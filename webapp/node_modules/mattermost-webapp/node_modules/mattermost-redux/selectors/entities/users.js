"use strict";

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUserIdsInChannels = getUserIdsInChannels;
exports.getUserIdsNotInChannels = getUserIdsNotInChannels;
exports.getUserIdsInTeams = getUserIdsInTeams;
exports.getUserIdsNotInTeams = getUserIdsNotInTeams;
exports.getUserIdsWithoutTeam = getUserIdsWithoutTeam;
exports.getUserStatuses = getUserStatuses;
exports.getUserSessions = getUserSessions;
exports.getUserAudits = getUserAudits;
exports.getUser = getUser;
exports.getUserByUsername = getUserByUsername;
exports.getUserByEmail = getUserByEmail;
exports.getStatusForUserId = getStatusForUserId;
exports.getTotalUsersStats = getTotalUsersStats;
exports.searchProfiles = searchProfiles;
exports.searchProfilesInCurrentChannel = searchProfilesInCurrentChannel;
exports.searchProfilesNotInCurrentChannel = searchProfilesNotInCurrentChannel;
exports.searchProfilesInCurrentTeam = searchProfilesInCurrentTeam;
exports.searchProfilesInTeam = searchProfilesInTeam;
exports.searchProfilesNotInCurrentTeam = searchProfilesNotInCurrentTeam;
exports.searchProfilesWithoutTeam = searchProfilesWithoutTeam;
exports.makeGetProfilesForReactions = makeGetProfilesForReactions;
exports.makeGetProfilesInChannel = makeGetProfilesInChannel;
exports.makeGetProfilesNotInChannel = makeGetProfilesNotInChannel;
exports.makeGetProfilesByIdsAndUsernames = makeGetProfilesByIdsAndUsernames;
exports.makeGetDisplayName = makeGetDisplayName;
Object.defineProperty(exports, "getCurrentUser", {
  enumerable: true,
  get: function get() {
    return _common.getCurrentUser;
  }
});
Object.defineProperty(exports, "getCurrentUserId", {
  enumerable: true,
  get: function get() {
    return _common.getCurrentUserId;
  }
});
Object.defineProperty(exports, "getUsers", {
  enumerable: true,
  get: function get() {
    return _common.getUsers;
  }
});
exports.getUsersInVisibleDMs = exports.shouldShowTermsOfService = exports.getProfilesWithoutTeam = exports.getProfilesNotInCurrentTeam = exports.getProfilesInTeam = exports.getProfilesInCurrentTeam = exports.getProfilesNotInCurrentChannel = exports.getProfilesInCurrentChannel = exports.getProfiles = exports.getProfileSetNotInCurrentTeam = exports.getProfileSetInCurrentTeam = exports.getProfileSetNotInCurrentChannel = exports.getProfileSetInCurrentChannel = exports.getCurrentUserMentionKeys = exports.getCurrentUserRoles = exports.isCurrentUserSystemAdmin = exports.getUsersByEmail = exports.getUsersByUsername = void 0;

var _reselect = require("reselect");

var _common = require("./common");

var _general = require("./general");

var _preferences = require("./preferences");

var _user_utils = require("../../utils/user_utils");

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow
function getUserIdsInChannels(state
/*: GlobalState*/
)
/*: RelationOneToMany<Channel, UserProfile>*/
{
  return state.entities.users.profilesInChannel;
}

function getUserIdsNotInChannels(state
/*: GlobalState*/
)
/*: RelationOneToMany<Channel, UserProfile>*/
{
  return state.entities.users.profilesNotInChannel;
}

function getUserIdsInTeams(state
/*: GlobalState*/
)
/*: RelationOneToMany<Team, UserProfile>*/
{
  return state.entities.users.profilesInTeam;
}

function getUserIdsNotInTeams(state
/*: GlobalState*/
)
/*: RelationOneToMany<Team, UserProfile>*/
{
  return state.entities.users.profilesNotInTeam;
}

function getUserIdsWithoutTeam(state
/*: GlobalState*/
)
/*: Set<$ID<UserProfile>>*/
{
  return state.entities.users.profilesWithoutTeam;
}

function getUserStatuses(state
/*: GlobalState*/
)
/*: RelationOneToOne<UserProfile, string>*/
{
  return state.entities.users.statuses;
}

function getUserSessions(state
/*: GlobalState*/
)
/*: Array<Object>*/
{
  return state.entities.users.mySessions;
}

function getUserAudits(state
/*: GlobalState*/
)
/*: Array<Object>*/
{
  return state.entities.users.myAudits;
}

function getUser(state
/*: GlobalState*/
, id
/*: $ID<UserProfile>*/
)
/*: UserProfile*/
{
  return state.entities.users.profiles[id];
}

const getUsersByUsername
/*: (GlobalState) => UsernameMappedObjects<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, users => {
  const usersByUsername = {};

  for (const id in users) {
    if (users.hasOwnProperty(id)) {
      const user = users[id];
      usersByUsername[user.username] = user;
    }
  }

  return usersByUsername;
});
exports.getUsersByUsername = getUsersByUsername;

function getUserByUsername(state
/*: GlobalState*/
, username
/*: $Username<UserProfile>*/
)
/*: UserProfile*/
{
  return getUsersByUsername(state)[username];
}

const getUsersByEmail
/*: (GlobalState) => EmailMappedObjects<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, users => {
  const usersByEmail = {};

  for (const user of Object.keys(users).map(key => users[key])) {
    usersByEmail[user.email] = user;
  }

  return usersByEmail;
});
exports.getUsersByEmail = getUsersByEmail;

function getUserByEmail(state
/*: GlobalState*/
, email
/*: $Email<UserProfile>*/
)
/*: UserProfile*/
{
  return getUsersByEmail(state)[email];
}

const isCurrentUserSystemAdmin
/*: (GlobalState) => boolean*/
= (0, _reselect.createSelector)(_common.getCurrentUser, user => {
  const roles = user.roles || '';
  return (0, _user_utils.isSystemAdmin)(roles);
});
exports.isCurrentUserSystemAdmin = isCurrentUserSystemAdmin;
const getCurrentUserRoles
/*: (GlobalState) => $PropertyType<UserProfile, 'roles'>*/
= (0, _reselect.createSelector)(_common.getMyCurrentChannelMembership, state => state.entities.teams.myMembers[state.entities.teams.currentTeamId], _common.getCurrentUser, (currentChannelMembership, currentTeamMembership, currentUser) => {
  let roles = '';

  if (currentTeamMembership) {
    roles += "".concat(currentTeamMembership.roles, " ");
  }

  if (currentChannelMembership) {
    roles += "".concat(currentChannelMembership.roles, " ");
  }

  if (currentUser) {
    roles += currentUser.roles;
  }

  return roles.trim();
});
exports.getCurrentUserRoles = getCurrentUserRoles;
const getCurrentUserMentionKeys
/*: (GlobalState) => Array<{key: string, caseSensitive?: boolean}>*/
= (0, _reselect.createSelector)(_common.getCurrentUser, user => {
  let keys = [];

  if (!user || !user.notify_props) {
    return keys;
  }

  if (user.notify_props.mention_keys) {
    keys = keys.concat(user.notify_props.mention_keys.split(',').map(key => {
      return {
        key
      };
    }));
  }

  if (user.notify_props.first_name === 'true' && user.first_name) {
    keys.push({
      key: user.first_name,
      caseSensitive: true
    });
  }

  if (user.notify_props.channel === 'true') {
    keys.push({
      key: '@channel'
    });
    keys.push({
      key: '@all'
    });
    keys.push({
      key: '@here'
    });
  }

  const usernameKey = '@' + user.username;

  if (keys.findIndex(key => key.key === usernameKey) === -1) {
    keys.push({
      key: usernameKey
    });
  }

  return keys;
});
exports.getCurrentUserMentionKeys = getCurrentUserMentionKeys;
const getProfileSetInCurrentChannel
/*: (GlobalState) => Array<$ID<UserProfile>>*/
= (0, _reselect.createSelector)(_common.getCurrentChannelId, getUserIdsInChannels, (currentChannel, channelProfiles) => {
  return channelProfiles[currentChannel];
});
exports.getProfileSetInCurrentChannel = getProfileSetInCurrentChannel;
const getProfileSetNotInCurrentChannel
/*: (GlobalState) => Array<$ID<UserProfile>>*/
= (0, _reselect.createSelector)(_common.getCurrentChannelId, getUserIdsNotInChannels, (currentChannel, channelProfiles) => {
  return channelProfiles[currentChannel];
});
exports.getProfileSetNotInCurrentChannel = getProfileSetNotInCurrentChannel;
const getProfileSetInCurrentTeam
/*: (GlobalState) => Array<$ID<UserProfile>>*/
= (0, _reselect.createSelector)(state => state.entities.teams.currentTeamId, getUserIdsInTeams, (currentTeam, teamProfiles) => {
  return teamProfiles[currentTeam];
});
exports.getProfileSetInCurrentTeam = getProfileSetInCurrentTeam;
const getProfileSetNotInCurrentTeam
/*: (GlobalState) => Array<$ID<UserProfile>>*/
= (0, _reselect.createSelector)(state => state.entities.teams.currentTeamId, getUserIdsNotInTeams, (currentTeam, teamProfiles) => {
  return teamProfiles[currentTeam];
});
exports.getProfileSetNotInCurrentTeam = getProfileSetNotInCurrentTeam;
const PROFILE_SET_ALL = 'all';

function sortAndInjectProfiles(profiles
/*: IDMappedObjects<UserProfile>*/
, profileSet
/*:: ?: 'all' | Array<$ID<UserProfile>> | Set<$ID<UserProfile>>*/
, skipInactive = false)
/*: Array<UserProfile>*/
{
  let currentProfiles = [];

  if (typeof profileSet === 'undefined') {
    return currentProfiles;
  } else if (profileSet === PROFILE_SET_ALL) {
    currentProfiles = Object.keys(profiles).map(key => profiles[key]);
  } else {
    currentProfiles = Array.from(profileSet).map(p => profiles[p]);
  }

  currentProfiles = currentProfiles.filter(profile => Boolean(profile));

  if (skipInactive) {
    currentProfiles = currentProfiles.filter(profile => !(profile.delete_at && profile.delete_at !== 0));
  }

  return currentProfiles.sort(_user_utils.sortByUsername);
}

const getProfiles
/*: (GlobalState, Filters) => Array<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, (state, filters) => filters, (profiles, filters) => {
  return sortAndInjectProfiles(filterProfiles(profiles, filters), PROFILE_SET_ALL);
});
exports.getProfiles = getProfiles;

function filterProfiles(profiles
/*: IDMappedObjects<UserProfile>*/
, filters
/*:: ?: Filters*/
)
/*: IDMappedObjects<UserProfile>*/
{
  if (!filters) {
    return profiles;
  }

  let users = Object.keys(profiles).map(key => profiles[key]);

  if (filters.role && filters.role !== '') {
    users = users.filter(user => user.roles && user.roles.includes(filters && filters.role || ''));
  }

  if (filters.inactive) {
    users = users.filter(user => user.delete_at !== 0);
  }

  return users.reduce((acc, user) => {
    acc[user.id] = user;
    return acc;
  }, {});
}

const getProfilesInCurrentChannel
/*: (GlobalState) => Array<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, getProfileSetInCurrentChannel, (profiles, currentChannelProfileSet) => {
  return sortAndInjectProfiles(profiles, currentChannelProfileSet);
});
exports.getProfilesInCurrentChannel = getProfilesInCurrentChannel;
const getProfilesNotInCurrentChannel
/*: (GlobalState) => Array<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, getProfileSetNotInCurrentChannel, (profiles, notInCurrentChannelProfileSet) => {
  return sortAndInjectProfiles(profiles, notInCurrentChannelProfileSet);
});
exports.getProfilesNotInCurrentChannel = getProfilesNotInCurrentChannel;
const getProfilesInCurrentTeam
/*: (GlobalState) => Array<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, getProfileSetInCurrentTeam, (profiles, currentTeamProfileSet) => {
  return sortAndInjectProfiles(profiles, currentTeamProfileSet);
});
exports.getProfilesInCurrentTeam = getProfilesInCurrentTeam;
const getProfilesInTeam
/*: (GlobalState, $ID<Team>) => Array<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, getUserIdsInTeams, (state, teamId) => teamId, (state, teamId, filters) => filters, (profiles, usersInTeams, teamId, filters) => {
  return sortAndInjectProfiles(filterProfiles(profiles, filters), usersInTeams[teamId] || new Set());
});
exports.getProfilesInTeam = getProfilesInTeam;
const getProfilesNotInCurrentTeam
/*: (GlobalState) => Array<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, getProfileSetNotInCurrentTeam, (profiles, notInCurrentTeamProfileSet) => {
  return sortAndInjectProfiles(profiles, notInCurrentTeamProfileSet);
});
exports.getProfilesNotInCurrentTeam = getProfilesNotInCurrentTeam;
const getProfilesWithoutTeam
/*: (GlobalState, filters?: Filters) => Array<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, getUserIdsWithoutTeam, (state, filters) => filters, (profiles, withoutTeamProfileSet, filters) => {
  return sortAndInjectProfiles(filterProfiles(profiles, filters), withoutTeamProfileSet);
});
exports.getProfilesWithoutTeam = getProfilesWithoutTeam;

function getStatusForUserId(state
/*: GlobalState*/
, userId
/*: $ID<UserProfile>*/
)
/*: string*/
{
  return getUserStatuses(state)[userId];
}

function getTotalUsersStats(state
/*: GlobalState*/
)
/*: Object*/
{
  return state.entities.users.stats;
}

function searchProfiles(state
/*: GlobalState*/
, term
/*: string*/
, skipCurrent
/*: boolean*/
= false, filters
/*:: ?: Filters*/
)
/*: Array<UserProfile>*/
{
  const users = (0, _common.getUsers)(state);
  const profiles = (0, _user_utils.filterProfilesMatchingTerm)(Object.keys(users).map(key => users[key]), term);
  const filteredProfilesMap = filterProfiles((0, _user_utils.profileListToMap)(profiles), filters);
  const filteredProfiles = Object.keys(filteredProfilesMap).map(key => filteredProfilesMap[key]);

  if (skipCurrent) {
    removeCurrentUserFromList(filteredProfiles, (0, _common.getCurrentUserId)(state));
  }

  return filteredProfiles;
}

function searchProfilesInCurrentChannel(state
/*: GlobalState*/
, term
/*: string*/
, skipCurrent
/*: boolean*/
= false)
/*: Array<UserProfile>*/
{
  const profiles = (0, _user_utils.filterProfilesMatchingTerm)(getProfilesInCurrentChannel(state), term);

  if (skipCurrent) {
    removeCurrentUserFromList(profiles, (0, _common.getCurrentUserId)(state));
  }

  return profiles;
}

function searchProfilesNotInCurrentChannel(state
/*: GlobalState*/
, term
/*: string*/
, skipCurrent
/*: boolean*/
= false)
/*: Array<UserProfile>*/
{
  const profiles = (0, _user_utils.filterProfilesMatchingTerm)(getProfilesNotInCurrentChannel(state), term);

  if (skipCurrent) {
    removeCurrentUserFromList(profiles, (0, _common.getCurrentUserId)(state));
  }

  return profiles;
}

function searchProfilesInCurrentTeam(state
/*: GlobalState*/
, term
/*: string*/
, skipCurrent
/*: boolean*/
= false)
/*: Array<UserProfile>*/
{
  const profiles = (0, _user_utils.filterProfilesMatchingTerm)(getProfilesInCurrentTeam(state), term);

  if (skipCurrent) {
    removeCurrentUserFromList(profiles, (0, _common.getCurrentUserId)(state));
  }

  return profiles;
}

function searchProfilesInTeam(state
/*: GlobalState*/
, teamId
/*: $ID<Team>*/
, term
/*: string*/
, skipCurrent
/*: boolean*/
= false, filters
/*:: ?: Filters*/
)
/*: Array<UserProfile>*/
{
  const profiles = (0, _user_utils.filterProfilesMatchingTerm)(getProfilesInTeam(state, teamId), term);
  const filteredProfilesMap = filterProfiles((0, _user_utils.profileListToMap)(profiles), filters);
  const filteredProfiles = Object.keys(filteredProfilesMap).map(key => filteredProfilesMap[key]);

  if (skipCurrent) {
    removeCurrentUserFromList(filteredProfiles, (0, _common.getCurrentUserId)(state));
  }

  return filteredProfiles;
}

function searchProfilesNotInCurrentTeam(state
/*: GlobalState*/
, term
/*: string*/
, skipCurrent
/*: boolean*/
= false)
/*: Array<UserProfile>*/
{
  const profiles = (0, _user_utils.filterProfilesMatchingTerm)(getProfilesNotInCurrentTeam(state), term);

  if (skipCurrent) {
    removeCurrentUserFromList(profiles, (0, _common.getCurrentUserId)(state));
  }

  return profiles;
}

function searchProfilesWithoutTeam(state
/*: GlobalState*/
, term
/*: string*/
, skipCurrent
/*: boolean*/
= false, filters
/*:: ?: Filters*/
)
/*: Array<UserProfile>*/
{
  const filteredProfiles = (0, _user_utils.filterProfilesMatchingTerm)(getProfilesWithoutTeam(state, filters), term);

  if (skipCurrent) {
    removeCurrentUserFromList(filteredProfiles, (0, _common.getCurrentUserId)(state));
  }

  return filteredProfiles;
}

function removeCurrentUserFromList(profiles
/*: Array<UserProfile>*/
, currentUserId
/*: $ID<UserProfile>*/
) {
  const index = profiles.findIndex(p => p.id === currentUserId);

  if (index >= 0) {
    profiles.splice(index, 1);
  }
}

const shouldShowTermsOfService
/*: (GlobalState) => boolean*/
= (0, _reselect.createSelector)(_general.getConfig, _common.getCurrentUser, _general.getLicense, (config, user, license) => {
  // Defaults to false if the user is not logged in or the setting doesn't exist
  const acceptedTermsId = user ? user.terms_of_service_id : '';
  const acceptedAt = user ? user.terms_of_service_create_at : 0;
  const featureEnabled = license.IsLicensed === 'true' && config.EnableCustomTermsOfService === 'true';
  const reacceptanceTime = config.CustomTermsOfServiceReAcceptancePeriod * 1000 * 60 * 60 * 24;
  const timeElapsed = new Date().getTime() - acceptedAt;
  return Boolean(user && featureEnabled && (config.CustomTermsOfServiceId !== acceptedTermsId || timeElapsed > reacceptanceTime));
});
exports.shouldShowTermsOfService = shouldShowTermsOfService;
const getUsersInVisibleDMs
/*: (GlobalState) => Array<UserProfile>*/
= (0, _reselect.createSelector)(_common.getUsers, _preferences.getDirectShowPreferences, (users, preferences) => {
  const dmUsers = [];
  preferences.forEach(pref => {
    if (pref.value === 'true' && users[pref.name]) {
      dmUsers.push(users[pref.name]);
    }
  });
  return dmUsers;
});
exports.getUsersInVisibleDMs = getUsersInVisibleDMs;

function makeGetProfilesForReactions()
/*: (GlobalState, Array<Reaction>) => Array<UserProfile>*/
{
  return (0, _reselect.createSelector)(_common.getUsers, (state, reactions) => reactions, (users, reactions) => {
    const profiles = [];
    reactions.forEach(r => {
      if (users[r.user_id]) {
        profiles.push(users[r.user_id]);
      }
    });
    return profiles;
  });
}

function makeGetProfilesInChannel()
/*: (GlobalState, $ID<Channel>, boolean) => Array<UserProfile>*/
{
  return (0, _reselect.createSelector)(_common.getUsers, getUserIdsInChannels, (state, channelId) => channelId, (state, channelId, skipInactive) => skipInactive, (users, userIds, channelId, skipInactive = false) => {
    const userIdsInChannel = userIds[channelId];

    if (!userIdsInChannel) {
      return [];
    }

    return sortAndInjectProfiles(users, userIdsInChannel, skipInactive);
  });
}

function makeGetProfilesNotInChannel()
/*: (GlobalState, $ID<Channel>, boolean) => Array<UserProfile>*/
{
  return (0, _reselect.createSelector)(_common.getUsers, getUserIdsNotInChannels, (state, channelId) => channelId, (state, channelId, skipInactive) => skipInactive, (users, userIds, channelId, skipInactive = false) => {
    const userIdsInChannel = userIds[channelId];

    if (!userIdsInChannel) {
      return [];
    }

    return sortAndInjectProfiles(users, userIdsInChannel, skipInactive);
  });
}

function makeGetProfilesByIdsAndUsernames()
/*: (GlobalState, {allUserIds: Array<$ID<UserProfile>>, allUsernames: Array<$Username<UserProfile>>}) => Array<UserProfile>*/
{
  return (0, _reselect.createSelector)(_common.getUsers, getUsersByUsername, (state, props) => props.allUserIds, (state, props) => props.allUsernames, (allProfilesById, allProfilesByUsername, allUserIds, allUsernames) => {
    const userProfiles = [];

    if (allUserIds && allUserIds.length > 0) {
      const profilesById = allUserIds.filter(userId => allProfilesById[userId]).map(userId => allProfilesById[userId]);

      if (profilesById && profilesById.length > 0) {
        userProfiles.push(...profilesById);
      }
    }

    if (allUsernames && allUsernames.length > 0) {
      const profilesByUsername = allUsernames.filter(username => allProfilesByUsername[username]).map(username => allProfilesByUsername[username]);

      if (profilesByUsername && profilesByUsername.length > 0) {
        userProfiles.push(...profilesByUsername);
      }
    }

    return userProfiles;
  });
}

function makeGetDisplayName()
/*: (GlobalState, $ID<UserProfile>, boolean) => string*/
{
  return (0, _reselect.createSelector)((state, userId) => getUser(state, userId), _preferences.getTeammateNameDisplaySetting, (state, _, useFallbackUsername = true) => useFallbackUsername, (user, teammateNameDisplaySetting, useFallbackUsername) => {
    return (0, _user_utils.displayUsername)(user, teammateNameDisplaySetting, useFallbackUsername);
  });
}