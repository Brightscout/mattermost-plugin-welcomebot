"use strict";

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllPosts = getAllPosts;
exports.getPost = getPost;
exports.getPostsInThread = getPostsInThread;
exports.getReactionsForPosts = getReactionsForPosts;
exports.makeGetReactionsForPost = makeGetReactionsForPost;
exports.getOpenGraphMetadata = getOpenGraphMetadata;
exports.getOpenGraphMetadataForUrl = getOpenGraphMetadataForUrl;
exports.getPostIdsInCurrentChannel = getPostIdsInCurrentChannel;
exports.makeGetPostIdsForThread = makeGetPostIdsForThread;
exports.makeGetPostsChunkAroundPost = makeGetPostsChunkAroundPost;
exports.makeGetPostIdsAroundPost = makeGetPostIdsAroundPost;
exports.makeGetPostsInChannel = makeGetPostsInChannel;
exports.makeGetPostsAroundPost = makeGetPostsAroundPost;
exports.makeGetPostsForThread = makeGetPostsForThread;
exports.makeGetCommentCountForPost = makeGetCommentCountForPost;
exports.getSearchMatches = getSearchMatches;
exports.makeGetMessageInHistoryItem = makeGetMessageInHistoryItem;
exports.makeGetPostsForIds = makeGetPostsForIds;
exports.getRecentPostsChunkInChannel = getRecentPostsChunkInChannel;
exports.getPostIdsInChannel = getPostIdsInChannel;
exports.getPostsChunkInChannelAroundTime = getPostsChunkInChannelAroundTime;
exports.getUnreadPostsChunk = getUnreadPostsChunk;
exports.getExpandedLink = getExpandedLink;
exports.makeIsPostCommentMention = exports.isPostIdSending = exports.getCurrentUsersLatestPost = exports.getLatestReplyablePostId = exports.getMostRecentPostIdInChannel = exports.getLastPostPerChannel = exports.getSearchResults = exports.getPostsInCurrentChannel = void 0;

var _reselect = require("reselect");

var _common = require("./common");

var _preferences = require("./preferences");

var _helpers = require("../../utils/helpers");

var _constants = require("../../constants");

var _post_utils = require("../../utils/post_utils");

var _preference_utils = require("../../utils/preference_utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getAllPosts(state
/*: GlobalState*/
) {
  return state.entities.posts.posts;
}

function getPost(state
/*: GlobalState*/
, postId
/*: $ID<Post>*/
)
/*: Post*/
{
  return getAllPosts(state)[postId];
}

function getPostsInThread(state
/*: GlobalState*/
)
/*: RelationOneToMany<Post, Post>*/
{
  return state.entities.posts.postsInThread;
}

function getReactionsForPosts(state
/*: GlobalState*/
)
/*: RelationOneToOne<Post, {[string]: Reaction}>*/
{
  return state.entities.posts.reactions;
}

function makeGetReactionsForPost()
/*: (GlobalState, $ID<Post>) => ?{[string]: Reaction}*/
{
  return (0, _reselect.createSelector)(getReactionsForPosts, (state
  /*: GlobalState*/
  , postId) => postId, (reactions, postId) => {
    if (reactions[postId]) {
      return reactions[postId];
    }

    return null;
  });
}

function getOpenGraphMetadata(state
/*: GlobalState*/
)
/*: RelationOneToOne<Post, Object>*/
{
  return state.entities.posts.openGraph;
}

function getOpenGraphMetadataForUrl(state
/*: GlobalState*/
, url
/*: string*/
)
/*: Object*/
{
  return state.entities.posts.openGraph[url];
} // getPostIdsInCurrentChannel returns the IDs of posts loaded at the bottom of the channel. It does not include older
// posts such as those loaded by viewing a thread or a permalink.


function getPostIdsInCurrentChannel(state
/*: GlobalState*/
)
/*: ?Array<$ID<Post>>*/
{
  return getPostIdsInChannel(state, state.entities.channels.currentChannelId);
} // getPostsInCurrentChannel returns the posts loaded at the bottom of the channel. It does not include older posts
// such as those loaded by viewing a thread or a permalink.


const getPostsInCurrentChannel
/*: (GlobalState) => ?Array<PostWithFormatData>*/
= (() => {
  const getPostsInChannel = makeGetPostsInChannel();
  return (state
  /*: GlobalState*/
  ) => getPostsInChannel(state, state.entities.channels.currentChannelId, -1);
})();

exports.getPostsInCurrentChannel = getPostsInCurrentChannel;

function makeGetPostIdsForThread()
/*: (GlobalState, $ID<Post>) => Array<$ID<Post>>*/
{
  return (0, _helpers.createIdsSelector)(getAllPosts, (state
  /*: GlobalState*/
  , rootId) => state.entities.posts.postsInThread[rootId] || [], (state
  /*: GlobalState*/
  , rootId) => state.entities.posts.posts[rootId], (posts, postsForThread, rootPost) => {
    const thread = [];

    if (rootPost) {
      thread.push(rootPost);
    }

    postsForThread.forEach(id => {
      const post = posts[id];

      if (post) {
        thread.push(post);
      }
    });
    thread.sort(_post_utils.comparePosts);
    return thread.map(post => post.id);
  });
}

function makeGetPostsChunkAroundPost()
/*: (GlobalState, $ID<Post>, $ID<Channel>) => Object*/
{
  return (0, _helpers.createIdsSelector)((state
  /*: GlobalState*/
  , postId, channelId) => state.entities.posts.postsInChannel[channelId], (state
  /*: GlobalState*/
  , postId) => postId, (postsForChannel, postId) => {
    if (!postsForChannel) {
      return null;
    }

    let postChunk = null;

    for (const block of postsForChannel) {
      const index = block.order.indexOf(postId);

      if (index === -1) {
        continue;
      }

      postChunk = block;
    }

    return postChunk;
  });
}

function makeGetPostIdsAroundPost()
/*: (GlobalState, $ID<Post>, $ID<Channel>, {postsBeforeCount: number, postsAfterCount: number}) => ?Array<$ID<Post>>*/
{
  const getPostsChunkAroundPost = makeGetPostsChunkAroundPost();
  return (0, _helpers.createIdsSelector)((state
  /*: GlobalState*/
  , postId, channelId) => getPostsChunkAroundPost(state, postId, channelId), (state
  /*: GlobalState*/
  , postId) => postId, (state
  /*: GlobalState*/
  , postId, channelId, options) => options && options.postsBeforeCount, (state
  /*: GlobalState*/
  , postId, channelId, options) => options && options.postsAfterCount, (postsChunk, postId, postsBeforeCount = _constants.Posts.POST_CHUNK_SIZE / 2, postsAfterCount = _constants.Posts.POST_CHUNK_SIZE / 2) => {
    if (!postsChunk || !postsChunk.order) {
      return null;
    }

    const postIds = postsChunk.order;
    const index = postIds.indexOf(postId); // Remember that posts that come after the post have a smaller index

    const minPostIndex = postsAfterCount === -1 ? 0 : Math.max(index - postsAfterCount, 0);
    const maxPostIndex = postsBeforeCount === -1 ? postIds.length : Math.min(index + postsBeforeCount + 1, postIds.length); // Needs the extra 1 to include the focused post

    return postIds.slice(minPostIndex, maxPostIndex);
  });
}

function formatPostInChannel(post
/*: Post*/
, previousPost
/*: ?Post*/
, index
/*: number*/
, allPosts
/*: IDMappedObjects<Post>*/
, postsInThread
/*: RelationOneToMany<Post, Post>*/
, postIds
/*: Array<$ID<Post>>*/
, currentUser
/*: UserProfile*/
, focusedPostId
/*: $ID<Post>*/
)
/*: PostWithFormatData*/
{
  let isFirstReply = false;
  let isLastReply = false;
  let highlight = false;
  let commentedOnPost;

  if (post.id === focusedPostId) {
    highlight = true;
  }

  if (post.root_id) {
    if (previousPost && previousPost.root_id !== post.root_id) {
      // Post is the first reply in a list of consecutive replies
      isFirstReply = true;

      if (previousPost && previousPost.id !== post.root_id) {
        commentedOnPost = allPosts[post.root_id];
      }
    }

    if (index - 1 < 0 || allPosts[postIds[index - 1]].root_id !== post.root_id) {
      // Post is the last reply in a list of consecutive replies
      isLastReply = true;
    }
  }

  let previousPostIsComment = false;

  if (previousPost && previousPost.root_id) {
    previousPostIsComment = true;
  }

  const postFromWebhook = Boolean(post.props && post.props.from_webhook);
  const prevPostFromWebhook = Boolean(previousPost && previousPost.props && previousPost.props.from_webhook);
  let consecutivePostByUser = false;

  if (previousPost && previousPost.user_id === post.user_id && post.create_at - previousPost.create_at <= _constants.Posts.POST_COLLAPSE_TIMEOUT && !postFromWebhook && !prevPostFromWebhook && !(0, _post_utils.isSystemMessage)(post) && !(0, _post_utils.isSystemMessage)(previousPost)) {
    // The last post and this post were made by the same user within some time
    consecutivePostByUser = true;
  }

  let threadRepliedToByCurrentUser = false;
  let replyCount = 0;
  let isCommentMention = false;

  if (currentUser) {
    const rootId = post.root_id || post.id;
    const threadIds = postsInThread[rootId] || [];

    for (const pid of threadIds) {
      const p = allPosts[pid];

      if (!p) {
        continue;
      }

      if (p.user_id === currentUser.id) {
        threadRepliedToByCurrentUser = true;
      }

      if (!(0, _post_utils.isPostEphemeral)(p)) {
        replyCount += 1;
      }
    }

    const rootPost = allPosts[rootId];
    isCommentMention = (0, _post_utils.isPostCommentMention)({
      post,
      currentUser,
      threadRepliedToByCurrentUser,
      rootPost
    });
  }

  return _objectSpread({}, post, {
    isFirstReply,
    isLastReply,
    previousPostIsComment,
    commentedOnPost,
    consecutivePostByUser,
    replyCount,
    isCommentMention,
    highlight
  });
} // makeGetPostsInChannel creates a selector that returns up to the given number of posts loaded at the bottom of the
// given channel. It does not include older posts such as those loaded by viewing a thread or a permalink.


function makeGetPostsInChannel()
/*: (GlobalState, $ID<Channel>, number) => ?Array<PostWithFormatData>*/
{
  return (0, _reselect.createSelector)(getAllPosts, getPostsInThread, (state
  /*: GlobalState*/
  , channelId
  /*: $ID<Channel>*/
  ) => getPostIdsInChannel(state, channelId), _common.getCurrentUser, _preferences.getMyPreferences, (state
  /*: GlobalState*/
  , channelId
  /*: $ID<Channel>*/
  , numPosts
  /*: number*/
  ) => numPosts || _constants.Posts.POST_CHUNK_SIZE, (allPosts, postsInThread, allPostIds, currentUser, myPreferences, numPosts) => {
    if (!allPostIds) {
      return null;
    }

    const posts = [];
    const joinLeavePref = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_ADVANCED_SETTINGS, _constants.Preferences.ADVANCED_FILTER_JOIN_LEAVE)];
    const showJoinLeave = joinLeavePref ? joinLeavePref.value !== 'false' : true;
    const postIds = numPosts === -1 ? allPostIds : allPostIds.slice(0, numPosts);

    for (let i = 0; i < postIds.length; i++) {
      const post = allPosts[postIds[i]];

      if ((0, _post_utils.shouldFilterJoinLeavePost)(post, showJoinLeave, currentUser ? currentUser.username : '')) {
        continue;
      }

      const previousPost = allPosts[postIds[i + 1]] || null;
      posts.push(formatPostInChannel(post, previousPost, i, allPosts, postsInThread, postIds, currentUser, ''));
    }

    return posts;
  });
}

function makeGetPostsAroundPost()
/*: (GlobalState, $ID<Post>, $ID<Channel>) => ?Array<PostWithFormatData>*/
{
  const getPostIdsAroundPost = makeGetPostIdsAroundPost();
  const options = {
    postsBeforeCount: -1,
    // Where this is used in the web app, view state is used to determine how far back to display
    postsAfterCount: _constants.Posts.POST_CHUNK_SIZE / 2
  };
  return (0, _reselect.createSelector)((state
  /*: GlobalState*/
  , focusedPostId, channelId) => getPostIdsAroundPost(state, focusedPostId, channelId, options), getAllPosts, getPostsInThread, (state
  /*: GlobalState*/
  , focusedPostId) => focusedPostId, _common.getCurrentUser, _preferences.getMyPreferences, (postIds, allPosts, postsInThread, focusedPostId, currentUser, myPreferences) => {
    if (!postIds || !currentUser) {
      return null;
    }

    const posts = [];
    const joinLeavePref = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_ADVANCED_SETTINGS, _constants.Preferences.ADVANCED_FILTER_JOIN_LEAVE)];
    const showJoinLeave = joinLeavePref ? joinLeavePref.value !== 'false' : true;

    for (let i = 0; i < postIds.length; i++) {
      const post = allPosts[postIds[i]];

      if ((0, _post_utils.shouldFilterJoinLeavePost)(post, showJoinLeave, currentUser.username)) {
        continue;
      }

      const previousPost = allPosts[postIds[i + 1]] || null;
      const formattedPost = formatPostInChannel(post, previousPost, i, allPosts, postsInThread, postIds, currentUser, focusedPostId);
      posts.push(formattedPost);
    }

    return posts;
  });
} // Returns a function that creates a creates a selector that will get the posts for a given thread.
// That selector will take a props object (containing a rootId field) as its
// only argument and will be memoized based on that argument.


function makeGetPostsForThread()
/*: (GlobalState, {rootId: $ID<Post>}) => Array<Post>*/
{
  return (0, _reselect.createSelector)(getAllPosts, (state
  /*: GlobalState*/
  , {
    rootId
  }) => state.entities.posts.postsInThread[rootId] || [], (state
  /*: GlobalState*/
  , {
    rootId
  }) => state.entities.posts.posts[rootId], (posts, postsForThread, rootPost) => {
    const thread = [];

    if (rootPost) {
      thread.push(rootPost);
    }

    postsForThread.forEach(id => {
      const post = posts[id];

      if (post) {
        thread.push(post);
      }
    });
    thread.sort(_post_utils.comparePosts);
    return thread;
  });
}

function makeGetCommentCountForPost()
/*: (GlobalState, {post: Post}) => number*/
{
  return (0, _reselect.createSelector)(getAllPosts, (state, {
    post
  }) => state.entities.posts.postsInThread[post ? post.id : ''] || [], (state, props) => props, (posts, postsForThread, {
    post: currentPost
  }) => {
    if (!currentPost) {
      return 0;
    }

    let count = 0;
    postsForThread.forEach(id => {
      const post = posts[id];

      if (post && post.state !== _constants.Posts.POST_DELETED && !(0, _post_utils.isPostEphemeral)(post)) {
        count += 1;
      }
    });
    return count;
  });
}

const getSearchResults
/*: (GlobalState) => Array<Post>*/
= (0, _reselect.createSelector)(getAllPosts, (state
/*: GlobalState*/
) => state.entities.search.results, (posts, postIds) => {
  if (!postIds) {
    return [];
  }

  return postIds.map(id => posts[id]);
}); // Returns the matched text from the search results, if the server has provided them.
// These matches will only be present if the server is running Mattermost 5.1 or higher
// with Elasticsearch enabled to search posts. Otherwise, null will be returned.

exports.getSearchResults = getSearchResults;

function getSearchMatches(state
/*: GlobalState*/
)
/*: {[string]: Array<string>}*/
{
  return state.entities.search.matches;
}

function makeGetMessageInHistoryItem(type
/*: string*/
)
/*: (GlobalState) => string*/
{
  return (0, _reselect.createSelector)((state
  /*: GlobalState*/
  ) => state.entities.posts.messagesHistory, messagesHistory => {
    const idx = messagesHistory.index[type];
    const messages = messagesHistory.messages;

    if (idx >= 0 && messages && messages.length > idx) {
      return messages[idx];
    }

    return '';
  });
}

function makeGetPostsForIds()
/*: (GlobalState, Array<$ID<Post>>) => Array<Post>*/
{
  return (0, _helpers.createIdsSelector)(getAllPosts, (state
  /*: GlobalState*/
  , postIds) => postIds, (allPosts, postIds) => {
    if (!postIds) {
      return [];
    }

    return postIds.map(id => allPosts[id]);
  });
}

const getLastPostPerChannel
/*: (GlobalState) => RelationOneToOne<Channel, Post>*/
= (0, _reselect.createSelector)(getAllPosts, (state
/*: GlobalState*/
) => state.entities.posts.postsInChannel, (allPosts, postsInChannel) => {
  const ret = {};

  for (const [channelId, postsForChannel] of Object.entries(postsInChannel)) {
    const recentBlock = (postsForChannel
    /*: any*/
    ).find(block => block.recent);

    if (!recentBlock) {
      continue;
    }

    const postId = recentBlock.order[0];

    if (allPosts.hasOwnProperty(postId)) {
      ret[channelId] = allPosts[postId];
    }
  }

  return ret;
});
exports.getLastPostPerChannel = getLastPostPerChannel;
const getMostRecentPostIdInChannel
/*: (GlobalState, $ID<Channel>) => ?$ID<Post>*/
= (0, _reselect.createSelector)(getAllPosts, (state
/*: GlobalState*/
, channelId) => getPostIdsInChannel(state, channelId), _preferences.getMyPreferences, (posts, postIdsInChannel, preferences) => {
  if (!postIdsInChannel) {
    return '';
  }

  const key = (0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_ADVANCED_SETTINGS, _constants.Preferences.ADVANCED_FILTER_JOIN_LEAVE);
  const allowSystemMessages = preferences[key] ? preferences[key].value === 'true' : true;

  if (!allowSystemMessages) {
    // return the most recent non-system message in the channel
    let postId;

    for (let i = 0; i < postIdsInChannel.length; i++) {
      const p = posts[postIdsInChannel[i]];

      if (!p.type || !p.type.startsWith(_constants.Posts.SYSTEM_MESSAGE_PREFIX)) {
        postId = p.id;
        break;
      }
    }

    return postId;
  } // return the most recent message in the channel


  return postIdsInChannel[0];
});
exports.getMostRecentPostIdInChannel = getMostRecentPostIdInChannel;
const getLatestReplyablePostId
/*: (GlobalState) => $ID<Post>*/
= (0, _reselect.createSelector)(getPostsInCurrentChannel, posts => {
  if (!posts) {
    return '';
  }

  const latestReplyablePost = posts.find(post => post.state !== _constants.Posts.POST_DELETED && !(0, _post_utils.isSystemMessage)(post) && !(0, _post_utils.isPostEphemeral)(post));

  if (!latestReplyablePost) {
    return '';
  }

  return latestReplyablePost.id;
});
exports.getLatestReplyablePostId = getLatestReplyablePostId;
const getCurrentUsersLatestPost
/*: (GlobalState, $ID<Post>) => ?PostWithFormatData*/
= (0, _reselect.createSelector)(getPostsInCurrentChannel, _common.getCurrentUser, (_, rootId) => rootId, (posts, currentUser, rootId) => {
  if (!posts) {
    return null;
  }

  const lastPost = posts.find(post => {
    // don't edit webhook posts, deleted posts, or system messages
    if (post.user_id !== currentUser.id || post.props && post.props.from_webhook || post.state === _constants.Posts.POST_DELETED || (0, _post_utils.isSystemMessage)(post) || (0, _post_utils.isPostEphemeral)(post) || (0, _post_utils.isPostPendingOrFailed)(post)) {
      return false;
    }

    if (rootId) {
      return post.root_id === rootId || post.id === rootId;
    }

    return true;
  });
  return lastPost;
});
exports.getCurrentUsersLatestPost = getCurrentUsersLatestPost;

function getRecentPostsChunkInChannel(state
/*: GlobalState*/
, channelId
/*: $ID<Channel>*/
)
/*: Object*/
{
  const postsForChannel = state.entities.posts.postsInChannel[channelId];

  if (!postsForChannel) {
    return null;
  }

  return postsForChannel.find(block => block.recent);
} // getPostIdsInChannel returns the IDs of posts loaded at the bottom of the given channel. It does not include older
// posts such as those loaded by viewing a thread or a permalink.


function getPostIdsInChannel(state
/*: GlobalState*/
, channelId
/*: $ID<Channel>*/
)
/*: ?Array<$ID<Post>>*/
{
  const recentBlock = getRecentPostsChunkInChannel(state, channelId);

  if (!recentBlock) {
    return null;
  }

  return recentBlock.order;
}

function getPostsChunkInChannelAroundTime(state
/*: GlobalState*/
, channelId
/*: $ID<Channel>*/
, timeStamp
/*: number*/
)
/*: ?Object*/
{
  const postsEntity = state.entities.posts;
  const postsForChannel = postsEntity.postsInChannel[channelId];
  const posts = postsEntity.posts;

  if (!postsForChannel) {
    return null;
  }

  const blockAroundTimestamp = postsForChannel.find(block => {
    const {
      order
    } = block;
    const recentPostInBlock = posts[order[0]];
    const oldestPostInBlock = posts[order[order.length - 1]];

    if (recentPostInBlock && oldestPostInBlock) {
      return recentPostInBlock.create_at >= timeStamp && oldestPostInBlock.create_at <= timeStamp;
    }

    return false;
  });
  return blockAroundTimestamp;
}

function getUnreadPostsChunk(state
/*: GlobalState*/
, channelId
/*: $ID<Channel>*/
, timeStamp
/*: number*/
)
/*: ?Object*/
{
  const postsEntity = state.entities.posts;
  const posts = postsEntity.posts;
  const recentChunk = getRecentPostsChunkInChannel(state, channelId);

  if (recentChunk) {
    // This would happen if there are no posts in channel.
    // If the system messages are deleted by sys admin.
    // Experimental changes like hiding Join/Leave still will have recent chunk so it follows the default path based on timestamp
    if (!recentChunk.order.length) {
      return recentChunk;
    }

    const {
      order
    } = recentChunk;
    const oldestPostInBlock = posts[order[order.length - 1]]; // check for only oldest posts because this can be higher than the latest post if the last post is edited

    if (oldestPostInBlock.create_at <= timeStamp) {
      return recentChunk;
    }
  }

  return getPostsChunkInChannelAroundTime(state, channelId, timeStamp);
}

const isPostIdSending = (state
/*: GlobalState*/
, postId
/*: $ID<Post>*/
) =>
/*: boolean*/
state.entities.posts.pendingPostIds.some(sendingPostId => sendingPostId === postId);

exports.isPostIdSending = isPostIdSending;

const makeIsPostCommentMention = () =>
/*: ((GlobalState, $ID<Post>) => boolean)*/
{
  return (0, _reselect.createSelector)(getAllPosts, getPostsInThread, _common.getCurrentUser, getPost, (allPosts, postsInThread, currentUser, post) => {
    if (!post) {
      return false;
    }

    let threadRepliedToByCurrentUser = false;
    let isCommentMention = false;

    if (currentUser) {
      const rootId = post.root_id || post.id;
      const threadIds = postsInThread[rootId] || [];

      for (const pid of threadIds) {
        const p = allPosts[pid];

        if (!p) {
          continue;
        }

        if (p.user_id === currentUser.id) {
          threadRepliedToByCurrentUser = true;
        }
      }

      const rootPost = allPosts[rootId];
      isCommentMention = (0, _post_utils.isPostCommentMention)({
        post,
        currentUser,
        threadRepliedToByCurrentUser,
        rootPost
      });
    }

    return isCommentMention;
  });
};

exports.makeIsPostCommentMention = makeIsPostCommentMention;

function getExpandedLink(state
/*: GlobalState*/
, link
/*: string*/
)
/*: string*/
{
  return state.entities.posts.expandedURLs[link];
}