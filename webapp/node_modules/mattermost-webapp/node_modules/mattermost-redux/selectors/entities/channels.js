"use strict";

require("core-js/modules/es.string.includes");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllChannels = getAllChannels;
exports.getAllChannelStats = getAllChannelStats;
exports.getChannelsInTeam = getChannelsInTeam;
exports.getChannelMembersInChannels = getChannelMembersInChannels;
exports.filterChannels = filterChannels;
exports.makeGetChannel = makeGetChannel;
exports.isCurrentChannelReadOnly = isCurrentChannelReadOnly;
exports.isChannelReadOnlyById = isChannelReadOnlyById;
exports.isChannelReadOnly = isChannelReadOnly;
exports.shouldHideDefaultChannel = shouldHideDefaultChannel;
exports.getChannelByName = getChannelByName;
exports.getGroupOrDirectChannelVisibility = getGroupOrDirectChannelVisibility;
Object.defineProperty(exports, "getCurrentChannelId", {
  enumerable: true,
  get: function get() {
    return _common.getCurrentChannelId;
  }
});
Object.defineProperty(exports, "getMyChannelMemberships", {
  enumerable: true,
  get: function get() {
    return _common.getMyChannelMemberships;
  }
});
Object.defineProperty(exports, "getMyCurrentChannelMembership", {
  enumerable: true,
  get: function get() {
    return _common.getMyCurrentChannelMembership;
  }
});
exports.getRedirectChannelNameForTeam = exports.getMyFirstChannelForTeams = exports.getDefaultChannelForTeams = exports.getSortedDirectChannelWithUnreadsIds = exports.getSortedFavoriteChannelWithUnreadsIds = exports.getSortedPrivateChannelWithUnreadsIds = exports.getSortedPublicChannelWithUnreadsIds = exports.getOrderedChannelIds = exports.getAllSortedChannelIds = exports.getAllChannelIds = exports.getChannelsWithUserProfiles = exports.filterPostIds = exports.getSortedDirectChannelIds = exports.getDirectChannelIds = exports.getDirectAndGroupChannels = exports.getDirectChannels = exports.getSortedPrivateChannelIds = exports.getPrivateChannelIds = exports.getPrivateChannels = exports.getSortedPublicChannelIds = exports.getPublicChannelIds = exports.getPublicChannels = exports.getSortedFavoriteChannelIds = exports.getFavoriteChannelIds = exports.getFavoriteChannels = exports.getSortedUnreadChannelIds = exports.getMapAndSortedUnreadChannelIds = exports.getUnreadChannels = exports.getUnreadChannelIds = exports.getChannelIdsForCurrentTeam = exports.getChannelIdsInCurrentTeam = exports.getAllDirectChannelIds = exports.canManageAnyChannelMembersInCurrentTeam = exports.canManageChannelMembers = exports.getUnreadsInCurrentTeam = exports.getUnreads = exports.getMembersInCurrentChannel = exports.getDefaultChannel = exports.getChannelsWithUnreadSection = exports.getChannelsByCategory = exports.getArchivedChannels = exports.getOtherChannels = exports.getMyChannels = exports.getGroupChannels = exports.getAllDirectChannels = exports.getChannelsNameMapInCurrentTeam = exports.getChannelsNameMapInTeam = exports.getChannelsInCurrentTeam = exports.getChannelSetInCurrentTeam = exports.isCurrentChannelDefault = exports.isCurrentChannelArchived = exports.isCurrentChannelMuted = exports.isCurrentChannelFavorite = exports.getCurrentChannelStats = exports.getMyChannelMember = exports.getCurrentChannel = exports.getChannel = exports.mapAndSortChannelIds = exports.getDirectChannelsSet = void 0;

var _reselect = require("reselect");

var _constants = require("../../constants");

var _common = require("./common");

var _general = require("./general");

var _preferences = require("./preferences");

var _posts = require("./posts");

var _teams = require("./teams");

var _roles = require("./roles");

var _users = require("./users");

var _channel_utils = require("../../utils/channel_utils");

var _helpers = require("../../utils/helpers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getAllChannels(state
/*: GlobalState*/
)
/*: IDMappedObjects<Channel>*/
{
  return state.entities.channels.channels;
}

function getAllChannelStats(state
/*: GlobalState*/
)
/*: RelationOneToOne<Channel, ChannelStats>*/
{
  return state.entities.channels.stats;
}

function getChannelsInTeam(state
/*: GlobalState*/
)
/*: RelationOneToMany<Team, Channel>*/
{
  return state.entities.channels.channelsInTeam;
}

const getDirectChannelsSet
/*: (GlobalState) => Set<string>*/
= (0, _reselect.createSelector)(getChannelsInTeam, (channelsInTeam
/*: RelationOneToMany<Team, Channel>*/
) =>
/*: Set<string>*/
{
  return channelsInTeam && new Set(channelsInTeam['']) || new Set();
});
exports.getDirectChannelsSet = getDirectChannelsSet;

function getChannelMembersInChannels(state
/*: GlobalState*/
)
/*: RelationOneToOne<Channel, UserIDMappedObjects<ChannelMembership>>*/
{
  return state.entities.channels.membersInChannel;
}

function sortChannelsByRecencyOrAlpha(locale, lastPosts, sorting
/*: SortingType*/
, a, b) {
  if (sorting === 'recent') {
    return (0, _channel_utils.sortChannelsByRecency)(lastPosts, a, b);
  }

  return (0, _channel_utils.sortChannelsByDisplayName)(locale, a, b);
} // mapAndSortChannelIds sorts channels, primarily by:
//   For all sections except unreads:
//     a. All other unread channels
//     b. Muted channels
//   For unreads section:
//     a. Non-muted channels with mentions
//     b. Muted channels with mentions
//     c. Remaining unread channels
//   And then secondary by alphabetical ("alpha") or chronological ("recency") order


const mapAndSortChannelIds = (channels
/*: Array<Channel>*/
, currentUser
/*: UserProfile*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
, lastPosts
/*: RelationOneToOne<Channel, Post>*/
, sorting
/*: SortingType*/
, sortMentionsFirst
/*: boolean*/
= false) =>
/*: Array<string>*/
{
  const locale = currentUser.locale || _constants.General.DEFAULT_LOCALE;
  const mutedChannelIds = channels.filter(channel => (0, _channel_utils.isChannelMuted)(myMembers[channel.id])).sort(sortChannelsByRecencyOrAlpha.bind(null, locale, lastPosts, sorting)).map(channel => channel.id);
  let hasMentionedChannelIds = [];

  if (sortMentionsFirst) {
    hasMentionedChannelIds = channels.filter(channel => {
      const member = myMembers[channel.id];
      return member && member.mention_count > 0 && !(0, _channel_utils.isChannelMuted)(member);
    }).sort(sortChannelsByRecencyOrAlpha.bind(null, locale, lastPosts, sorting)).map(channel => channel.id);
  }

  const otherChannelIds = channels.filter(channel => {
    return !mutedChannelIds.includes(channel.id) && !hasMentionedChannelIds.includes(channel.id);
  }).sort(sortChannelsByRecencyOrAlpha.bind(null, locale, lastPosts, sorting)).map(channel => channel.id);
  return sortMentionsFirst ? hasMentionedChannelIds.concat(mutedChannelIds, otherChannelIds) : otherChannelIds.concat(mutedChannelIds);
};

exports.mapAndSortChannelIds = mapAndSortChannelIds;

function filterChannels(unreadIds
/*: Array<string>*/
, favoriteIds
/*: Array<string>*/
, channelIds
/*: Array<string>*/
, unreadsAtTop
/*: boolean*/
, favoritesAtTop
/*: boolean*/
)
/*: Array<string>*/
{
  let channels
  /*: Array<string>*/
  = channelIds;

  if (unreadsAtTop) {
    channels = channels.filter(id => {
      return !unreadIds.includes(id);
    });
  }

  if (favoritesAtTop) {
    channels = channels.filter(id => {
      return !favoriteIds.includes(id);
    });
  }

  return channels;
}

function makeGetChannel()
/*: (GlobalState, {id: string}) => Channel*/
{
  return (0, _reselect.createSelector)(getAllChannels, (state
  /*: GlobalState*/
  , props) => props.id, (state
  /*: GlobalState*/
  ) => state.entities.users, _preferences.getTeammateNameDisplaySetting, (allChannels, channelId, users, teammateNameDisplay) => {
    const channel = allChannels[channelId];

    if (channel) {
      return (0, _channel_utils.completeDirectChannelInfo)(users, teammateNameDisplay, channel);
    }

    return channel;
  });
}

const getChannel
/*: (GlobalState, string) => Channel*/
= (0, _reselect.createSelector)(getAllChannels, (state
/*: GlobalState*/
, id
/*: string*/
) =>
/*: string*/
id, (state
/*: GlobalState*/
) =>
/*: UsersState*/
state.entities.users, _preferences.getTeammateNameDisplaySetting, (allChannels
/*: IDMappedObjects<Channel>*/
, channelId
/*: string*/
, users
/*: UsersState*/
, teammateNameDisplay
/*: string*/
) =>
/*: Channel*/
{
  const channel = allChannels[channelId];

  if (channel) {
    return (0, _channel_utils.completeDirectChannelInfo)(users, teammateNameDisplay, channel);
  }

  return channel;
});
exports.getChannel = getChannel;
const getCurrentChannel
/*: (GlobalState) => Channel*/
= (0, _reselect.createSelector)(getAllChannels, _common.getCurrentChannelId, (state
/*: GlobalState*/
) =>
/*: UsersState*/
state.entities.users, _preferences.getTeammateNameDisplaySetting, (allChannels
/*: IDMappedObjects<Channel>*/
, currentChannelId
/*: string*/
, users
/*: UsersState*/
, teammateNameDisplay
/*: string*/
) =>
/*: Channel*/
{
  const channel = allChannels[currentChannelId];

  if (channel) {
    return (0, _channel_utils.completeDirectChannelInfo)(users, teammateNameDisplay, channel);
  }

  return channel;
});
exports.getCurrentChannel = getCurrentChannel;
const getMyChannelMember
/*: (GlobalState, string) => ?ChannelMembership*/
= (0, _reselect.createSelector)(_common.getMyChannelMemberships, (state
/*: GlobalState*/
, channelId
/*: string*/
) =>
/*: string*/
channelId, (channelMemberships
/*: RelationOneToOne<Channel, ChannelMembership>*/
, channelId
/*: string*/
) =>
/*: ?ChannelMembership*/
{
  return channelMemberships[channelId] || null;
});
exports.getMyChannelMember = getMyChannelMember;
const getCurrentChannelStats
/*: (GlobalState) => ChannelStats*/
= (0, _reselect.createSelector)(getAllChannelStats, _common.getCurrentChannelId, (allChannelStats
/*: RelationOneToOne<Channel, ChannelStats>*/
, currentChannelId
/*: string*/
) =>
/*: ChannelStats*/
{
  return allChannelStats[currentChannelId];
});
exports.getCurrentChannelStats = getCurrentChannelStats;
const isCurrentChannelFavorite
/*: (GlobalState) => boolean*/
= (0, _reselect.createSelector)(_preferences.getMyPreferences, _common.getCurrentChannelId, (preferences
/*: {[string]: PreferenceType}*/
, channelId
/*: string*/
) =>
/*: boolean*/
(0, _channel_utils.isFavoriteChannel)(preferences, channelId));
exports.isCurrentChannelFavorite = isCurrentChannelFavorite;
const isCurrentChannelMuted
/*: (GlobalState) => boolean*/
= (0, _reselect.createSelector)(_common.getMyCurrentChannelMembership, (membership
/*: ?ChannelMembership*/
) =>
/*: boolean*/
{
  if (!membership) {
    return false;
  }

  return (0, _channel_utils.isChannelMuted)(membership);
});
exports.isCurrentChannelMuted = isCurrentChannelMuted;
const isCurrentChannelArchived
/*: (GlobalState) => boolean*/
= (0, _reselect.createSelector)(getCurrentChannel, (channel
/*: Channel*/
) =>
/*: boolean*/
channel.delete_at !== 0);
exports.isCurrentChannelArchived = isCurrentChannelArchived;
const isCurrentChannelDefault
/*: (GlobalState) => boolean*/
= (0, _reselect.createSelector)(getCurrentChannel, (channel
/*: Channel*/
) =>
/*: boolean*/
(0, _channel_utils.isDefault)(channel));
exports.isCurrentChannelDefault = isCurrentChannelDefault;

function isCurrentChannelReadOnly(state
/*: GlobalState*/
)
/*: boolean*/
{
  return isChannelReadOnly(state, getCurrentChannel(state));
}

function isChannelReadOnlyById(state
/*: GlobalState*/
, channelId
/*: string*/
)
/*: boolean*/
{
  return isChannelReadOnly(state, getChannel(state, channelId));
}

function isChannelReadOnly(state
/*: GlobalState*/
, channel
/*: Channel*/
)
/*: boolean*/
{
  return channel && channel.name === _constants.General.DEFAULT_CHANNEL && !(0, _users.isCurrentUserSystemAdmin)(state) && (0, _general.getConfig)(state).ExperimentalTownSquareIsReadOnly === 'true';
}

function shouldHideDefaultChannel(state
/*: GlobalState*/
, channel
/*: Channel*/
)
/*: boolean*/
{
  return channel && channel.name === _constants.General.DEFAULT_CHANNEL && !(0, _users.isCurrentUserSystemAdmin)(state) && (0, _general.getConfig)(state).ExperimentalHideTownSquareinLHS === 'true';
}

function getChannelByName(state
/*: GlobalState*/
, channelName
/*: string*/
)
/*: ?Channel*/
{
  return (0, _channel_utils.getChannelByName)(getAllChannels(state), channelName);
}

const getChannelSetInCurrentTeam
/*: (GlobalState) => Array<string>*/
= (0, _reselect.createSelector)(_teams.getCurrentTeamId, getChannelsInTeam, (currentTeamId
/*: string*/
, channelsInTeam
/*: RelationOneToMany<Team, Channel>*/
) =>
/*: Array<string>*/
{
  return channelsInTeam && channelsInTeam[currentTeamId] || [];
});
exports.getChannelSetInCurrentTeam = getChannelSetInCurrentTeam;

function sortAndInjectChannels(channels
/*: IDMappedObjects<Channel>*/
, channelSet
/*: Array<string>*/
, locale
/*: string*/
)
/*: Array<Channel>*/
{
  const currentChannels = [];

  if (typeof channelSet === 'undefined') {
    return currentChannels;
  }

  channelSet.forEach(c => {
    currentChannels.push(channels[c]);
  });
  return currentChannels.sort(_channel_utils.sortChannelsByDisplayName.bind(null, locale));
}

const getChannelsInCurrentTeam
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(getAllChannels, getChannelSetInCurrentTeam, _common.getCurrentUser, (channels
/*: IDMappedObjects<Channel>*/
, currentTeamChannelSet
/*: Array<string>*/
, currentUser
/*: UserProfile*/
) =>
/*: Array<Channel>*/
{
  let locale = _constants.General.DEFAULT_LOCALE;

  if (currentUser && currentUser.locale) {
    locale = currentUser.locale;
  }

  return sortAndInjectChannels(channels, currentTeamChannelSet, locale);
});
exports.getChannelsInCurrentTeam = getChannelsInCurrentTeam;
const getChannelsNameMapInTeam
/*: (GlobalState, string) => NameMappedObjects<Channel>*/
= (0, _reselect.createSelector)(getAllChannels, getChannelsInTeam, (state
/*: GlobalState*/
, teamId
/*: string*/
) =>
/*: string*/
teamId, (channels
/*: IDMappedObjects<Channel>*/
, channelsInTeams
/*: RelationOneToMany<Team, Channel>*/
, teamId
/*: string*/
) =>
/*: NameMappedObjects<Channel>*/
{
  const channelsInTeam = channelsInTeams[teamId] || [];
  const channelMap = {};
  channelsInTeam.forEach(id => {
    const channel = channels[id];
    channelMap[channel.name] = channel;
  });
  return channelMap;
});
exports.getChannelsNameMapInTeam = getChannelsNameMapInTeam;
const getChannelsNameMapInCurrentTeam
/*: (GlobalState) => NameMappedObjects<Channel>*/
= (0, _reselect.createSelector)(getAllChannels, getChannelSetInCurrentTeam, (channels
/*: IDMappedObjects<Channel>*/
, currentTeamChannelSet
/*: Array<string>*/
) =>
/*: NameMappedObjects<Channel>*/
{
  const channelMap = {};
  currentTeamChannelSet.forEach(id => {
    const channel = channels[id];
    channelMap[channel.name] = channel;
  });
  return channelMap;
}); // Returns both DMs and GMs

exports.getChannelsNameMapInCurrentTeam = getChannelsNameMapInCurrentTeam;
const getAllDirectChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(getAllChannels, getDirectChannelsSet, (state
/*: GlobalState*/
) =>
/*: UsersState*/
state.entities.users, _preferences.getTeammateNameDisplaySetting, (channels
/*: IDMappedObjects<Channel>*/
, channelSet
/*: Set<string>*/
, users
/*: UsersState*/
, teammateNameDisplay
/*: string*/
) =>
/*: Array<Channel>*/
{
  const dmChannels = [];
  channelSet.forEach(c => {
    dmChannels.push((0, _channel_utils.completeDirectChannelInfo)(users, teammateNameDisplay, channels[c]));
  });
  return dmChannels;
}); // Returns only GMs

exports.getAllDirectChannels = getAllDirectChannels;
const getGroupChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(getAllChannels, getDirectChannelsSet, (state
/*: GlobalState*/
) =>
/*: UsersState*/
state.entities.users, _preferences.getTeammateNameDisplaySetting, (channels
/*: IDMappedObjects<Channel>*/
, channelSet
/*: Set<string>*/
, users
/*: UsersState*/
, teammateNameDisplay
/*: string*/
) =>
/*: Array<Channel>*/
{
  const gmChannels = [];
  channelSet.forEach(id => {
    const channel = channels[id];

    if (channel.type === _constants.General.GM_CHANNEL) {
      gmChannels.push((0, _channel_utils.completeDirectChannelInfo)(users, teammateNameDisplay, channel));
    }
  });
  return gmChannels;
});
exports.getGroupChannels = getGroupChannels;
const getMyChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(getChannelsInCurrentTeam, getAllDirectChannels, _common.getMyChannelMemberships, (channels
/*: Array<Channel>*/
, directChannels
/*: Array<Channel>*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
) =>
/*: Array<Channel>*/
{
  return [...channels, ...directChannels].filter(c => myMembers.hasOwnProperty(c.id));
});
exports.getMyChannels = getMyChannels;
const getOtherChannels
/*: (GlobalState, ?boolean) => Array<Channel>*/
= (0, _reselect.createSelector)(getChannelsInCurrentTeam, _common.getMyChannelMemberships, (state
/*: GlobalState*/
, archived
/*: ?boolean*/
= true) => archived, (channels
/*: Array<Channel>*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
, archived
/*: ?boolean*/
) =>
/*: Array<Channel>*/
{
  return channels.filter(c => !myMembers.hasOwnProperty(c.id) && c.type === _constants.General.OPEN_CHANNEL && (archived ? true : c.delete_at === 0));
});
exports.getOtherChannels = getOtherChannels;
const getArchivedChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(getChannelsInCurrentTeam, _common.getMyChannelMemberships, (channels
/*: Array<Channel>*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
) =>
/*: Array<Channel>*/
{
  return channels.filter(c => myMembers.hasOwnProperty(c.id) && c.delete_at !== 0);
});
exports.getArchivedChannels = getArchivedChannels;
const getChannelsByCategory
/*: (GlobalState) => {favoriteChannels: Array<Channel>, publicChannels: Array<Channel>, privateChannels: Array<Channel>, directAndGroupChannels: Array<Channel>}*/
= (0, _reselect.createSelector)(_common.getCurrentChannelId, getMyChannels, _common.getMyChannelMemberships, _general.getConfig, _preferences.getMyPreferences, _preferences.getTeammateNameDisplaySetting, (state
/*: GlobalState*/
) =>
/*: UsersState*/
state.entities.users, _posts.getLastPostPerChannel, (currentChannelId
/*: string*/
, channels
/*: Array<Channel>*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
, config
/*: Object*/
, myPreferences
/*: {[string]: PreferenceType}*/
, teammateNameDisplay
/*: string*/
, usersState
/*: UsersState*/
, lastPosts
/*: RelationOneToOne<Channel, Post>*/
) => {
  const allChannels = channels.map(c => {
    const channel = _objectSpread({}, c);

    channel.isCurrent = c.id === currentChannelId;
    return channel;
  });
  return (0, _channel_utils.buildDisplayableChannelList)(usersState, allChannels, myMembers, config, myPreferences, teammateNameDisplay, lastPosts);
});
exports.getChannelsByCategory = getChannelsByCategory;
const getChannelsWithUnreadSection
/*: (GlobalState) => {unreadChannels: Array<Channel>, favoriteChannels: Array<Channel>, publicChannels: Array<Channel>, privateChannels: Array<Channel>, directAndGroupChannels: Array<Channel>}*/
= (0, _reselect.createSelector)(_common.getCurrentChannelId, getMyChannels, _common.getMyChannelMemberships, _general.getConfig, _preferences.getMyPreferences, _preferences.getTeammateNameDisplaySetting, (state
/*: GlobalState*/
) =>
/*: UsersState*/
state.entities.users, _posts.getLastPostPerChannel, (currentChannelId
/*: string*/
, channels
/*: Array<Channel>*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
, config
/*: Object*/
, myPreferences
/*: {[string]: PreferenceType}*/
, teammateNameDisplay
/*: string*/
, usersState
/*: UsersState*/
, lastPosts
/*: RelationOneToOne<Channel, Post>*/
) => {
  const allChannels = channels.map(c => {
    const channel = _objectSpread({}, c);

    channel.isCurrent = c.id === currentChannelId;
    return channel;
  });
  return (0, _channel_utils.buildDisplayableChannelListWithUnreadSection)(usersState, allChannels, myMembers, config, myPreferences, teammateNameDisplay, lastPosts);
});
exports.getChannelsWithUnreadSection = getChannelsWithUnreadSection;
const getDefaultChannel
/*: (GlobalState) => ?Channel*/
= (0, _reselect.createSelector)(getAllChannels, _teams.getCurrentTeamId, (channels
/*: IDMappedObjects<Channel>*/
, teamId
/*: string*/
) =>
/*: ?Channel*/
{
  return Object.keys(channels).map(key => channels[key]).find(c => c && c.team_id === teamId && c.name === _constants.General.DEFAULT_CHANNEL);
});
exports.getDefaultChannel = getDefaultChannel;
const getMembersInCurrentChannel
/*: (GlobalState) => UserIDMappedObjects<ChannelMembership>*/
= (0, _reselect.createSelector)(_common.getCurrentChannelId, getChannelMembersInChannels, (currentChannelId
/*: string*/
, members
/*: RelationOneToOne<Channel, UserIDMappedObjects<ChannelMembership>>*/
) =>
/*: UserIDMappedObjects<ChannelMembership>*/
{
  return members[currentChannelId];
});
exports.getMembersInCurrentChannel = getMembersInCurrentChannel;
const getUnreads
/*: (GlobalState) => {messageCount: number, mentionCount: number}*/
= (0, _reselect.createSelector)(getAllChannels, _common.getMyChannelMemberships, _common.getUsers, _users.getCurrentUserId, _teams.getCurrentTeamId, _teams.getMyTeams, _teams.getTeamMemberships, (channels
/*: IDMappedObjects<Channel>*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
, users
/*: IDMappedObjects<UserProfile>*/
, currentUserId
/*: string*/
, currentTeamId
/*: string*/
, myTeams
/*: Array<Team>*/
, myTeamMemberships
/*: RelationOneToOne<Team, TeamMembership>*/
) =>
/*: {messageCount: number, mentionCount: number}*/
{
  let messageCountForCurrentTeam = 0; // Includes message count from channels of current team plus all GM'S and all DM's across teams

  let mentionCountForCurrentTeam = 0; // Includes mention count from channels of current team plus all GM'S and all DM's across teams

  Object.keys(myMembers).forEach(channelId => {
    const channel = channels[channelId];
    const m = myMembers[channelId];

    if (channel && m && (channel.team_id === currentTeamId || channel.type === _constants.General.DM_CHANNEL || channel.type === _constants.General.GM_CHANNEL)) {
      let otherUserId = '';

      if (channel.type === 'D') {
        otherUserId = (0, _channel_utils.getUserIdFromChannelName)(currentUserId, channel.name);

        if (users[otherUserId] && users[otherUserId].delete_at === 0) {
          mentionCountForCurrentTeam += channel.total_msg_count - m.msg_count;
        }
      } else if (m.mention_count > 0 && channel.delete_at === 0) {
        mentionCountForCurrentTeam += m.mention_count;
      }

      if (m.notify_props && m.notify_props.mark_unread !== 'mention' && channel.total_msg_count - m.msg_count > 0) {
        if (channel.type === 'D') {
          if (users[otherUserId] && users[otherUserId].delete_at === 0) {
            messageCountForCurrentTeam += 1;
          }
        } else if (channel.delete_at === 0) {
          messageCountForCurrentTeam += 1;
        }
      }
    }
  }); // Includes mention count and message count from teams other than the current team
  // This count does not include GM's and DM's

  const otherTeamsUnreadCountForChannels = myTeams.reduce((acc, team) => {
    if (currentTeamId !== team.id) {
      const member = myTeamMemberships[team.id];
      acc.messageCount += member.msg_count;
      acc.mentionCount += member.mention_count;
    }

    return acc;
  }, {
    messageCount: 0,
    mentionCount: 0
  });
  const totalTeamsUnreadCount = {
    messageCount: messageCountForCurrentTeam + otherTeamsUnreadCountForChannels.messageCount,
    mentionCount: mentionCountForCurrentTeam + otherTeamsUnreadCountForChannels.mentionCount
  };
  return totalTeamsUnreadCount;
});
exports.getUnreads = getUnreads;
const getUnreadsInCurrentTeam
/*: (GlobalState) => {messageCount: number, mentionCount: number}*/
= (0, _reselect.createSelector)(_common.getCurrentChannelId, getMyChannels, _common.getMyChannelMemberships, _common.getUsers, _users.getCurrentUserId, (currentChannelId
/*: string*/
, channels
/*: Array<Channel>*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
, users
/*: IDMappedObjects<UserProfile>*/
, currentUserId
/*: string*/
) =>
/*: {messageCount: number, mentionCount: number}*/
{
  let messageCount = 0;
  let mentionCount = 0;
  channels.forEach(channel => {
    const m = myMembers[channel.id];

    if (m && channel.id !== currentChannelId) {
      let otherUserId = '';

      if (channel.type === 'D') {
        otherUserId = (0, _channel_utils.getUserIdFromChannelName)(currentUserId, channel.name);

        if (users[otherUserId] && users[otherUserId].delete_at === 0) {
          mentionCount += channel.total_msg_count - m.msg_count;
        }
      } else if (m.mention_count > 0 && channel.delete_at === 0) {
        mentionCount += m.mention_count;
      }

      if (m.notify_props && m.notify_props.mark_unread !== 'mention' && channel.total_msg_count - m.msg_count > 0) {
        if (channel.type === 'D') {
          if (users[otherUserId] && users[otherUserId].delete_at === 0) {
            messageCount += 1;
          }
        } else if (channel.delete_at === 0) {
          messageCount += 1;
        }
      }
    }
  });
  return {
    messageCount,
    mentionCount
  };
});
exports.getUnreadsInCurrentTeam = getUnreadsInCurrentTeam;
const canManageChannelMembers
/*: (GlobalState) => boolean*/
= (0, _reselect.createSelector)(getCurrentChannel, _common.getCurrentUser, _teams.getCurrentTeamMembership, _common.getMyCurrentChannelMembership, _general.getConfig, _general.getLicense, _general.hasNewPermissions, (state
/*: GlobalState*/
) =>
/*: boolean*/
(0, _roles.haveICurrentChannelPermission)(state, {
  permission: _constants.Permissions.MANAGE_PRIVATE_CHANNEL_MEMBERS
}), (state
/*: GlobalState*/
) =>
/*: boolean*/
(0, _roles.haveICurrentChannelPermission)(state, {
  permission: _constants.Permissions.MANAGE_PUBLIC_CHANNEL_MEMBERS
}), (channel
/*: Channel*/
, user
/*: UserProfile*/
, teamMembership
/*: TeamMembership*/
, channelMembership
/*: ?ChannelMembership*/
, config
/*: Object*/
, license
/*: Object*/
, newPermissions
/*: boolean*/
, managePrivateMembers
/*: boolean*/
, managePublicMembers
/*: boolean*/
) =>
/*: boolean*/
{
  if (!channel) {
    return false;
  }

  if (channel.delete_at !== 0) {
    return false;
  }

  if (channel.type === _constants.General.DM_CHANNEL || channel.type === _constants.General.GM_CHANNEL || channel.name === _constants.General.DEFAULT_CHANNEL) {
    return false;
  }

  if (newPermissions) {
    if (channel.type === _constants.General.OPEN_CHANNEL) {
      return managePublicMembers;
    } else if (channel.type === _constants.General.PRIVATE_CHANNEL) {
      return managePrivateMembers;
    }

    return true;
  }

  if (!channelMembership) {
    return false;
  }

  return (0, _channel_utils.canManageMembersOldPermissions)(channel, user, teamMembership, channelMembership, config, license);
}); // Determine if the user has permissions to manage members in at least one channel of the current team

exports.canManageChannelMembers = canManageChannelMembers;
const canManageAnyChannelMembersInCurrentTeam
/*: (GlobalState) => boolean*/
= (0, _reselect.createSelector)(_common.getMyChannelMemberships, _teams.getCurrentTeamId, (state
/*: GlobalState*/
) =>
/*: GlobalState*/
state, (members
/*: RelationOneToOne<Channel, ChannelMembership>*/
, currentTeamId
/*: string*/
, state
/*: GlobalState*/
) =>
/*: boolean*/
{
  for (const channelId of Object.keys(members)) {
    const channel = getChannel(state, channelId);

    if (!channel || channel.team_id !== currentTeamId) {
      continue;
    }

    if (channel.type === _constants.General.OPEN_CHANNEL && (0, _roles.haveIChannelPermission)(state, {
      permission: _constants.Permissions.MANAGE_PUBLIC_CHANNEL_MEMBERS,
      channel: channelId,
      team: currentTeamId
    })) {
      return true;
    } else if (channel.type === _constants.General.PRIVATE_CHANNEL && (0, _roles.haveIChannelPermission)(state, {
      permission: _constants.Permissions.MANAGE_PRIVATE_CHANNEL_MEMBERS,
      channel: channelId,
      team: currentTeamId
    })) {
      return true;
    }
  }

  return false;
});
exports.canManageAnyChannelMembersInCurrentTeam = canManageAnyChannelMembersInCurrentTeam;
const getAllDirectChannelIds
/*: (GlobalState) => Array<string>*/
= (0, _helpers.createIdsSelector)(getDirectChannelsSet, (directIds
/*: Set<string>*/
) =>
/*: Array<string>*/
{
  return Array.from(directIds);
});
exports.getAllDirectChannelIds = getAllDirectChannelIds;
const getChannelIdsInCurrentTeam
/*: (GlobalState) => Array<string>*/
= (0, _helpers.createIdsSelector)(_teams.getCurrentTeamId, getChannelsInTeam, (currentTeamId
/*: string*/
, channelsInTeam
/*: RelationOneToMany<Team, Channel>*/
) =>
/*: Array<string>*/
{
  return Array.from(channelsInTeam[currentTeamId] || []);
});
exports.getChannelIdsInCurrentTeam = getChannelIdsInCurrentTeam;
const getChannelIdsForCurrentTeam
/*: (GlobalState) => Array<string>*/
= (0, _helpers.createIdsSelector)(getChannelIdsInCurrentTeam, getAllDirectChannelIds, (channels, direct) => {
  return [...channels, ...direct];
});
exports.getChannelIdsForCurrentTeam = getChannelIdsForCurrentTeam;
const getUnreadChannelIds
/*: (GlobalState, ?Channel) => Array<string>*/
= (0, _helpers.createIdsSelector)(getAllChannels, _common.getMyChannelMemberships, getChannelIdsForCurrentTeam, (state
/*: GlobalState*/
, lastUnreadChannel
/*: ?Channel*/
= null) =>
/*: ?Channel*/
lastUnreadChannel, (channels
/*: IDMappedObjects<Channel>*/
, members
/*: RelationOneToOne<Channel, ChannelMembership>*/
, teamChannelIds
/*: Array<string>*/
, lastUnreadChannel
/*: ?Channel*/
) =>
/*: Array<string>*/
{
  const unreadIds = teamChannelIds.filter(id => {
    const c = channels[id];
    const m = members[id];

    if (c && m) {
      const chHasUnread = c.total_msg_count - m.msg_count > 0;
      const chHasMention = m.mention_count > 0;

      if (m.notify_props && m.notify_props.mark_unread !== 'mention' && chHasUnread || chHasMention) {
        return true;
      }
    }

    return false;
  });

  if (lastUnreadChannel && !unreadIds.includes(lastUnreadChannel.id)) {
    unreadIds.push(lastUnreadChannel.id);
  }

  return unreadIds;
});
exports.getUnreadChannelIds = getUnreadChannelIds;
const getUnreadChannels
/*: (GlobalState, ?Channel) => Array<Channel>*/
= (0, _helpers.createIdsSelector)(_common.getCurrentUser, _common.getUsers, _users.getUserIdsInChannels, getAllChannels, getUnreadChannelIds, _preferences.getTeammateNameDisplaySetting, (currentUser, profiles, userIdsInChannels
/*: Object*/
, channels, unreadIds, settings) => {
  // If we receive an unread for a channel and then a mention the channel
  // won't be sorted correctly until we receive a message in another channel
  if (!currentUser) {
    return [];
  }

  const allUnreadChannels = unreadIds.filter(id => channels[id] && channels[id].delete_at === 0).map(id => {
    const c = channels[id];

    if (c.type === _constants.General.DM_CHANNEL || c.type === _constants.General.GM_CHANNEL) {
      return (0, _channel_utils.completeDirectChannelDisplayName)(currentUser.id, profiles, userIdsInChannels[id], settings, c);
    }

    return c;
  });
  return allUnreadChannels;
});
exports.getUnreadChannels = getUnreadChannels;
const getMapAndSortedUnreadChannelIds
/*: (GlobalState, Channel, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannels, _common.getCurrentUser, _common.getMyChannelMemberships, _posts.getLastPostPerChannel, (state, lastUnreadChannel, sorting
/*: SortingType*/
= 'alpha') => sorting, (channels, currentUser, myMembers, lastPosts, sorting
/*: SortingType*/
) => {
  return mapAndSortChannelIds(channels, currentUser, myMembers, lastPosts, sorting, true);
});
exports.getMapAndSortedUnreadChannelIds = getMapAndSortedUnreadChannelIds;
const getSortedUnreadChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => {
  return getMapAndSortedUnreadChannelIds(state, lastUnreadChannel, sorting);
}, (unreadChannelIds, mappedAndSortedUnreadChannelIds) => mappedAndSortedUnreadChannelIds); // Favorites

exports.getSortedUnreadChannelIds = getSortedUnreadChannelIds;
const getFavoriteChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _helpers.createIdsSelector)(_common.getCurrentUser, _common.getUsers, _users.getUserIdsInChannels, getAllChannels, _common.getMyChannelMemberships, _preferences.getFavoritesPreferences, getChannelIdsForCurrentTeam, _preferences.getTeammateNameDisplaySetting, _general.getConfig, _preferences.getMyPreferences, _common.getCurrentChannelId, (currentUser
/*: UserProfile*/
, profiles
/*: IDMappedObjects<UserProfile>*/
, userIdsInChannels
/*: Object*/
, channels
/*: IDMappedObjects<Channel>*/
, myMembers
/*: RelationOneToOne<Channel, ChannelMembership>*/
, favoriteIds
/*: Array<string>*/
, teamChannelIds
/*: Array<string>*/
, settings
/*: string*/
, config
/*: Object*/
, prefs
/*: {[string]: PreferenceType}*/
, currentChannelId
/*: string*/
) =>
/*: Array<Channel>*/
{
  if (!currentUser) {
    return [];
  }

  const favoriteChannel = favoriteIds.filter(id => {
    if (!myMembers[id] || !channels[id]) {
      return false;
    }

    const channel = channels[id];
    const otherUserId = (0, _channel_utils.getUserIdFromChannelName)(currentUser.id, channel.name);

    if (channel.delete_at !== 0 && channel.id !== currentChannelId) {
      return false;
    } // Deleted users from CLI will not have a profiles entry


    if (channel.type === _constants.General.DM_CHANNEL && !profiles[otherUserId]) {
      return false;
    }

    if (channel.type === _constants.General.DM_CHANNEL && !(0, _channel_utils.isDirectChannelVisible)(profiles[otherUserId] || otherUserId, config, prefs, channel, null, false, currentChannelId)) {
      return false;
    } else if (channel.type === _constants.General.GM_CHANNEL && !(0, _channel_utils.isGroupChannelVisible)(config, prefs, channel)) {
      return false;
    }

    return teamChannelIds.includes(id);
  }).map(id => {
    const c = channels[id];

    if (c.type === _constants.General.DM_CHANNEL || c.type === _constants.General.GM_CHANNEL) {
      return (0, _channel_utils.completeDirectChannelDisplayName)(currentUser.id, profiles, userIdsInChannels[id], settings, c);
    }

    return c;
  });
  return favoriteChannel;
});
exports.getFavoriteChannels = getFavoriteChannels;
const getFavoriteChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getFavoriteChannels, _common.getCurrentUser, _common.getMyChannelMemberships, _posts.getLastPostPerChannel, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => sorting, mapAndSortChannelIds);
exports.getFavoriteChannelIds = getFavoriteChannelIds;
const getSortedFavoriteChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, _preferences.getFavoritesPreferences, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
) => getFavoriteChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting), (state, lastUnreadChannel, unreadsAtTop = true) => unreadsAtTop, (unreadChannelIds, favoritePreferences, favoriteChannelIds, unreadsAtTop) => {
  return filterChannels(unreadChannelIds, favoritePreferences, favoriteChannelIds, unreadsAtTop, false);
}); // Public Channels

exports.getSortedFavoriteChannelIds = getSortedFavoriteChannelIds;
const getPublicChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(_common.getCurrentUser, getAllChannels, _common.getMyChannelMemberships, getChannelIdsForCurrentTeam, (currentUser, channels, myMembers, teamChannelIds) => {
  if (!currentUser) {
    return [];
  }

  const publicChannels = teamChannelIds.filter(id => {
    if (!myMembers[id]) {
      return false;
    }

    const channel = channels[id];
    return teamChannelIds.includes(id) && channel.type === _constants.General.OPEN_CHANNEL;
  }).map(id => channels[id]);
  return publicChannels;
});
exports.getPublicChannels = getPublicChannels;
const getPublicChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getPublicChannels, _common.getCurrentUser, _common.getMyChannelMemberships, _posts.getLastPostPerChannel, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => sorting, mapAndSortChannelIds);
exports.getPublicChannelIds = getPublicChannelIds;
const getSortedPublicChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, _preferences.getFavoritesPreferences, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => getPublicChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting), (state, lastUnreadChannel, unreadsAtTop = true) => unreadsAtTop, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop = true) => favoritesAtTop, filterChannels); // Private Channels

exports.getSortedPublicChannelIds = getSortedPublicChannelIds;
const getPrivateChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(_common.getCurrentUser, getAllChannels, _common.getMyChannelMemberships, getChannelIdsForCurrentTeam, (currentUser, channels, myMembers, teamChannelIds) => {
  if (!currentUser) {
    return [];
  }

  const privateChannels = teamChannelIds.filter(id => {
    if (!myMembers[id]) {
      return false;
    }

    const channel = channels[id];
    return teamChannelIds.includes(id) && channel.type === _constants.General.PRIVATE_CHANNEL;
  }).map(id => channels[id]);
  return privateChannels;
});
exports.getPrivateChannels = getPrivateChannels;
const getPrivateChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getPrivateChannels, _common.getCurrentUser, _common.getMyChannelMemberships, _posts.getLastPostPerChannel, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => sorting, mapAndSortChannelIds);
exports.getPrivateChannelIds = getPrivateChannelIds;
const getSortedPrivateChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, _preferences.getFavoritesPreferences, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => getPrivateChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting), (state, lastUnreadChannel, unreadsAtTop = true) => unreadsAtTop, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop = true) => favoritesAtTop, filterChannels); // Direct Messages

exports.getSortedPrivateChannelIds = getSortedPrivateChannelIds;
const getDirectChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(_common.getCurrentUser, _common.getUsers, _users.getUserIdsInChannels, getAllChannels, _preferences.getVisibleTeammate, _preferences.getVisibleGroupIds, _preferences.getTeammateNameDisplaySetting, _general.getConfig, _preferences.getMyPreferences, _posts.getLastPostPerChannel, _common.getCurrentChannelId, (currentUser
/*: UserProfile*/
, profiles
/*: IDMappedObjects<UserProfile>*/
, userIdsInChannels
/*: Object*/
, channels
/*: IDMappedObjects<Channel>*/
, teammates
/*: Array<string>*/
, groupIds
/*: Array<string>*/
, settings
/*: Object*/
, config
/*: Object*/
, preferences
/*: {[string]: PreferenceType}*/
, lastPosts
/*: RelationOneToOne<Channel, Post>*/
, currentChannelId
/*: string*/
) =>
/*: Array<Channel>*/
{
  if (!currentUser) {
    return [];
  }

  const channelValues = Object.keys(channels).map(key => channels[key]);
  const directChannelsIds = [];
  teammates.reduce((result, teammateId) => {
    const name = (0, _channel_utils.getDirectChannelName)(currentUser.id, teammateId);
    const channel = channelValues.find((c
    /*: Channel*/
    ) => c && c.name === name); //eslint-disable-line max-nested-callbacks

    if (channel) {
      const lastPost = lastPosts[channel.id];
      const otherUser = profiles[(0, _channel_utils.getUserIdFromChannelName)(currentUser.id, channel.name)];

      if (!(0, _channel_utils.isAutoClosed)(config, preferences, channel, lastPost ? lastPost.create_at : 0, otherUser ? otherUser.delete_at : 0, currentChannelId)) {
        result.push(channel.id);
      }
    }

    return result;
  }, directChannelsIds);
  const directChannels = groupIds.filter(id => {
    const channel = channels[id];

    if (channel) {
      const lastPost = lastPosts[channel.id];
      return !(0, _channel_utils.isAutoClosed)(config, preferences, channels[id], lastPost ? lastPost.create_at : 0, 0, currentChannelId);
    }

    return false;
  }).concat(directChannelsIds).map(id => {
    const channel = channels[id];
    return (0, _channel_utils.completeDirectChannelDisplayName)(currentUser.id, profiles, userIdsInChannels[id], settings, channel);
  });
  return directChannels;
}); // getDirectAndGroupChannels returns all direct and group channels, even if they have been manually
// or automatically closed.
//
// This is similar to the getDirectChannels above (which actually also returns group channels,
// but suppresses manually closed group channels but not manually closed direct channels.) This
// method does away with all the suppression, since the webapp client downstream uses this for
// the channel switcher and puts such suppressed channels in a separate category.

exports.getDirectChannels = getDirectChannels;
const getDirectAndGroupChannels
/*: (GlobalState) => Array<Channel>*/
= (0, _reselect.createSelector)(_common.getCurrentUser, _common.getUsers, _users.getUserIdsInChannels, getAllChannels, _preferences.getTeammateNameDisplaySetting, (currentUser
/*: UserProfile*/
, profiles
/*: IDMappedObjects<UserProfile>*/
, userIdsInChannels
/*: Object*/
, channels
/*: IDMappedObjects<Channel>*/
, settings) =>
/*: Array<Channel>*/
{
  if (!currentUser) {
    return [];
  }

  return Object.keys(channels).map(key => channels[key]).filter((channel
  /*: Channel*/
  ) =>
  /*: boolean*/
  Boolean(channel)).filter((channel
  /*: Channel*/
  ) =>
  /*: boolean*/
  channel.type === _constants.General.DM_CHANNEL || channel.type === _constants.General.GM_CHANNEL).map((channel
  /*: Channel*/
  ) =>
  /*: Channel*/
  (0, _channel_utils.completeDirectChannelDisplayName)(currentUser.id, profiles, userIdsInChannels[channel.id], settings, channel));
});
exports.getDirectAndGroupChannels = getDirectAndGroupChannels;
const getDirectChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getDirectChannels, _common.getCurrentUser, _common.getMyChannelMemberships, _posts.getLastPostPerChannel, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => sorting, mapAndSortChannelIds);
exports.getDirectChannelIds = getDirectChannelIds;
const getSortedDirectChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, _preferences.getFavoritesPreferences, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => getDirectChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting), (state, lastUnreadChannel, unreadsAtTop = true) => unreadsAtTop, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop = true) => favoritesAtTop, filterChannels);
exports.getSortedDirectChannelIds = getSortedDirectChannelIds;

function getGroupOrDirectChannelVisibility(state
/*: GlobalState*/
, channelId
/*: string*/
)
/*: boolean*/
{
  return (0, _channel_utils.isGroupOrDirectChannelVisible)(getChannel(state, channelId), (0, _common.getMyChannelMemberships)(state), (0, _general.getConfig)(state), (0, _preferences.getMyPreferences)(state), (0, _common.getCurrentUser)(state).id, (0, _common.getUsers)(state), (0, _posts.getLastPostPerChannel)(state));
} // Filters post IDs by the given condition.
// The condition function receives as parameters the associated channel object and the post object.


const filterPostIds = (condition
/*: (Channel, Post) => boolean*/
) => {
  if (typeof condition !== 'function') {
    throw new TypeError("".concat(condition, " is not a function"));
  }

  return ((0, _reselect.createSelector)(getAllChannels, _posts.getAllPosts, (state
  /*: GlobalState*/
  , postIds
  /*: Array<string>*/
  ) =>
  /*: Array<string>*/
  postIds, (channels
  /*: IDMappedObjects<Channel>*/
  , posts
  /*: IDMappedObjects<Post>*/
  , postIds
  /*: Array<string>*/
  ) =>
  /*: Array<string>*/
  {
    return postIds.filter(postId => {
      const post = posts[postId];
      let channel;

      if (post) {
        channel = channels[post.channel_id];
      }

      return post && channel && condition(channel, post);
    });
  })
  /*: (GlobalState, Array<string>) => Array<string>*/
  );
};

exports.filterPostIds = filterPostIds;

const getProfiles = (currentUserId
/*: string*/
, usersIdsInChannel
/*: Array<string>*/
, users
/*: IDMappedObjects<UserProfile>*/
) =>
/*: Array<UserProfile>*/
{
  const profiles = [];
  usersIdsInChannel.forEach(userId => {
    if (userId !== currentUserId) {
      profiles.push(users[userId]);
    }
  });
  return profiles;
};

const getChannelsWithUserProfiles
/*: (GlobalState) => Array<{|...Channel, profiles: Array<UserProfile>|}>*/
= (0, _reselect.createSelector)(_users.getUserIdsInChannels, _common.getUsers, getGroupChannels, _users.getCurrentUserId, (channelUserMap
/*: RelationOneToMany<Channel, UserProfile>*/
, users
/*: IDMappedObjects<UserProfile>*/
, channels
/*: Array<Channel>*/
, currentUserId
/*: string*/
) => {
  return channels.map((channel
  /*: Channel*/
  ) =>
  /*: {|...Channel, profiles: Array<UserProfile>|}*/
  {
    const profiles = getProfiles(currentUserId, channelUserMap[channel.id] || [], users);
    return _objectSpread({}, channel, {
      profiles
    });
  });
});
exports.getChannelsWithUserProfiles = getChannelsWithUserProfiles;
const getAllActiveChannels = (0, _reselect.createSelector)(getPublicChannels, getPrivateChannels, getDirectChannels, (publicChannels, privateChannels, directChannels) => {
  const allChannels = [...publicChannels, ...privateChannels, ...directChannels];
  return allChannels;
});
const getAllChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getAllActiveChannels, _common.getCurrentUser, _common.getMyChannelMemberships, _posts.getLastPostPerChannel, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => sorting, mapAndSortChannelIds);
exports.getAllChannelIds = getAllChannelIds;
const getAllSortedChannelIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, _preferences.getFavoritesPreferences, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting
/*: SortingType*/
= 'alpha') => getAllChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting), (state, lastUnreadChannel, unreadsAtTop = true) => unreadsAtTop, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop = true) => favoritesAtTop, filterChannels);
exports.getAllSortedChannelIds = getAllSortedChannelIds;
let lastChannels;

const hasChannelsChanged = channels => {
  if (!lastChannels || lastChannels.length !== channels.length) {
    return true;
  }

  for (let i = 0; i < channels.length; i++) {
    if (channels[i].type !== lastChannels[i].type || channels[i].items !== lastChannels[i].items) {
      return true;
    }
  }

  return false;
};

const getOrderedChannelIds = (state
/*: GlobalState*/
, lastUnreadChannel
/*: Channel*/
, grouping
/*: 'by_type' | 'none'*/
, sorting
/*: SortingType*/
, unreadsAtTop
/*: boolean*/
, favoritesAtTop
/*: boolean*/
) => {
  const channels = [];

  if (grouping === 'by_type') {
    channels.push({
      type: 'public',
      name: 'PUBLIC CHANNELS',
      items: getSortedPublicChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting)
    });
    channels.push({
      type: 'private',
      name: 'PRIVATE CHANNELS',
      items: getSortedPrivateChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting)
    });
    channels.push({
      type: 'direct',
      name: 'DIRECT MESSAGES',
      items: getSortedDirectChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting)
    });
  } else {
    // Combine all channel types
    let type = 'alpha';
    let name = 'CHANNELS';

    if (sorting === 'recent') {
      type = 'recent';
      name = 'RECENT ACTIVITY';
    }

    channels.push({
      type,
      name,
      items: getAllSortedChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting)
    });
  }

  if (favoritesAtTop) {
    channels.unshift({
      type: 'favorite',
      name: 'FAVORITE CHANNELS',
      items: getSortedFavoriteChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting)
    });
  }

  if (unreadsAtTop) {
    channels.unshift({
      type: 'unreads',
      name: 'UNREADS',
      items: getSortedUnreadChannelIds(state, lastUnreadChannel, unreadsAtTop, favoritesAtTop, sorting)
    });
  }

  if (hasChannelsChanged(channels)) {
    lastChannels = channels;
  }

  return lastChannels;
}; // Added for backwards compatibility
// Can be removed once webapp includes new sidebar preferences


exports.getOrderedChannelIds = getOrderedChannelIds;
const getSortedPublicChannelWithUnreadsIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, _preferences.getFavoritesPreferences, getPublicChannelIds, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop = true) => favoritesAtTop, (unreadChannelIds, favoritePreferences, publicChannelIds, favoritesAtTop) => {
  return filterChannels(unreadChannelIds, favoritePreferences, publicChannelIds, false, favoritesAtTop);
});
exports.getSortedPublicChannelWithUnreadsIds = getSortedPublicChannelWithUnreadsIds;
const getSortedPrivateChannelWithUnreadsIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, _preferences.getFavoritesPreferences, getPrivateChannelIds, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop = true) => favoritesAtTop, (unreadChannelIds, favoritePreferences, privateChannelId, favoritesAtTop) => {
  return filterChannels(unreadChannelIds, favoritePreferences, privateChannelId, false, favoritesAtTop);
});
exports.getSortedPrivateChannelWithUnreadsIds = getSortedPrivateChannelWithUnreadsIds;
const getSortedFavoriteChannelWithUnreadsIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, getFavoriteChannelIds, (unreadChannelIds, favoriteChannelIds) => favoriteChannelIds);
exports.getSortedFavoriteChannelWithUnreadsIds = getSortedFavoriteChannelWithUnreadsIds;
const getSortedDirectChannelWithUnreadsIds
/*: (GlobalState, Channel, boolean, boolean, SortingType) => Array<string>*/
= (0, _helpers.createIdsSelector)(getUnreadChannelIds, _preferences.getFavoritesPreferences, getDirectChannelIds, (state, lastUnreadChannel, unreadsAtTop, favoritesAtTop = true) => favoritesAtTop, (unreadChannelIds, favoritePreferences, directChannelIds, favoritesAtTop) => {
  return filterChannels(unreadChannelIds, favoritePreferences, directChannelIds, false, favoritesAtTop);
});
exports.getSortedDirectChannelWithUnreadsIds = getSortedDirectChannelWithUnreadsIds;
const getDefaultChannelForTeams
/*: (GlobalState) => RelationOneToOne<Team, Channel>*/
= (0, _reselect.createSelector)(getAllChannels, (channels
/*: IDMappedObjects<Channel>*/
) =>
/*: RelationOneToOne<Team, Channel>*/
{
  const result = {};

  for (const channel of Object.keys(channels).map(key => channels[key])) {
    if (channel && channel.name === _constants.General.DEFAULT_CHANNEL) {
      result[channel.team_id] = channel;
    }
  }

  return result;
});
exports.getDefaultChannelForTeams = getDefaultChannelForTeams;
const getMyFirstChannelForTeams
/*: (GlobalState) => RelationOneToOne<Team, Channel>*/
= (0, _reselect.createSelector)(getAllChannels, _common.getMyChannelMemberships, _teams.getMyTeams, _common.getCurrentUser, (allChannels
/*: IDMappedObjects<Channel>*/
, myChannelMemberships
/*: RelationOneToOne<Channel, ChannelMembership>*/
, myTeams
/*: Array<Team>*/
, currentUser
/*: UserProfile*/
) =>
/*: RelationOneToOne<Team, Channel>*/
{
  const locale = currentUser.locale || _constants.General.DEFAULT_LOCALE;
  const result = {};

  for (const team of myTeams) {
    // Get a sorted array of all channels in the team that the current user is a member of
    // $FlowFixMe
    const teamChannels = Object.values(allChannels).filter((channel
    /*: Channel*/
    ) => channel && channel.team_id === team.id && Boolean(myChannelMemberships[channel.id])).sort(_channel_utils.sortChannelsByDisplayName.bind(null, locale));

    if (teamChannels.length === 0) {
      continue;
    }

    result[team.id] = teamChannels[0];
  }

  return result;
});
exports.getMyFirstChannelForTeams = getMyFirstChannelForTeams;

const getRedirectChannelNameForTeam = (state
/*: GlobalState*/
, teamId
/*: string*/
) =>
/*: string*/
{
  const defaultChannelForTeam = getDefaultChannelForTeams(state)[teamId];
  const myFirstChannelForTeam = getMyFirstChannelForTeams(state)[teamId];
  const canIJoinPublicChannelsInTeam = !(0, _general.hasNewPermissions)(state) || (0, _roles.haveITeamPermission)(state, {
    team: teamId,
    permission: _constants.Permissions.JOIN_PUBLIC_CHANNELS
  });
  const myChannelMemberships = (0, _common.getMyChannelMemberships)(state);
  const iAmMemberOfTheTeamDefaultChannel = Boolean(defaultChannelForTeam && myChannelMemberships[defaultChannelForTeam.id]);

  if (iAmMemberOfTheTeamDefaultChannel || canIJoinPublicChannelsInTeam) {
    return _constants.General.DEFAULT_CHANNEL;
  }

  return myFirstChannelForTeam && myFirstChannelForTeam.name || _constants.General.DEFAULT_CHANNEL;
};

exports.getRedirectChannelNameForTeam = getRedirectChannelNameForTeam;