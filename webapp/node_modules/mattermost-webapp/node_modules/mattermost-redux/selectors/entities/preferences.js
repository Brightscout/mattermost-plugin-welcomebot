"use strict";

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMyPreferences = getMyPreferences;
exports.get = get;
exports.getBool = getBool;
exports.getInt = getInt;
exports.makeGetCategory = makeGetCategory;
exports.getDirectShowPreferences = getDirectShowPreferences;
exports.getGroupShowPreferences = getGroupShowPreferences;
exports.getFavoritesPreferences = getFavoritesPreferences;
exports.makeGetStyleFromTheme = makeGetStyleFromTheme;
exports.getSidebarPreferences = exports.getTheme = exports.getTeammateNameDisplaySetting = exports.getVisibleGroupIds = exports.getVisibleTeammate = void 0;

var _reselect = require("reselect");

var _constants = require("../../constants");

var _general = require("./general");

var _teams = require("./teams");

var _helpers = require("../../utils/helpers");

var _preference_utils = require("../../utils/preference_utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getMyPreferences(state) {
  return state.entities.preferences.myPreferences;
}

function get(state, category, name, defaultValue = '') {
  const key = (0, _preference_utils.getPreferenceKey)(category, name);
  const prefs = getMyPreferences(state);

  if (!(key in prefs)) {
    return defaultValue;
  }

  return prefs[key].value;
}

function getBool(state, category, name, defaultValue = false) {
  const value = get(state, category, name, String(defaultValue));
  return value !== 'false';
}

function getInt(state, category, name, defaultValue = 0) {
  const value = get(state, category, name, defaultValue);
  return parseInt(value, 10);
}

function makeGetCategory() {
  return (0, _reselect.createSelector)(getMyPreferences, (state, category) => category, (preferences, category) => {
    const prefix = category + '--';
    const prefsInCategory = [];

    for (const key in preferences) {
      if (key.startsWith(prefix)) {
        prefsInCategory.push(preferences[key]);
      }
    }

    return prefsInCategory;
  });
}

const getDirectShowCategory = makeGetCategory();

function getDirectShowPreferences(state) {
  return getDirectShowCategory(state, _constants.Preferences.CATEGORY_DIRECT_CHANNEL_SHOW);
}

const getGroupShowCategory = makeGetCategory();

function getGroupShowPreferences(state) {
  return getGroupShowCategory(state, _constants.Preferences.CATEGORY_GROUP_CHANNEL_SHOW);
}

const getFavoritesCategory = makeGetCategory();

function getFavoritesPreferences(state) {
  const favorites = getFavoritesCategory(state, _constants.Preferences.CATEGORY_FAVORITE_CHANNEL);
  return favorites.filter(f => f.value === 'true').map(f => f.name);
}

const getVisibleTeammate = (0, _reselect.createSelector)(getDirectShowPreferences, direct => {
  return direct.filter(dm => dm.value === 'true' && dm.name).map(dm => dm.name);
});
exports.getVisibleTeammate = getVisibleTeammate;
const getVisibleGroupIds = (0, _reselect.createSelector)(getGroupShowPreferences, groups => {
  return groups.filter(dm => dm.value === 'true' && dm.name).map(dm => dm.name);
});
exports.getVisibleGroupIds = getVisibleGroupIds;
const getTeammateNameDisplaySetting = (0, _reselect.createSelector)(_general.getConfig, getMyPreferences, (config, preferences) => {
  const key = (0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_DISPLAY_SETTINGS, _constants.Preferences.NAME_NAME_FORMAT);

  if (preferences[key]) {
    return preferences[key].value;
  } else if (config.TeammateNameDisplay) {
    return config.TeammateNameDisplay;
  }

  return _constants.General.TEAMMATE_NAME_DISPLAY.SHOW_USERNAME;
});
exports.getTeammateNameDisplaySetting = getTeammateNameDisplaySetting;
const getThemePreference = (0, _reselect.createSelector)(getMyPreferences, _teams.getCurrentTeamId, (myPreferences, currentTeamId) => {
  // Prefer the user's current team-specific theme over the user's current global theme
  let themePreference;

  if (currentTeamId) {
    themePreference = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_THEME, currentTeamId)];
  }

  if (!themePreference) {
    themePreference = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_THEME, '')];
  }

  return themePreference;
});
const getDefaultTheme = (0, _reselect.createSelector)(_general.getConfig, config => {
  if (config.DefaultTheme) {
    const theme = _constants.Preferences.THEMES[config.DefaultTheme];

    if (theme) {
      return theme;
    }
  } // If no config.DefaultTheme or value doesn't refer to a valid theme name...


  return _constants.Preferences.THEMES.default;
});
const getTheme = (0, _helpers.createShallowSelector)(getThemePreference, getDefaultTheme, (themePreference, defaultTheme) => {
  let theme;

  if (themePreference) {
    theme = themePreference.value;
  } else {
    theme = defaultTheme;
  }

  if (typeof theme === 'string') {
    // A custom theme will be a JSON-serialized object stored in a preference
    theme = JSON.parse(theme);
  } // At this point, the theme should be a plain object
  // If this is a system theme, find it in case the user's theme is missing any fields


  if (theme.type && theme.type !== 'custom') {
    const match = Object.values(_constants.Preferences.THEMES).find(v => v.type === theme.type);

    if (match) {
      if (!match.mentionBg) {
        match.mentionBg = match.mentionBj;
      }

      return match;
    }
  }

  for (const key of Object.keys(defaultTheme)) {
    if (theme[key]) {
      // Fix a case where upper case theme colours are rendered as black
      theme[key] = theme[key].toLowerCase();
    }
  } // Backwards compatability with old name


  if (!theme.mentionBg) {
    theme.mentionBg = theme.mentionBj;
  }

  return Object.assign({}, defaultTheme, theme);
});
exports.getTheme = getTheme;

function makeGetStyleFromTheme() {
  return (0, _reselect.createSelector)(getTheme, (state, getStyleFromTheme) => getStyleFromTheme, (theme, getStyleFromTheme) => {
    return getStyleFromTheme(theme);
  });
}

const defaultSidebarPrefs = {
  grouping: 'by_type',
  unreads_at_top: 'true',
  favorite_at_top: 'true',
  sorting: 'alpha'
};
const getSidebarPreferences = (0, _reselect.createSelector)(state => {
  const config = (0, _general.getConfig)(state);
  return config.ExperimentalGroupUnreadChannels !== _constants.General.DISABLED && getBool(state, _constants.Preferences.CATEGORY_SIDEBAR_SETTINGS, 'show_unread_section', config.ExperimentalGroupUnreadChannels === _constants.General.DEFAULT_ON);
}, state => {
  return get(state, _constants.Preferences.CATEGORY_SIDEBAR_SETTINGS, '', null);
}, (showUnreadSection, sidebarPreference) => {
  let sidebarPrefs = JSON.parse(sidebarPreference);

  if (sidebarPrefs === null) {
    // Support unread settings for old implementation
    sidebarPrefs = _objectSpread({}, defaultSidebarPrefs, {
      unreads_at_top: showUnreadSection ? 'true' : 'false'
    });
  }

  return sidebarPrefs;
});
exports.getSidebarPreferences = getSidebarPreferences;