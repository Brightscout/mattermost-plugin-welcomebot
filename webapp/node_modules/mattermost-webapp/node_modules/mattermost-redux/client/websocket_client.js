"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/es.string.split");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
const MAX_WEBSOCKET_FAILS = 7;
const MIN_WEBSOCKET_RETRY_TIME = 3000; // 3 sec

const MAX_WEBSOCKET_RETRY_TIME = 300000; // 5 mins

let Socket;

class WebSocketClient {
  constructor() {
    this.conn = null;
    this.connectionUrl = null;
    this.token = null;
    this.sequence = 1;
    this.connectFailCount = 0;
    this.eventCallback = null;
    this.firstConnectCallback = null;
    this.reconnectCallback = null;
    this.errorCallback = null;
    this.closeCallback = null;
    this.connectingCallback = null;
    this.stop = false;
    this.platform = '';
  }

  initialize(token, opts) {
    const defaults = {
      forceConnection: true,
      connectionUrl: this.connectionUrl,
      webSocketConnector: WebSocket
    };

    const _Object$assign = Object.assign({}, defaults, opts),
          {
      connectionUrl,
      forceConnection,
      webSocketConnector,
      platform
    } = _Object$assign,
          additionalOptions = _objectWithoutProperties(_Object$assign, ["connectionUrl", "forceConnection", "webSocketConnector", "platform"]);

    if (platform) {
      this.platform = platform;
    }

    if (forceConnection) {
      this.stop = false;
    }

    return new Promise((resolve, reject) => {
      if (this.conn) {
        resolve();
        return;
      }

      if (connectionUrl == null) {
        console.log('websocket must have connection url'); //eslint-disable-line no-console

        reject(new Error('websocket must have connection url'));
        return;
      }

      if (this.connectFailCount === 0) {
        console.log('websocket connecting to ' + connectionUrl); //eslint-disable-line no-console
      }

      Socket = webSocketConnector;

      if (this.connectingCallback) {
        this.connectingCallback();
      }

      const regex = /^(?:https?|wss?):(?:\/\/)?[^/]*/;
      const captured = regex.exec(connectionUrl);
      let origin;

      if (captured) {
        origin = captured[0];

        if (platform === 'android') {
          // this is done cause for android having the port 80 or 443 will fail the connection
          // the websocket will append them
          const split = origin.split(':');
          const port = split[2];

          if (port === '80' || port === '443') {
            origin = "".concat(split[0], ":").concat(split[1]);
          }
        }
      } else {
        // If we're unable to set the origin header, the websocket won't connect, but the URL is likely malformed anyway
        const errorMessage = 'websocket failed to parse origin from ' + connectionUrl;
        console.warn(errorMessage); // eslint-disable-line no-console

        reject(new Error(errorMessage));
        return;
      }

      this.conn = new Socket(connectionUrl, [], _objectSpread({
        headers: {
          origin
        }
      }, additionalOptions || {}));
      this.connectionUrl = connectionUrl;
      this.token = token;

      this.conn.onopen = () => {
        if (token) {
          // we check for the platform as a workaround until we fix on the server that further authentications
          // are ignored
          this.sendMessage('authentication_challenge', {
            token
          });
        }

        if (this.connectFailCount > 0) {
          console.log('websocket re-established connection'); //eslint-disable-line no-console

          if (this.reconnectCallback) {
            this.reconnectCallback();
          }
        } else if (this.firstConnectCallback) {
          this.firstConnectCallback();
        }

        this.connectFailCount = 0;
        resolve();
      };

      this.conn.onclose = () => {
        this.conn = null;
        this.sequence = 1;

        if (this.connectFailCount === 0) {
          console.log('websocket closed'); //eslint-disable-line no-console
        }

        this.connectFailCount++;

        if (this.closeCallback) {
          this.closeCallback(this.connectFailCount);
        }

        let retryTime = MIN_WEBSOCKET_RETRY_TIME; // If we've failed a bunch of connections then start backing off

        if (this.connectFailCount > MAX_WEBSOCKET_FAILS) {
          retryTime = MIN_WEBSOCKET_RETRY_TIME * this.connectFailCount;

          if (retryTime > MAX_WEBSOCKET_RETRY_TIME) {
            retryTime = MAX_WEBSOCKET_RETRY_TIME;
          }
        }

        if (this.connectionTimeout) {
          clearTimeout(this.connectionTimeout);
        }

        this.connectionTimeout = setTimeout(() => {
          if (this.stop) {
            clearTimeout(this.connectionTimeout);
            return;
          }

          this.initialize(token, opts);
        }, retryTime);
      };

      this.conn.onerror = evt => {
        if (this.connectFailCount <= 1) {
          console.log('websocket error'); //eslint-disable-line no-console

          console.log(evt); //eslint-disable-line no-console
        }

        if (this.errorCallback) {
          this.errorCallback(evt);
        }
      };

      this.conn.onmessage = evt => {
        const msg = JSON.parse(evt.data);

        if (msg.seq_reply) {
          if (msg.error) {
            console.warn(msg); //eslint-disable-line no-console
          }
        } else if (this.eventCallback) {
          this.eventCallback(msg);
        }
      };
    });
  }

  setConnectingCallback(callback) {
    this.connectingCallback = callback;
  }

  setEventCallback(callback) {
    this.eventCallback = callback;
  }

  setFirstConnectCallback(callback) {
    this.firstConnectCallback = callback;
  }

  setReconnectCallback(callback) {
    this.reconnectCallback = callback;
  }

  setErrorCallback(callback) {
    this.errorCallback = callback;
  }

  setCloseCallback(callback) {
    this.closeCallback = callback;
  }

  close(stop = false) {
    this.stop = stop;
    this.connectFailCount = 0;
    this.sequence = 1;

    if (this.conn && this.conn.readyState === Socket.OPEN) {
      this.conn.onclose = () => {}; //eslint-disable-line no-empty-function


      this.conn.close();
      this.conn = null;
      console.log('websocket closed'); //eslint-disable-line no-console
    }
  }

  sendMessage(action, data) {
    const msg = {
      action,
      seq: this.sequence++,
      data
    };

    if (this.conn && this.conn.readyState === Socket.OPEN) {
      this.conn.send(JSON.stringify(msg));
    } else if (!this.conn || this.conn.readyState === Socket.CLOSED) {
      this.conn = null;
      this.initialize(this.token, {
        platform: this.platform
      });
    }
  }

  userTyping(channelId, parentId) {
    this.sendMessage('user_typing', {
      channel_id: channelId,
      parent_id: parentId
    });
  }

  getStatuses() {
    this.sendMessage('get_statuses', null);
  }

  getStatusesByIds(userIds) {
    this.sendMessage('get_statuses_by_ids', {
      user_ids: userIds
    });
  }

}

var _default = new WebSocketClient();

exports.default = _default;