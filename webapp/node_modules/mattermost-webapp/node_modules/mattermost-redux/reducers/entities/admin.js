"use strict";

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.string.includes");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertAnalyticsRowsToStats = convertAnalyticsRowsToStats;
exports.default = void 0;

var _redux = require("redux");

var _action_types = require("../../action_types");

var _constants = require("../../constants");

var _plugins = _interopRequireDefault(require("../../constants/plugins"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function logs(state = [], action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_LOGS:
      {
        return action.data;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return [];

    default:
      return state;
  }
}

function audits(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_AUDITS:
      {
        const nextState = _objectSpread({}, state);

        for (const audit of action.data) {
          nextState[audit.id] = audit;
        }

        return nextState;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function config(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_CONFIG:
      {
        return action.data;
      }

    case _action_types.AdminTypes.ENABLED_PLUGIN:
      {
        const nextPluginSettings = _objectSpread({}, state.PluginSettings);

        const nextPluginStates = _objectSpread({}, nextPluginSettings.PluginStates);

        nextPluginStates[action.data] = {
          Enable: true
        };
        nextPluginSettings.PluginStates = nextPluginStates;
        return _objectSpread({}, state, {
          PluginSettings: nextPluginSettings
        });
      }

    case _action_types.AdminTypes.DISABLED_PLUGIN:
      {
        const nextPluginSettings = _objectSpread({}, state.PluginSettings);

        const nextPluginStates = _objectSpread({}, nextPluginSettings.PluginStates);

        nextPluginStates[action.data] = {
          Enable: false
        };
        nextPluginSettings.PluginStates = nextPluginStates;
        return _objectSpread({}, state, {
          PluginSettings: nextPluginSettings
        });
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function environmentConfig(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_ENVIRONMENT_CONFIG:
      {
        return action.data;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function complianceReports(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_COMPLIANCE_REPORT:
      {
        const nextState = _objectSpread({}, state);

        nextState[action.data.id] = action.data;
        return nextState;
      }

    case _action_types.AdminTypes.RECEIVED_COMPLIANCE_REPORTS:
      {
        const nextState = _objectSpread({}, state);

        for (const report of action.data) {
          nextState[report.id] = report;
        }

        return nextState;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function clusterInfo(state = [], action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_CLUSTER_STATUS:
      {
        return action.data;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return [];

    default:
      return state;
  }
}

function samlCertStatus(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_SAML_CERT_STATUS:
      {
        return action.data;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function convertAnalyticsRowsToStats(data, name) {
  const stats = {};
  const clonedData = [...data];

  if (name === 'post_counts_day') {
    clonedData.reverse();
    stats[_constants.Stats.POST_PER_DAY] = clonedData;
    return stats;
  }

  if (name === 'bot_post_counts_day') {
    clonedData.reverse();
    stats[_constants.Stats.BOT_POST_PER_DAY] = clonedData;
    return stats;
  }

  if (name === 'user_counts_with_posts_day') {
    clonedData.reverse();
    stats[_constants.Stats.USERS_WITH_POSTS_PER_DAY] = clonedData;
    return stats;
  }

  clonedData.forEach(row => {
    let key;

    switch (row.name) {
      case 'channel_open_count':
        key = _constants.Stats.TOTAL_PUBLIC_CHANNELS;
        break;

      case 'channel_private_count':
        key = _constants.Stats.TOTAL_PRIVATE_GROUPS;
        break;

      case 'post_count':
        key = _constants.Stats.TOTAL_POSTS;
        break;

      case 'unique_user_count':
        key = _constants.Stats.TOTAL_USERS;
        break;

      case 'inactive_user_count':
        key = _constants.Stats.TOTAL_INACTIVE_USERS;
        break;

      case 'team_count':
        key = _constants.Stats.TOTAL_TEAMS;
        break;

      case 'total_websocket_connections':
        key = _constants.Stats.TOTAL_WEBSOCKET_CONNECTIONS;
        break;

      case 'total_master_db_connections':
        key = _constants.Stats.TOTAL_MASTER_DB_CONNECTIONS;
        break;

      case 'total_read_db_connections':
        key = _constants.Stats.TOTAL_READ_DB_CONNECTIONS;
        break;

      case 'daily_active_users':
        key = _constants.Stats.DAILY_ACTIVE_USERS;
        break;

      case 'monthly_active_users':
        key = _constants.Stats.MONTHLY_ACTIVE_USERS;
        break;

      case 'file_post_count':
        key = _constants.Stats.TOTAL_FILE_POSTS;
        break;

      case 'hashtag_post_count':
        key = _constants.Stats.TOTAL_HASHTAG_POSTS;
        break;

      case 'incoming_webhook_count':
        key = _constants.Stats.TOTAL_IHOOKS;
        break;

      case 'outgoing_webhook_count':
        key = _constants.Stats.TOTAL_OHOOKS;
        break;

      case 'command_count':
        key = _constants.Stats.TOTAL_COMMANDS;
        break;

      case 'session_count':
        key = _constants.Stats.TOTAL_SESSIONS;
        break;
    }

    if (key) {
      stats[key] = row.value;
    }
  });
  return stats;
}

function analytics(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_SYSTEM_ANALYTICS:
      {
        const stats = convertAnalyticsRowsToStats(action.data, action.name);
        return _objectSpread({}, state, {}, stats);
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function teamAnalytics(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_TEAM_ANALYTICS:
      {
        const nextState = _objectSpread({}, state);

        const stats = convertAnalyticsRowsToStats(action.data, action.name);

        const analyticsForTeam = _objectSpread({}, nextState[action.teamId] || {}, {}, stats);

        nextState[action.teamId] = analyticsForTeam;
        return nextState;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function userAccessTokens(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKEN:
      {
        return _objectSpread({}, state, {
          [action.data.id]: action.data
        });
      }

    case _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKENS_FOR_USER:
      {
        const nextState = {};

        for (const uat of action.data) {
          nextState[uat.id] = uat;
        }

        return _objectSpread({}, state, {}, nextState);
      }

    case _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKENS:
      {
        const nextState = {};

        for (const uat of action.data) {
          nextState[uat.id] = uat;
        }

        return _objectSpread({}, state, {}, nextState);
      }

    case _action_types.UserTypes.REVOKED_USER_ACCESS_TOKEN:
      {
        const nextState = _objectSpread({}, state);

        Reflect.deleteProperty(nextState, action.data);
        return _objectSpread({}, nextState);
      }

    case _action_types.UserTypes.ENABLED_USER_ACCESS_TOKEN:
      {
        const token = _objectSpread({}, state[action.data], {
          is_active: true
        });

        return _objectSpread({}, state, {
          [action.data]: token
        });
      }

    case _action_types.UserTypes.DISABLED_USER_ACCESS_TOKEN:
      {
        const token = _objectSpread({}, state[action.data], {
          is_active: false
        });

        return _objectSpread({}, state, {
          [action.data]: token
        });
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function userAccessTokensForUser(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKEN:
      {
        const nextUserState = _objectSpread({}, state[action.data.user_id] || {});

        nextUserState[action.data.id] = action.data;
        return _objectSpread({}, state, {
          [action.data.user_id]: nextUserState
        });
      }

    case _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKENS_FOR_USER:
      {
        const nextUserState = _objectSpread({}, state[action.userId] || {});

        for (const uat of action.data) {
          nextUserState[uat.id] = uat;
        }

        return _objectSpread({}, state, {
          [action.userId]: nextUserState
        });
      }

    case _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKENS:
      {
        const nextUserState = {};

        for (const uat of action.data) {
          nextUserState[uat.user_id] = nextUserState[uat.user_id] || {};
          nextUserState[uat.user_id][uat.id] = uat;
        }

        return _objectSpread({}, state, {}, nextUserState);
      }

    case _action_types.UserTypes.REVOKED_USER_ACCESS_TOKEN:
      {
        const userIds = Object.keys(state);

        for (let i = 0; i < userIds.length; i++) {
          const userId = userIds[i];

          if (state[userId] && state[userId][action.data]) {
            const nextUserState = _objectSpread({}, state[userId]);

            Reflect.deleteProperty(nextUserState, action.data);
            return _objectSpread({}, state, {
              [userId]: nextUserState
            });
          }
        }

        return state;
      }

    case _action_types.UserTypes.ENABLED_USER_ACCESS_TOKEN:
      {
        const userIds = Object.keys(state);

        for (let i = 0; i < userIds.length; i++) {
          const userId = userIds[i];

          if (state[userId] && state[userId][action.data]) {
            const nextUserState = _objectSpread({}, state[userId]);

            const token = _objectSpread({}, nextUserState[action.data], {
              is_active: true
            });

            nextUserState[token.id] = token;
            return _objectSpread({}, state, {
              [userId]: nextUserState
            });
          }
        }

        return state;
      }

    case _action_types.UserTypes.DISABLED_USER_ACCESS_TOKEN:
      {
        const userIds = Object.keys(state);

        for (let i = 0; i < userIds.length; i++) {
          const userId = userIds[i];

          if (state[userId] && state[userId][action.data]) {
            const nextUserState = _objectSpread({}, state[userId]);

            const token = _objectSpread({}, nextUserState[action.data], {
              is_active: false
            });

            nextUserState[token.id] = token;
            return _objectSpread({}, state, {
              [userId]: nextUserState
            });
          }
        }

        return state;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function plugins(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_PLUGINS:
      {
        const nextState = _objectSpread({}, state);

        const activePlugins = action.data.active;

        for (const plugin of activePlugins) {
          nextState[plugin.id] = _objectSpread({}, plugin, {
            active: true
          });
        }

        const inactivePlugins = action.data.inactive;

        for (const plugin of inactivePlugins) {
          nextState[plugin.id] = _objectSpread({}, plugin, {
            active: false
          });
        }

        return nextState;
      }

    case _action_types.AdminTypes.REMOVED_PLUGIN:
      {
        const nextState = _objectSpread({}, state);

        Reflect.deleteProperty(nextState, action.data);
        return nextState;
      }

    case _action_types.AdminTypes.ENABLED_PLUGIN:
      {
        const nextState = _objectSpread({}, state);

        const plugin = nextState[action.data];

        if (plugin && !plugin.active) {
          nextState[action.data] = _objectSpread({}, plugin, {
            active: true
          });
          return nextState;
        }

        return state;
      }

    case _action_types.AdminTypes.DISABLED_PLUGIN:
      {
        const nextState = _objectSpread({}, state);

        const plugin = nextState[action.data];

        if (plugin && plugin.active) {
          nextState[action.data] = _objectSpread({}, plugin, {
            active: false
          });
          return nextState;
        }

        return state;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function pluginStatuses(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_PLUGIN_STATUSES:
      {
        const nextState = {};

        for (const plugin of action.data || []) {
          const id = plugin.plugin_id; // The plugin may be in different states across the cluster. Pick the highest one to
          // surface an error.

          const pluginState = Math.max(nextState[id] && nextState[id].state || 0, plugin.state);
          const instances = [...(nextState[id] && nextState[id].instances || []), {
            cluster_id: plugin.cluster_id,
            version: plugin.version,
            state: plugin.state
          }];
          nextState[id] = {
            id,
            name: nextState[id] && nextState[id].name || plugin.name,
            description: nextState[id] && nextState[id].description || plugin.description,
            version: nextState[id] && nextState[id].version || plugin.version,
            is_prepackaged: nextState[id] && nextState[id].is_prepackaged || _constants.Plugins.PREPACKAGED_PLUGINS.includes(id),
            active: pluginState > 0,
            state: pluginState,
            instances
          };
        }

        return nextState;
      }

    case _action_types.AdminTypes.ENABLE_PLUGIN_REQUEST:
      {
        const pluginId = action.data;

        if (!state[pluginId]) {
          return state;
        }

        return _objectSpread({}, state, {
          [pluginId]: _objectSpread({}, state[pluginId], {
            state: _plugins.default.PLUGIN_STATE_STARTING
          })
        });
      }

    case _action_types.AdminTypes.DISABLE_PLUGIN_REQUEST:
      {
        const pluginId = action.data;

        if (!state[pluginId]) {
          return state;
        }

        return _objectSpread({}, state, {
          [pluginId]: _objectSpread({}, state[pluginId], {
            state: _plugins.default.PLUGIN_STATE_STOPPING
          })
        });
      }

    case _action_types.AdminTypes.REMOVED_PLUGIN:
      {
        const pluginId = action.data;

        if (!state[pluginId]) {
          return state;
        }

        const nextState = _objectSpread({}, state);

        Reflect.deleteProperty(nextState, pluginId);
        return nextState;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function ldapGroupsCount(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_LDAP_GROUPS:
      return action.data.count;

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return 0;

    default:
      return state;
  }
}

function ldapGroups(state = {}, action) {
  switch (action.type) {
    case _action_types.AdminTypes.RECEIVED_LDAP_GROUPS:
      {
        const nextState = {};

        for (const group of action.data.groups) {
          nextState[group.primary_key] = group;
        }

        return nextState;
      }

    case _action_types.AdminTypes.LINKED_LDAP_GROUP:
      {
        const nextState = _objectSpread({}, state);

        if (nextState[action.data.primary_key]) {
          nextState[action.data.primary_key] = action.data;
        }

        return nextState;
      }

    case _action_types.AdminTypes.UNLINKED_LDAP_GROUP:
      {
        const nextState = _objectSpread({}, state);

        if (nextState[action.data]) {
          nextState[action.data] = _objectSpread({}, nextState[action.data], {
            mattermost_group_id: null,
            has_syncables: null,
            failed: false
          });
        }

        return nextState;
      }

    case _action_types.AdminTypes.LINK_LDAP_GROUP_FAILURE:
      {
        const nextState = _objectSpread({}, state);

        if (nextState[action.data]) {
          nextState[action.data] = _objectSpread({}, nextState[action.data], {
            failed: true
          });
        }

        return nextState;
      }

    case _action_types.AdminTypes.UNLINK_LDAP_GROUP_FAILURE:
      {
        const nextState = _objectSpread({}, state);

        if (nextState[action.data]) {
          nextState[action.data] = _objectSpread({}, nextState[action.data], {
            failed: true
          });
        }

        return nextState;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

var _default = (0, _redux.combineReducers)({
  // array of strings each representing a log entry
  logs,
  // object where every key is an audit id and has an object with audit details
  audits,
  // object representing the server configuration
  config,
  // object representing which fields of the server configuration were set through the environment config
  environmentConfig,
  // object where every key is a report id and has an object with report details
  complianceReports,
  // array of cluster status data
  clusterInfo,
  // object with certificate type as keys and boolean statuses as values
  samlCertStatus,
  // object with analytic categories as types and numbers as values
  analytics,
  // object with team ids as keys and analytics objects as values
  teamAnalytics,
  // object with user ids as keys and objects, with token ids as keys, and
  // user access tokens as values without actual token
  userAccessTokensByUser: userAccessTokensForUser,
  // object with token ids as keys, and user access tokens as values without actual token
  userAccessTokens,
  // object with plugin ids as keys and objects representing plugin manifests as values
  plugins,
  // object with plugin ids as keys and objects representing plugin statuses across the cluster
  pluginStatuses,
  // object representing the ldap groups
  ldapGroups,
  // total ldap groups
  ldapGroupsCount
});

exports.default = _default;