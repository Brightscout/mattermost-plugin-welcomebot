"use strict";

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.customEmoji = customEmoji;
exports.default = void 0;

var _redux = require("redux");

var _action_types = require("../../action_types");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function customEmoji(state
/*: IDMappedObjects<CustomEmoji>*/
= {}, action
/*: GenericAction*/
)
/*: IDMappedObjects<CustomEmoji>*/
{
  switch (action.type) {
    case _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJI:
      {
        const nextState = _objectSpread({}, state);

        nextState[action.data.id] = action.data;
        return nextState;
      }

    case _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJIS:
      {
        const nextState = _objectSpread({}, state);

        for (const emoji of action.data) {
          nextState[emoji.id] = emoji;
        }

        return nextState;
      }

    case _action_types.EmojiTypes.DELETED_CUSTOM_EMOJI:
      {
        const nextState = _objectSpread({}, state);

        Reflect.deleteProperty(nextState, action.data.id);
        return nextState;
      }

    case _action_types.EmojiTypes.CLEAR_CUSTOM_EMOJIS:
    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    case _action_types.PostTypes.RECEIVED_NEW_POST:
    case _action_types.PostTypes.RECEIVED_POST:
      {
        const post
        /*: Post*/
        = action.data;
        return storeEmojisForPost(state, post);
      }

    case _action_types.PostTypes.RECEIVED_POSTS:
      {
        const posts = Object.values(action.data.posts);
        return (posts
        /*: any*/
        ).reduce(storeEmojisForPost, state); // Cast to any to avoid typing problems caused by Object.values
      }

    default:
      return state;
  }
}

function storeEmojisForPost(state
/*: IDMappedObjects<CustomEmoji>*/
, post
/*: Post*/
)
/*: IDMappedObjects<CustomEmoji>*/
{
  if (!post.metadata || !post.metadata.emojis) {
    return state;
  }

  return post.metadata.emojis.reduce((nextState, emoji) => {
    if (nextState[emoji.id]) {
      // Emoji is already in the store
      return nextState;
    }

    return _objectSpread({}, nextState, {
      [emoji.id]: emoji
    });
  }, state);
}

function nonExistentEmoji(state
/*: Set<string>*/
= new Set(), action
/*: GenericAction*/
)
/*: Set<string>*/
{
  switch (action.type) {
    case _action_types.EmojiTypes.CUSTOM_EMOJI_DOES_NOT_EXIST:
      {
        if (!state.has(action.data)) {
          const nextState = new Set(state);
          nextState.add(action.data);
          return nextState;
        }

        return state;
      }

    case _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJI:
      {
        if (action.data && state.has(action.data.name)) {
          const nextState = new Set(state);
          nextState.delete(action.data.name);
          return nextState;
        }

        return state;
      }

    case _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJIS:
      {
        const data = action.data || [];
        const nextState = new Set(state);
        let changed = false;

        for (const emoji of data) {
          if (emoji && nextState.has(emoji.name)) {
            nextState.delete(emoji.name);
            changed = true;
          }
        }

        return changed ? nextState : state;
      }

    case _action_types.EmojiTypes.CLEAR_CUSTOM_EMOJIS:
    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return new Set();

    default:
      return state;
  }
}

var _default = ((0, _redux.combineReducers)({
  // object where every key is the custom emoji id and has an object with the custom emoji details
  customEmoji,
  // set containing custom emoji names that do not exist
  nonExistentEmoji
})
/*: (EmojisState, GenericAction) => EmojisState*/
);

exports.default = _default;