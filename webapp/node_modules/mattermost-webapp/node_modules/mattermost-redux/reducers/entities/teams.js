"use strict";

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _redux = require("redux");

var _action_types = require("../../action_types");

var _team_utils = require("../../utils/team_utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function currentTeamId(state = '', action) {
  switch (action.type) {
    case _action_types.TeamTypes.SELECT_TEAM:
      return action.data;

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return '';

    default:
      return state;
  }
}

function teams(state = {}, action) {
  switch (action.type) {
    case _action_types.TeamTypes.RECEIVED_TEAMS_LIST:
    case _action_types.SchemeTypes.RECEIVED_SCHEME_TEAMS:
      return Object.assign({}, state, (0, _team_utils.teamListToMap)(action.data));

    case _action_types.TeamTypes.RECEIVED_TEAMS:
      return Object.assign({}, state, action.data);

    case _action_types.TeamTypes.CREATED_TEAM:
    case _action_types.TeamTypes.UPDATED_TEAM:
    case _action_types.TeamTypes.PATCHED_TEAM:
    case _action_types.TeamTypes.RECEIVED_TEAM:
      return _objectSpread({}, state, {
        [action.data.id]: action.data
      });

    case _action_types.TeamTypes.RECEIVED_TEAM_DELETED:
      {
        const nextState = _objectSpread({}, state);

        const teamId = action.data.id;

        if (nextState.hasOwnProperty(teamId)) {
          Reflect.deleteProperty(nextState, teamId);
          return nextState;
        }

        return state;
      }

    case _action_types.TeamTypes.UPDATED_TEAM_SCHEME:
      {
        const {
          teamId,
          schemeId
        } = action.data;
        const team = state[teamId];

        if (!team) {
          return state;
        }

        return _objectSpread({}, state, {
          [teamId]: _objectSpread({}, team, {
            scheme_id: schemeId
          })
        });
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function myMembers(state = {}, action) {
  function updateState(receivedTeams = {}, currentState = {}) {
    return Object.keys(receivedTeams).forEach(teamId => {
      if (receivedTeams[teamId].delete_at > 0 && currentState[teamId]) {
        Reflect.deleteProperty(currentState, teamId);
      }
    });
  }

  switch (action.type) {
    case _action_types.TeamTypes.RECEIVED_MY_TEAM_MEMBER:
      {
        const nextState = _objectSpread({}, state);

        const member = action.data;

        if (member.delete_at === 0) {
          nextState[member.team_id] = member;
        }

        return nextState;
      }

    case _action_types.TeamTypes.RECEIVED_MY_TEAM_MEMBERS:
      {
        const nextState = {};
        const members = action.data;

        for (const m of members) {
          if (m.delete_at == null || m.delete_at === 0) {
            const prevMember = state[m.team_id] || {
              mention_count: 0,
              msg_count: 0
            };
            nextState[m.team_id] = _objectSpread({}, prevMember, {}, m);
          }
        }

        return nextState;
      }

    case _action_types.TeamTypes.RECEIVED_TEAMS_LIST:
      {
        const nextState = _objectSpread({}, state);

        const receivedTeams = (0, _team_utils.teamListToMap)(action.data);
        return updateState(receivedTeams, nextState) || nextState;
      }

    case _action_types.TeamTypes.RECEIVED_TEAMS:
      {
        const nextState = _objectSpread({}, state);

        const receivedTeams = action.data;
        return updateState(receivedTeams, nextState) || nextState;
      }

    case _action_types.TeamTypes.RECEIVED_MY_TEAM_UNREADS:
      {
        const nextState = _objectSpread({}, state);

        const unreads = action.data;

        for (const u of unreads) {
          const msgCount = u.msg_count < 0 ? 0 : u.msg_count;
          const mentionCount = u.mention_count < 0 ? 0 : u.mention_count;

          const m = _objectSpread({}, state[u.team_id], {
            mention_count: mentionCount,
            msg_count: msgCount
          });

          nextState[u.team_id] = m;
        }

        return nextState;
      }

    case _action_types.ChannelTypes.INCREMENT_UNREAD_MSG_COUNT:
      {
        const {
          teamId,
          amount,
          onlyMentions
        } = action.data;
        const member = state[teamId];

        if (!member) {
          // Don't keep track of unread posts until we've loaded the actual team member
          return state;
        }

        if (onlyMentions) {
          // Incrementing the msg_count marks the team as unread, so don't do that if these posts shouldn't be unread
          return state;
        }

        return _objectSpread({}, state, {
          [teamId]: _objectSpread({}, member, {
            msg_count: member.msg_count + amount
          })
        });
      }

    case _action_types.ChannelTypes.DECREMENT_UNREAD_MSG_COUNT:
      {
        const {
          teamId,
          amount
        } = action.data;
        const member = state[teamId];

        if (!member) {
          // Don't keep track of unread posts until we've loaded the actual team member
          return state;
        }

        return _objectSpread({}, state, {
          [teamId]: _objectSpread({}, member, {
            msg_count: Math.max(member.msg_count - Math.abs(amount), 0)
          })
        });
      }

    case _action_types.ChannelTypes.INCREMENT_UNREAD_MENTION_COUNT:
      {
        const {
          teamId,
          amount
        } = action.data;
        const member = state[teamId];

        if (!member) {
          // Don't keep track of unread posts until we've loaded the actual team member
          return state;
        }

        return _objectSpread({}, state, {
          [teamId]: _objectSpread({}, member, {
            mention_count: member.mention_count + amount
          })
        });
      }

    case _action_types.ChannelTypes.DECREMENT_UNREAD_MENTION_COUNT:
      {
        const {
          teamId,
          amount
        } = action.data;
        const member = state[teamId];

        if (!member) {
          // Don't keep track of unread posts until we've loaded the actual team member
          return state;
        }

        return _objectSpread({}, state, {
          [teamId]: _objectSpread({}, member, {
            mention_count: Math.max(member.mention_count - amount, 0)
          })
        });
      }

    case _action_types.TeamTypes.LEAVE_TEAM:
    case _action_types.TeamTypes.RECEIVED_TEAM_DELETED:
      {
        const nextState = _objectSpread({}, state);

        const data = action.data;
        Reflect.deleteProperty(nextState, data.id);
        return nextState;
      }

    case _action_types.TeamTypes.UPDATED_TEAM_MEMBER_SCHEME_ROLES:
      {
        return updateTeamMemberSchemeRoles(state, action);
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function membersInTeam(state = {}, action) {
  switch (action.type) {
    case _action_types.TeamTypes.RECEIVED_MEMBER_IN_TEAM:
      {
        const data = action.data;

        const members = _objectSpread({}, state[data.team_id] || {});

        members[data.user_id] = data;
        return _objectSpread({}, state, {
          [data.team_id]: members
        });
      }

    case _action_types.TeamTypes.RECEIVED_TEAM_MEMBERS:
      {
        const data = action.data;

        if (data && data.length) {
          const nextState = _objectSpread({}, state);

          for (const member of data) {
            if (nextState[member.team_id]) {
              nextState[member.team_id] = _objectSpread({}, nextState[member.team_id]);
            } else {
              nextState[member.team_id] = {};
            }

            nextState[member.team_id][member.user_id] = member;
          }

          return nextState;
        }

        return state;
      }

    case _action_types.TeamTypes.RECEIVED_MEMBERS_IN_TEAM:
      {
        const data = action.data;

        if (data && data.length) {
          const teamId = data[0].team_id;

          const members = _objectSpread({}, state[teamId] || {});

          for (const member of data) {
            members[member.user_id] = member;
          }

          return _objectSpread({}, state, {
            [teamId]: members
          });
        }

        return state;
      }

    case _action_types.TeamTypes.REMOVE_MEMBER_FROM_TEAM:
      {
        const data = action.data;
        const members = state[data.team_id];

        if (members) {
          const nextState = _objectSpread({}, members);

          Reflect.deleteProperty(nextState, data.user_id);
          return _objectSpread({}, state, {
            [data.team_id]: nextState
          });
        }

        return state;
      }

    case _action_types.TeamTypes.RECEIVED_TEAM_DELETED:
      {
        const nextState = _objectSpread({}, state);

        const teamId = action.data.id;

        if (nextState.hasOwnProperty(teamId)) {
          Reflect.deleteProperty(nextState, teamId);
          return nextState;
        }

        return state;
      }

    case _action_types.TeamTypes.UPDATED_TEAM_MEMBER_SCHEME_ROLES:
      {
        return updateTeamMemberSchemeRoles(state, action);
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function stats(state = {}, action) {
  switch (action.type) {
    case _action_types.TeamTypes.RECEIVED_TEAM_STATS:
      {
        const stat = action.data;
        return _objectSpread({}, state, {
          [stat.team_id]: stat
        });
      }

    case _action_types.TeamTypes.RECEIVED_TEAM_DELETED:
      {
        const nextState = _objectSpread({}, state);

        const teamId = action.data.id;

        if (nextState.hasOwnProperty(teamId)) {
          Reflect.deleteProperty(nextState, teamId);
          return nextState;
        }

        return state;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function groupsAssociatedToTeam(state = {}, action) {
  switch (action.type) {
    case _action_types.GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_TEAM:
      {
        const {
          teamID,
          groups,
          totalGroupCount
        } = action.data;

        const nextState = _objectSpread({}, state);

        const associatedGroupIDs = new Set(state[teamID] ? state[teamID].ids : []);

        for (const group of groups) {
          associatedGroupIDs.add(group.id);
        }

        nextState[teamID] = {
          ids: Array.from(associatedGroupIDs),
          totalCount: totalGroupCount
        };
        return nextState;
      }

    case _action_types.GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_TEAM:
      {
        const {
          teamID,
          groups
        } = action.data;

        const nextState = _objectSpread({}, state);

        const associatedGroupIDs = new Set([]);

        for (const group of groups) {
          associatedGroupIDs.add(group.id);
        }

        const ids = Array.from(associatedGroupIDs);
        nextState[teamID] = {
          ids,
          totalCount: ids.length
        };
        return nextState;
      }

    case _action_types.GroupTypes.RECEIVED_GROUPS_NOT_ASSOCIATED_TO_TEAM:
      {
        const {
          teamID,
          groups
        } = action.data;

        const nextState = _objectSpread({}, state);

        const associatedGroupIDs = new Set(state[teamID] ? state[teamID].ids : []);

        for (const group of groups) {
          associatedGroupIDs.delete(group.id);
        }

        nextState[teamID] = Array.from(associatedGroupIDs);
        return nextState;
      }

    default:
      return state;
  }
}

function updateTeamMemberSchemeRoles(state, action) {
  const {
    teamId,
    userId,
    isSchemeUser,
    isSchemeAdmin
  } = action.data;
  const team = state[teamId];

  if (team) {
    const member = team[userId];

    if (member) {
      return _objectSpread({}, state, {
        [teamId]: _objectSpread({}, state[teamId], {
          [userId]: _objectSpread({}, state[teamId][userId], {
            scheme_user: isSchemeUser,
            scheme_admin: isSchemeAdmin
          })
        })
      });
    }
  }

  return state;
}

function totalCount(state = 0, action) {
  switch (action.type) {
    case _action_types.TeamTypes.RECEIVED_TOTAL_TEAM_COUNT:
      {
        return action.data;
      }

    default:
      return state;
  }
}

var _default = (0, _redux.combineReducers)({
  // the current selected team
  currentTeamId,
  // object where every key is the team id and has and object with the team detail
  teams,
  // object where every key is the team id and has and object with the team members detail
  myMembers,
  // object where every key is the team id and has an object of members in the team where the key is user id
  membersInTeam,
  // object where every key is the team id and has an object with the team stats
  stats,
  groupsAssociatedToTeam,
  totalCount
});

exports.default = _default;