"use strict";

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _redux = require("redux");

var _action_types = require("../../action_types");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const SEARCH_SELECTORS = {
  [_action_types.GifTypes.SELECT_SEARCH_TEXT]: (state, action) => _objectSpread({}, state, {
    searchText: action.searchText
  }),
  [_action_types.GifTypes.INVALIDATE_SEARCH_TEXT]: (state, action) => _objectSpread({}, state, {
    resultsByTerm: _objectSpread({}, state.resultsByTerm[action.searchText], {
      didInvalidate: true
    })
  }),
  [_action_types.GifTypes.REQUEST_SEARCH]: (state, action) => _objectSpread({}, state, {
    resultsByTerm: TERM_SELECTOR[action.type](state.resultsByTerm, action)
  }),
  [_action_types.GifTypes.RECEIVE_SEARCH]: (state, action) => _objectSpread({}, state, {
    searchText: action.searchText,
    resultsByTerm: TERM_SELECTOR[action.type](state.resultsByTerm, action)
  }),
  [_action_types.GifTypes.RECEIVE_SEARCH_END]: (state, action) => _objectSpread({}, state, {
    searchText: action.searchText,
    resultsByTerm: TERM_SELECTOR[action.type](state.resultsByTerm, action)
  }),
  [_action_types.GifTypes.RECEIVE_CATEGORY_SEARCH]: (state, action) => _objectSpread({}, state, {
    searchText: action.searchText,
    resultsByTerm: TERM_SELECTOR[action.type](state.resultsByTerm, action)
  }),
  [_action_types.GifTypes.SEARCH_FAILURE]: (state, action) => _objectSpread({}, state, {
    searchText: action.searchText,
    resultsByTerm: TERM_SELECTOR[action.type](state.resultsByTerm, action)
  }),
  [_action_types.GifTypes.CLEAR_SEARCH_RESULTS]: state => _objectSpread({}, state, {
    searchText: '',
    resultsByTerm: {}
  }),
  [_action_types.GifTypes.SAVE_SEARCH_SCROLL_POSITION]: (state, action) => _objectSpread({}, state, {
    scrollPosition: action.scrollPosition
  }),
  [_action_types.GifTypes.SAVE_SEARCH_PRIOR_LOCATION]: (state, action) => _objectSpread({}, state, {
    priorLocation: action.priorLocation
  }),
  [_action_types.GifTypes.UPDATE_SEARCH_TEXT]: (state, action) => _objectSpread({}, state, {
    searchText: action.searchText
  }),
  [_action_types.GifTypes.SAVE_SEARCH_BAR_TEXT]: (state, action) => _objectSpread({}, state, {
    searchBarText: action.searchBarText
  })
};
const CATEGORIES_SELECTORS = {
  [_action_types.GifTypes.REQUEST_CATEGORIES_LIST]: state => _objectSpread({}, state, {
    isFetching: true
  }),
  [_action_types.GifTypes.CATEGORIES_LIST_RECEIVED]: (state, action) => {
    const {
      cursor,
      tags
    } = action;
    const {
      tagsList: oldTagsList = []
    } = state;
    const tagsDict = {};
    const newTagsList = tags.filter(item => {
      return Boolean(item && item.gfycats[0] && item.gfycats[0].width);
    }).map(item => {
      tagsDict[item.tag] = true;
      return {
        tagName: item.tag,
        gfyId: item.gfycats[0].gfyId
      };
    });
    const tagsList = [...oldTagsList, ...newTagsList];
    return _objectSpread({}, state, {
      cursor,
      hasMore: Boolean(cursor),
      isFetching: false,
      tagsList,
      tagsDict
    });
  },
  [_action_types.GifTypes.CATEGORIES_LIST_FAILURE]: state => _objectSpread({}, state, {
    isFetching: false
  })
};
const TERM_SELECTOR = {
  [_action_types.GifTypes.REQUEST_SEARCH]: (state, action) => _objectSpread({}, state, {
    [action.searchText]: _objectSpread({}, state[action.searchText], {
      isFetching: true,
      didInvalidate: false,
      pages: PAGE_SELECTOR[action.type](state[action.searchText], action)
    })
  }),
  [_action_types.GifTypes.RECEIVE_SEARCH]: (state, action) => {
    const gfycats = action.gfycats.filter(item => {
      return Boolean(item.gfyId && item.width && item.height);
    });
    const newItems = gfycats.map(gfycat => gfycat.gfyId);
    return _objectSpread({}, state, {
      [action.searchText]: _objectSpread({}, state[action.searchText], {
        isFetching: false,
        items: typeof state[action.searchText] !== 'undefined' && state[action.searchText].items ? [...state[action.searchText].items, ...newItems] : newItems,
        moreRemaining: typeof state[action.searchText] !== 'undefined' && state[action.searchText].items ? [...state[action.searchText].items, ...action.gfycats].length < action.found : action.gfycats.length < action.found,
        count: action.count,
        found: action.found,
        start: action.start,
        currentPage: action.currentPage,
        pages: PAGE_SELECTOR[action.type](state[action.searchText], action),
        cursor: action.cursor
      })
    });
  },
  [_action_types.GifTypes.RECEIVE_CATEGORY_SEARCH]: (state, action) => {
    const gfycats = action.gfycats.filter(item => {
      return Boolean(item.gfyId && item.width && item.height);
    });
    const newItems = gfycats.map(gfycat => gfycat.gfyId);
    return _objectSpread({}, state, {
      [action.searchText]: _objectSpread({}, state[action.searchText], {
        isFetching: false,
        items: typeof state[action.searchText] !== 'undefined' && state[action.searchText].items ? [...state[action.searchText].items, ...newItems] : newItems,
        cursor: action.cursor,
        moreRemaining: Boolean(action.cursor)
      })
    });
  },
  [_action_types.GifTypes.RECEIVE_SEARCH_END]: (state, action) => _objectSpread({}, state, {
    [action.searchText]: _objectSpread({}, state[action.searchText], {
      isFetching: false,
      moreRemaining: false
    })
  }),
  [_action_types.GifTypes.SEARCH_FAILURE]: (state, action) => _objectSpread({}, state, {
    [action.searchText]: _objectSpread({}, state[action.searchText], {
      isFetching: false,
      items: [],
      moreRemaining: false,
      count: 0,
      found: 0,
      start: 0,
      isEmpty: true
    })
  })
};
const PAGE_SELECTOR = {
  [_action_types.GifTypes.REQUEST_SEARCH]: (state = {}) => {
    if (typeof state.pages == 'undefined') {
      return {};
    }

    return _objectSpread({}, state.pages);
  },
  [_action_types.GifTypes.RECEIVE_SEARCH]: (state, action) => _objectSpread({}, state.pages, {
    [action.currentPage]: action.gfycats.map(gfycat => gfycat.gfyId)
  })
};
const CACHE_SELECTORS = {
  [_action_types.GifTypes.CACHE_GIFS]: (state, action) => _objectSpread({}, state, {
    gifs: CACHE_GIF_SELECTOR[action.type](state.gifs, action),
    updating: false
  }),
  [_action_types.GifTypes.CACHE_REQUEST]: (state, action) => _objectSpread({}, state, {}, action.payload)
};
const CACHE_GIF_SELECTOR = {
  [_action_types.GifTypes.CACHE_GIFS]: (state, action) => _objectSpread({}, state, {}, action.gifs.reduce((map, obj) => {
    map[obj.gfyId] = obj;
    return map;
  }, {}))
};

function appReducer(state = {}, action) {
  const nextState = _objectSpread({}, state);

  switch (action.type) {
    case _action_types.GifTypes.SAVE_APP_PROPS:
      return _objectSpread({}, nextState, {}, action.props);

    default:
      return state;
  }
}

function categoriesReducer(state = {}, action) {
  const selector = CATEGORIES_SELECTORS[action.type];
  return selector ? selector(state, action) : state;
}

function searchReducer(state = {}, action) {
  const selector = SEARCH_SELECTORS[action.type];
  return selector ? selector(state, action) : state;
}

function cacheReducer(state = {}, action) {
  const selector = CACHE_SELECTORS[action.type];
  return selector ? selector(state, action) : state;
}

var _default = (0, _redux.combineReducers)({
  app: appReducer,
  categories: categoriesReducer,
  search: searchReducer,
  cache: cacheReducer
});

exports.default = _default;