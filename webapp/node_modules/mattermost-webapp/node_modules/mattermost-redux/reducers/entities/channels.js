"use strict";

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.channels = channels;
exports.default = void 0;

var _redux = require("redux");

var _action_types = require("../../action_types");

var _constants = require("../../constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function channelListToSet(state, action) {
  const nextState = _objectSpread({}, state);

  action.data.forEach(channel => {
    const nextSet = new Set(nextState[channel.team_id]);
    nextSet.add(channel.id);
    nextState[channel.team_id] = nextSet;
  });
  return nextState;
}

function removeChannelFromSet(state, action) {
  const id = action.data.team_id;
  const nextSet = new Set(state[id]);
  nextSet.delete(action.data.id);
  return _objectSpread({}, state, {
    [id]: nextSet
  });
}

function currentChannelId(state = '', action) {
  switch (action.type) {
    case _action_types.ChannelTypes.SELECT_CHANNEL:
      return action.data;

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return '';

    default:
      return state;
  }
}

function channels(state = {}, action) {
  switch (action.type) {
    case _action_types.ChannelTypes.RECEIVED_CHANNEL:
      if (state[action.data.id] && action.data.type === _constants.General.DM_CHANNEL) {
        action.data.display_name = action.data.display_name || state[action.data.id].display_name;
      }

      return _objectSpread({}, state, {
        [action.data.id]: action.data
      });

    case _action_types.ChannelTypes.RECEIVED_CHANNELS:
    case _action_types.ChannelTypes.RECEIVED_ALL_CHANNELS:
    case _action_types.SchemeTypes.RECEIVED_SCHEME_CHANNELS:
      {
        const nextState = _objectSpread({}, state);

        for (const channel of action.data) {
          if (state[channel.id] && channel.type === _constants.General.DM_CHANNEL) {
            channel.display_name = channel.display_name || state[channel.id].display_name;
          }

          nextState[channel.id] = channel;
        }

        return nextState;
      }

    case _action_types.ChannelTypes.RECEIVED_CHANNEL_DELETED:
      {
        const {
          id,
          deleteAt
        } = action.data;

        if (!state[id]) {
          return state;
        }

        return _objectSpread({}, state, {
          [id]: _objectSpread({}, state[id], {
            delete_at: deleteAt
          })
        });
      }

    case _action_types.ChannelTypes.UPDATE_CHANNEL_HEADER:
      {
        const {
          channelId,
          header
        } = action.data;

        if (!state[channelId]) {
          return state;
        }

        return _objectSpread({}, state, {
          [channelId]: _objectSpread({}, state[channelId], {
            header
          })
        });
      }

    case _action_types.ChannelTypes.UPDATE_CHANNEL_PURPOSE:
      {
        const {
          channelId,
          purpose
        } = action.data;

        if (!state[channelId]) {
          return state;
        }

        return _objectSpread({}, state, {
          [channelId]: _objectSpread({}, state[channelId], {
            purpose
          })
        });
      }

    case _action_types.ChannelTypes.LEAVE_CHANNEL:
      {
        if (action.data && action.data.type === _constants.General.PRIVATE_CHANNEL) {
          const nextState = _objectSpread({}, state);

          Reflect.deleteProperty(nextState, action.data.id);
          return nextState;
        }

        return state;
      }

    case _action_types.ChannelTypes.INCREMENT_TOTAL_MSG_COUNT:
      {
        const {
          channelId,
          amount
        } = action.data;
        const channel = state[channelId];

        if (!channel) {
          return state;
        }

        return _objectSpread({}, state, {
          [channelId]: _objectSpread({}, channel, {
            total_msg_count: channel.total_msg_count + amount
          })
        });
      }

    case _action_types.ChannelTypes.UPDATED_CHANNEL_SCHEME:
      {
        const {
          channelId,
          schemeId
        } = action.data;
        const channel = state[channelId];

        if (!channel) {
          return state;
        }

        return _objectSpread({}, state, {
          [channelId]: _objectSpread({}, channel, {
            scheme_id: schemeId
          })
        });
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function channelsInTeam(state = {}, action) {
  switch (action.type) {
    case _action_types.ChannelTypes.RECEIVED_CHANNEL:
      {
        const nextSet = new Set(state[action.data.team_id]);
        nextSet.add(action.data.id);
        return _objectSpread({}, state, {
          [action.data.team_id]: nextSet
        });
      }

    case _action_types.ChannelTypes.RECEIVED_CHANNELS:
      {
        return channelListToSet(state, action);
      }

    case _action_types.ChannelTypes.LEAVE_CHANNEL:
      {
        if (action.data && action.data.type === _constants.General.PRIVATE_CHANNEL) {
          return removeChannelFromSet(state, action);
        }

        return state;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function myMembers(state = {}, action) {
  switch (action.type) {
    case _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER:
      {
        const channelMember = action.data;
        return _objectSpread({}, state, {
          [channelMember.channel_id]: channelMember
        });
      }

    case _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBERS:
      {
        const nextState = _objectSpread({}, state);

        const remove = action.remove;

        if (remove) {
          remove.forEach(id => {
            Reflect.deleteProperty(nextState, id);
          });
        }

        for (const cm of action.data) {
          nextState[cm.channel_id] = cm;
        }

        return nextState;
      }

    case _action_types.ChannelTypes.RECEIVED_CHANNEL_PROPS:
      {
        const member = _objectSpread({}, state[action.data.channel_id]);

        member.notify_props = action.data.notifyProps;
        return _objectSpread({}, state, {
          [action.data.channel_id]: member
        });
      }

    case _action_types.ChannelTypes.INCREMENT_UNREAD_MSG_COUNT:
      {
        const {
          channelId,
          amount,
          onlyMentions
        } = action.data;
        const member = state[channelId];

        if (!member) {
          // Don't keep track of unread posts until we've loaded the actual channel member
          return state;
        }

        if (!onlyMentions) {
          // Incrementing the msg_count marks the channel as read, so don't do that if these posts should be unread
          return state;
        }

        return _objectSpread({}, state, {
          [channelId]: _objectSpread({}, member, {
            msg_count: member.msg_count + amount
          })
        });
      }

    case _action_types.ChannelTypes.DECREMENT_UNREAD_MSG_COUNT:
      {
        const {
          channelId,
          amount
        } = action.data;
        const member = state[channelId];

        if (!member) {
          // Don't keep track of unread posts until we've loaded the actual channel member
          return state;
        }

        return _objectSpread({}, state, {
          [channelId]: _objectSpread({}, member, {
            msg_count: member.msg_count + amount
          })
        });
      }

    case _action_types.ChannelTypes.INCREMENT_UNREAD_MENTION_COUNT:
      {
        const {
          channelId,
          amount
        } = action.data;
        const member = state[channelId];

        if (!member) {
          // Don't keep track of unread posts until we've loaded the actual channel member
          return state;
        }

        return _objectSpread({}, state, {
          [channelId]: _objectSpread({}, member, {
            mention_count: member.mention_count + amount
          })
        });
      }

    case _action_types.ChannelTypes.DECREMENT_UNREAD_MENTION_COUNT:
      {
        const {
          channelId,
          amount
        } = action.data;
        const member = state[channelId];

        if (!member) {
          // Don't keep track of unread posts until we've loaded the actual channel member
          return state;
        }

        return _objectSpread({}, state, {
          [channelId]: _objectSpread({}, member, {
            mention_count: Math.max(member.mention_count - amount, 0)
          })
        });
      }

    case _action_types.ChannelTypes.RECEIVED_LAST_VIEWED_AT:
      {
        const {
          data
        } = action;
        let member = state[data.channel_id];
        member = _objectSpread({}, member, {
          last_viewed_at: data.last_viewed_at
        });
        return _objectSpread({}, state, {
          [action.data.channel_id]: member
        });
      }

    case _action_types.ChannelTypes.LEAVE_CHANNEL:
      {
        const nextState = _objectSpread({}, state);

        if (action.data) {
          Reflect.deleteProperty(nextState, action.data.id);
          return nextState;
        }

        return state;
      }

    case _action_types.ChannelTypes.UPDATED_CHANNEL_MEMBER_SCHEME_ROLES:
      {
        return updateChannelMemberSchemeRoles(state, action);
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function membersInChannel(state = {}, action) {
  switch (action.type) {
    case _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER:
    case _action_types.ChannelTypes.RECEIVED_CHANNEL_MEMBER:
      {
        const member = action.data;

        const members = _objectSpread({}, state[member.channel_id] || {});

        members[member.user_id] = member;
        return _objectSpread({}, state, {
          [member.channel_id]: members
        });
      }

    case _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBERS:
    case _action_types.ChannelTypes.RECEIVED_CHANNEL_MEMBERS:
      {
        const nextState = _objectSpread({}, state);

        const remove = action.remove;
        const currentUserId = action.currentUserId;

        if (remove && currentUserId) {
          remove.forEach(id => {
            if (nextState[id]) {
              Reflect.deleteProperty(nextState[id], currentUserId);
            }
          });
        }

        for (const cm of action.data) {
          if (nextState[cm.channel_id]) {
            nextState[cm.channel_id] = _objectSpread({}, nextState[cm.channel_id]);
          } else {
            nextState[cm.channel_id] = {};
          }

          nextState[cm.channel_id][cm.user_id] = cm;
        }

        return nextState;
      }

    case _action_types.ChannelTypes.LEAVE_CHANNEL:
    case _action_types.UserTypes.RECEIVED_PROFILE_NOT_IN_CHANNEL:
      {
        if (action.data) {
          const data = action.data;

          const members = _objectSpread({}, state[data.id] || {});

          if (members) {
            Reflect.deleteProperty(members, data.user_id);
            return _objectSpread({}, state, {
              [data.id]: members
            });
          }
        }

        return state;
      }

    case _action_types.ChannelTypes.UPDATED_CHANNEL_MEMBER_SCHEME_ROLES:
      {
        return updateChannelMemberSchemeRoles(state, action);
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function stats(state = {}, action) {
  switch (action.type) {
    case _action_types.ChannelTypes.RECEIVED_CHANNEL_STATS:
      {
        const nextState = _objectSpread({}, state);

        const stat = action.data;
        nextState[stat.channel_id] = stat;
        return nextState;
      }

    case _action_types.ChannelTypes.ADD_CHANNEL_MEMBER_SUCCESS:
      {
        const nextState = _objectSpread({}, state);

        const id = action.id;
        const nextStat = nextState[id];

        if (nextStat) {
          const count = nextStat.member_count + 1;
          return _objectSpread({}, nextState, {
            [id]: _objectSpread({}, nextStat, {
              member_count: count
            })
          });
        }

        return state;
      }

    case _action_types.ChannelTypes.REMOVE_CHANNEL_MEMBER_SUCCESS:
      {
        const nextState = _objectSpread({}, state);

        const id = action.id;
        const nextStat = nextState[id];

        if (nextStat) {
          const count = nextStat.member_count - 1;
          return _objectSpread({}, nextState, {
            [id]: _objectSpread({}, nextStat, {
              member_count: count || 1
            })
          });
        }

        return state;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function groupsAssociatedToChannel(state = {}, action) {
  switch (action.type) {
    case _action_types.GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_CHANNEL:
      {
        const {
          channelID,
          groups,
          totalGroupCount
        } = action.data;

        const nextState = _objectSpread({}, state);

        const associatedGroupIDs = new Set(state[channelID] ? state[channelID].ids : []);

        for (const group of groups) {
          associatedGroupIDs.add(group.id);
        }

        nextState[channelID] = {
          ids: Array.from(associatedGroupIDs),
          totalCount: totalGroupCount
        };
        return nextState;
      }

    case _action_types.GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_CHANNEL:
      {
        const {
          channelID,
          groups
        } = action.data;

        const nextState = _objectSpread({}, state);

        const associatedGroupIDs = new Set([]);

        for (const group of groups) {
          associatedGroupIDs.add(group.id);
        }

        const ids = Array.from(associatedGroupIDs);
        nextState[channelID] = {
          ids,
          totalCount: ids.length
        };
        return nextState;
      }

    case _action_types.GroupTypes.RECEIVED_GROUPS_NOT_ASSOCIATED_TO_CHANNEL:
      {
        const {
          channelID,
          groups
        } = action.data;

        const nextState = _objectSpread({}, state);

        const associatedGroupIDs = new Set(state[channelID] ? state[channelID].ids : []);

        for (const group of groups) {
          associatedGroupIDs.delete(group.id);
        }

        nextState[channelID] = Array.from(associatedGroupIDs);
        return nextState;
      }

    default:
      return state;
  }
}

function updateChannelMemberSchemeRoles(state, action) {
  const {
    channelId,
    userId,
    isSchemeUser,
    isSchemeAdmin
  } = action.data;
  const channel = state[channelId];

  if (channel) {
    const member = channel[userId];

    if (member) {
      return _objectSpread({}, state, {
        [channelId]: _objectSpread({}, state[channelId], {
          [userId]: _objectSpread({}, state[channelId][userId], {
            scheme_user: isSchemeUser,
            scheme_admin: isSchemeAdmin
          })
        })
      });
    }
  }

  return state;
}

function totalCount(state = 0, action) {
  switch (action.type) {
    case _action_types.ChannelTypes.RECEIVED_TOTAL_CHANNEL_COUNT:
      {
        return action.data;
      }

    default:
      return state;
  }
}

var _default = (0, _redux.combineReducers)({
  // the current selected channel
  currentChannelId,
  // object where every key is the channel id and has and object with the channel detail
  channels,
  // object where every key is a team id and has set of channel ids that are on the team
  channelsInTeam,
  // object where every key is the channel id and has an object with the channel members detail
  myMembers,
  // object where every key is the channel id with an object where key is a user id and has an object with the channel members detail
  membersInChannel,
  // object where every key is the channel id and has an object with the channel stats
  stats,
  groupsAssociatedToChannel,
  totalCount
});

exports.default = _default;