"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.files = files;
exports.fileIdsByPostId = fileIdsByPostId;
exports.default = void 0;

var _redux = require("redux");

var _action_types = require("../../action_types");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function files(state = {}, action) {
  switch (action.type) {
    case _action_types.FileTypes.RECEIVED_UPLOAD_FILES:
    case _action_types.FileTypes.RECEIVED_FILES_FOR_POST:
      {
        const filesById = action.data.reduce((filesMap, file) => {
          return _objectSpread({}, filesMap, {
            [file.id]: file
          });
        }, {});
        return _objectSpread({}, state, {}, filesById);
      }

    case _action_types.PostTypes.RECEIVED_NEW_POST:
    case _action_types.PostTypes.RECEIVED_POST:
      {
        const post = action.data;
        return storeFilesForPost(state, post);
      }

    case _action_types.PostTypes.RECEIVED_POSTS:
      {
        const posts = Object.values(action.data.posts);
        return posts.reduce(storeFilesForPost, state);
      }

    case _action_types.PostTypes.POST_DELETED:
    case _action_types.PostTypes.POST_REMOVED:
      {
        if (action.data && action.data.file_ids && action.data.file_ids.length) {
          const nextState = _objectSpread({}, state);

          const fileIds = action.data.file_ids;
          fileIds.forEach(id => {
            Reflect.deleteProperty(nextState, id);
          });
          return nextState;
        }

        return state;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function storeFilesForPost(state, post) {
  if (!post.metadata || !post.metadata.files) {
    return state;
  }

  return post.metadata.files.reduce((nextState, file) => {
    if (nextState[file.id]) {
      // File is already in the store
      return nextState;
    }

    return _objectSpread({}, nextState, {
      [file.id]: file
    });
  }, state);
}

function fileIdsByPostId(state = {}, action) {
  switch (action.type) {
    case _action_types.FileTypes.RECEIVED_FILES_FOR_POST:
      {
        const {
          data,
          postId
        } = action;
        const filesIdsForPost = data.map(file => file.id);
        return _objectSpread({}, state, {
          [postId]: filesIdsForPost
        });
      }

    case _action_types.PostTypes.RECEIVED_NEW_POST:
    case _action_types.PostTypes.RECEIVED_POST:
      {
        const post = action.data;
        return storeFilesIdsForPost(state, post);
      }

    case _action_types.PostTypes.RECEIVED_POSTS:
      {
        const posts = Object.values(action.data.posts);
        return posts.reduce(storeFilesIdsForPost, state);
      }

    case _action_types.PostTypes.POST_DELETED:
    case _action_types.PostTypes.POST_REMOVED:
      {
        if (action.data) {
          const nextState = _objectSpread({}, state);

          Reflect.deleteProperty(nextState, action.data.id);
          return nextState;
        }

        return state;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return {};

    default:
      return state;
  }
}

function storeFilesIdsForPost(state, post) {
  if (!post.metadata || !post.metadata.files) {
    return state;
  }

  return _objectSpread({}, state, {
    [post.id]: post.metadata.files ? post.metadata.files.map(file => file.id) : []
  });
}

function filePublicLink(state = {}, action) {
  switch (action.type) {
    case _action_types.FileTypes.RECEIVED_FILE_PUBLIC_LINK:
      {
        return action.data;
      }

    case _action_types.UserTypes.LOGOUT_SUCCESS:
      return '';

    default:
      return state;
  }
}

var _default = (0, _redux.combineReducers)({
  files,
  fileIdsByPostId,
  filePublicLink
});

exports.default = _default;