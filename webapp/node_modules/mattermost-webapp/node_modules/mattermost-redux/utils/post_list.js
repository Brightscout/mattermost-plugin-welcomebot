"use strict";

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makePreparePostIdsForPostList = makePreparePostIdsForPostList;
exports.makeFilterPostsAndAddSeparators = makeFilterPostsAndAddSeparators;
exports.makeCombineUserActivityPosts = makeCombineUserActivityPosts;
exports.isStartOfNewMessages = isStartOfNewMessages;
exports.isDateLine = isDateLine;
exports.getDateForDateLine = getDateForDateLine;
exports.isCombinedUserActivityPost = isCombinedUserActivityPost;
exports.getPostIdsForCombinedUserActivityPost = getPostIdsForCombinedUserActivityPost;
exports.getFirstPostId = getFirstPostId;
exports.getLastPostId = getLastPostId;
exports.getLastPostIndex = getLastPostIndex;
exports.makeGenerateCombinedPost = makeGenerateCombinedPost;
exports.comparePostTypes = comparePostTypes;
exports.combineUserActivitySystemPost = combineUserActivitySystemPost;
exports.postTypePriority = exports.MAX_COMBINED_SYSTEM_POSTS = exports.START_OF_NEW_MESSAGES = exports.DATE_LINE = exports.COMBINED_USER_ACTIVITY = void 0;

var _reselect = require("reselect");

var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _constants = require("../constants");

var _posts = require("../selectors/entities/posts");

var _preferences = require("../selectors/entities/preferences");

var _timezone = require("../selectors/entities/timezone");

var _users = require("../selectors/entities/users");

var _helpers = require("./helpers");

var _post_utils = require("./post_utils");

var _timezone_utils = require("./timezone_utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const COMBINED_USER_ACTIVITY = 'user-activity-';
exports.COMBINED_USER_ACTIVITY = COMBINED_USER_ACTIVITY;
const DATE_LINE = 'date-';
exports.DATE_LINE = DATE_LINE;
const START_OF_NEW_MESSAGES = 'start-of-new-messages';
exports.START_OF_NEW_MESSAGES = START_OF_NEW_MESSAGES;
const MAX_COMBINED_SYSTEM_POSTS = 100;
exports.MAX_COMBINED_SYSTEM_POSTS = MAX_COMBINED_SYSTEM_POSTS;

function shouldShowJoinLeaveMessages(state) {
  // This setting is true or not set if join/leave messages are to be displayed
  return (0, _preferences.getBool)(state, _constants.Preferences.CATEGORY_ADVANCED_SETTINGS, _constants.Preferences.ADVANCED_FILTER_JOIN_LEAVE, true);
}

function makePreparePostIdsForPostList() {
  const filterPostsAndAddSeparators = makeFilterPostsAndAddSeparators();
  const combineUserActivityPosts = makeCombineUserActivityPosts();
  return (state, options) => {
    let postIds = filterPostsAndAddSeparators(state, options);
    postIds = combineUserActivityPosts(state, postIds);
    return postIds;
  };
} // Returns a selector that, given the state and an object containing an array of postIds and an optional
// timestamp of when the channel was last read, returns a memoized array of postIds interspersed with
// day indicators and an optional new message indicator.


function makeFilterPostsAndAddSeparators() {
  const getPostsForIds = (0, _posts.makeGetPostsForIds)();
  return (0, _helpers.createIdsSelector)((state, {
    postIds
  }) => getPostsForIds(state, postIds), (state, {
    lastViewedAt
  }) => lastViewedAt, (state, {
    indicateNewMessages
  }) => indicateNewMessages, state => state.entities.posts.selectedPostId, _users.getCurrentUser, shouldShowJoinLeaveMessages, _timezone.isTimezoneEnabled, (posts, lastViewedAt, indicateNewMessages, selectedPostId, currentUser, showJoinLeave, timeZoneEnabled) => {
    if (posts.length === 0 || !currentUser) {
      return [];
    }

    const out = [];
    let lastDate = null;
    let addedNewMessagesIndicator = false; // Iterating through the posts from oldest to newest

    for (let i = posts.length - 1; i >= 0; i--) {
      const post = posts[i];

      if (!post || post.type === _constants.Posts.POST_TYPES.EPHEMERAL_ADD_TO_CHANNEL && !selectedPostId) {
        continue;
      } // Filter out join/leave messages if necessary


      if ((0, _post_utils.shouldFilterJoinLeavePost)(post, showJoinLeave, currentUser.username)) {
        continue;
      } // Push on a date header if the last post was on a different day than the current one


      const postDate = new Date(post.create_at);

      if (timeZoneEnabled) {
        const currentOffset = postDate.getTimezoneOffset() * 60 * 1000;
        const timezone = (0, _timezone_utils.getUserCurrentTimezone)(currentUser.timezone);

        if (timezone) {
          const timezoneOffset = _momentTimezone.default.tz.zone(timezone).utcOffset(post.create_at) * 60 * 1000;
          postDate.setTime(post.create_at + (currentOffset - timezoneOffset));
        }
      }

      postDate.setHours(0, 0, 0, 0);

      if (!lastDate || lastDate.toDateString() !== postDate.toDateString()) {
        out.push(DATE_LINE + postDate.getTime());
        lastDate = postDate;
      }

      if (lastViewedAt && post.create_at > lastViewedAt && post.user_id !== currentUser.id && !addedNewMessagesIndicator && indicateNewMessages) {
        out.push(START_OF_NEW_MESSAGES);
        addedNewMessagesIndicator = true;
      }

      out.push(post.id);
    } // Flip it back to newest to oldest


    return out.reverse();
  });
}

function makeCombineUserActivityPosts() {
  return (0, _helpers.createIdsSelector)((state, postIds) => postIds, state => state.entities.posts.posts, (postIds, posts) => {
    let lastPostIsUserActivity = false;
    let combinedCount = 0;
    const out = [];
    let changed = false;

    for (let i = 0; i < postIds.length; i++) {
      const postId = postIds[i];

      if (postId === START_OF_NEW_MESSAGES || postId.startsWith(DATE_LINE)) {
        // Not a post, so it won't be combined
        out.push(postId);
        lastPostIsUserActivity = false;
        combinedCount = 0;
        continue;
      }

      const post = posts[postId];
      const postIsUserActivity = (0, _post_utils.isUserActivityPost)(post.type);

      if (postIsUserActivity && lastPostIsUserActivity && combinedCount < MAX_COMBINED_SYSTEM_POSTS) {
        // Add the ID to the previous combined post
        out[out.length - 1] += '_' + postId;
        combinedCount += 1;
        changed = true;
      } else if (postIsUserActivity) {
        // Start a new combined post, even if the "combined" post is only a single post
        out.push(COMBINED_USER_ACTIVITY + postId);
        combinedCount = 1;
        changed = true;
      } else {
        out.push(postId);
        combinedCount = 0;
      }

      lastPostIsUserActivity = postIsUserActivity;
    }

    if (!changed) {
      // Nothing was combined, so return the original array
      return postIds;
    }

    return out;
  });
}

function isStartOfNewMessages(item) {
  return item === START_OF_NEW_MESSAGES;
}

function isDateLine(item) {
  return item.startsWith(DATE_LINE);
}

function getDateForDateLine(item) {
  return parseInt(item.substring(DATE_LINE.length), 10);
}

function isCombinedUserActivityPost(item) {
  return /^user-activity-(?:[^_]+_)*[^_]+$/.test(item);
}

function getPostIdsForCombinedUserActivityPost(item) {
  return item.substring(COMBINED_USER_ACTIVITY.length).split('_');
}

function getFirstPostId(items) {
  for (let i = 0; i < items.length; i++) {
    const item = items[i];

    if (isStartOfNewMessages(item) || isDateLine(item)) {
      // This is not a post at all
      continue;
    }

    if (isCombinedUserActivityPost(item)) {
      // This is a combined post, so find the first post ID from it
      const combinedIds = getPostIdsForCombinedUserActivityPost(item);
      return combinedIds[0];
    } // This is a post ID


    return item;
  }

  return '';
}

function getLastPostId(items) {
  for (let i = items.length - 1; i >= 0; i--) {
    const item = items[i];

    if (isStartOfNewMessages(item) || isDateLine(item)) {
      // This is not a post at all
      continue;
    }

    if (isCombinedUserActivityPost(item)) {
      // This is a combined post, so find the first post ID from it
      const combinedIds = getPostIdsForCombinedUserActivityPost(item);
      return combinedIds[combinedIds.length - 1];
    } // This is a post ID


    return item;
  }

  return '';
}

function getLastPostIndex(postIds) {
  let index = 0;

  for (let i = postIds.length - 1; i > 0; i--) {
    const item = postIds[i];

    if (!isStartOfNewMessages(item) && !isDateLine(item)) {
      index = i;
      break;
    }
  }

  return index;
}

function makeGenerateCombinedPost() {
  const getPostsForIds = (0, _posts.makeGetPostsForIds)();
  const getPostIds = (0, _helpers.memoizeResult)(getPostIdsForCombinedUserActivityPost);
  return (0, _reselect.createSelector)((state, combinedId) => combinedId, (state, combinedId) => getPostsForIds(state, getPostIds(combinedId)), (combinedId, posts) => {
    // All posts should be in the same channel
    const channelId = posts[0].channel_id; // Assume that the last post is the oldest one

    const createAt = posts[posts.length - 1].create_at;
    const messages = posts.map(post => post.message);
    return {
      id: combinedId,
      root_id: '',
      channel_id: channelId,
      create_at: createAt,
      delete_at: 0,
      message: messages.join('\n'),
      props: {
        messages,
        user_activity: combineUserActivitySystemPost(posts)
      },
      state: '',
      system_post_ids: posts.map(post => post.id),
      type: _constants.Posts.POST_TYPES.COMBINED_USER_ACTIVITY,
      user_activity_posts: posts,
      user_id: '',
      metadata: {}
    };
  });
}

const postTypePriority = {
  [_constants.Posts.POST_TYPES.JOIN_TEAM]: 0,
  [_constants.Posts.POST_TYPES.ADD_TO_TEAM]: 1,
  [_constants.Posts.POST_TYPES.LEAVE_TEAM]: 2,
  [_constants.Posts.POST_TYPES.REMOVE_FROM_TEAM]: 3,
  [_constants.Posts.POST_TYPES.JOIN_CHANNEL]: 4,
  [_constants.Posts.POST_TYPES.ADD_TO_CHANNEL]: 5,
  [_constants.Posts.POST_TYPES.LEAVE_CHANNEL]: 6,
  [_constants.Posts.POST_TYPES.REMOVE_FROM_CHANNEL]: 7,
  [_constants.Posts.POST_TYPES.PURPOSE_CHANGE]: 8,
  [_constants.Posts.POST_TYPES.HEADER_CHANGE]: 9,
  [_constants.Posts.POST_TYPES.JOIN_LEAVE]: 10,
  [_constants.Posts.POST_TYPES.DISPLAYNAME_CHANGE]: 11,
  [_constants.Posts.POST_TYPES.CONVERT_CHANNEL]: 12,
  [_constants.Posts.POST_TYPES.CHANNEL_DELETED]: 13,
  [_constants.Posts.POST_TYPES.ADD_REMOVE]: 14,
  [_constants.Posts.POST_TYPES.EPHEMERAL]: 15
};
exports.postTypePriority = postTypePriority;

function comparePostTypes(a, b) {
  return postTypePriority[a.postType] - postTypePriority[b.postType];
}

function extractUserActivityData(userActivities) {
  const messageData = [];
  const allUserIds = [];
  const allUsernames = [];
  Object.entries(userActivities).forEach(([postType, values]) => {
    if (postType === _constants.Posts.POST_TYPES.ADD_TO_TEAM || postType === _constants.Posts.POST_TYPES.ADD_TO_CHANNEL || postType === _constants.Posts.POST_TYPES.REMOVE_FROM_CHANNEL) {
      Object.keys(values).map(key => [key, values[key]]).forEach(([actorId, users]) => {
        if (Array.isArray(users)) {
          throw new Error('Invalid Post activity data');
        }

        const {
          ids,
          usernames
        } = users;
        messageData.push({
          postType,
          userIds: [...usernames, ...ids],
          actorId
        });

        if (ids.length > 0) {
          allUserIds.push(...ids);
        }

        if (usernames.length > 0) {
          allUsernames.push(...usernames);
        }

        allUserIds.push(actorId);
      });
    } else {
      if (!Array.isArray(values)) {
        throw new Error('Invalid Post activity data');
      }

      messageData.push({
        postType,
        userIds: values
      });
      allUserIds.push(...values);
    }
  });
  messageData.sort(comparePostTypes);

  function reduceUsers(acc, curr) {
    if (!acc.includes(curr)) {
      acc.push(curr);
    }

    return acc;
  }

  return {
    allUserIds: allUserIds.reduce(reduceUsers, []),
    allUsernames: allUsernames.reduce(reduceUsers, []),
    messageData
  };
}

function combineUserActivitySystemPost(systemPosts = []) {
  if (systemPosts.length === 0) {
    return null;
  }

  const userActivities = systemPosts.reduce((acc, post) => {
    const postType = post.type;
    let userActivityProps = acc;
    const combinedPostType = userActivityProps[postType];

    if (postType === _constants.Posts.POST_TYPES.ADD_TO_TEAM || postType === _constants.Posts.POST_TYPES.ADD_TO_CHANNEL || postType === _constants.Posts.POST_TYPES.REMOVE_FROM_CHANNEL) {
      const userId = post.props.addedUserId || post.props.removedUserId;
      const username = post.props.addedUsername || post.props.removedUsername;

      if (combinedPostType) {
        if (Array.isArray(combinedPostType[post.user_id])) {
          throw new Error('Invalid Post activity data');
        }

        const users = combinedPostType[post.user_id] || {
          ids: [],
          usernames: []
        };

        if (userId) {
          if (!users.ids.includes(userId)) {
            users.ids.push(userId);
          }
        } else if (username && !users.usernames.includes(username)) {
          users.usernames.push(username);
        }

        combinedPostType[post.user_id] = users;
      } else {
        const users = {
          ids: [],
          usernames: []
        };

        if (userId) {
          users.ids.push(userId);
        } else if (username) {
          users.usernames.push(username);
        }

        userActivityProps[postType] = {
          [post.user_id]: users
        };
      }
    } else {
      const propsUserId = post.user_id;

      if (combinedPostType) {
        if (!Array.isArray(combinedPostType)) {
          throw new Error('Invalid Post activity data');
        }

        if (!combinedPostType.includes(propsUserId)) {
          userActivityProps[postType] = [...combinedPostType, propsUserId];
        }
      } else {
        userActivityProps = _objectSpread({}, userActivityProps, {
          [postType]: [propsUserId]
        });
      }
    }

    return userActivityProps;
  }, {});
  return extractUserActivityData(userActivities);
}