"use strict";

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPostFlagged = isPostFlagged;
exports.isSystemMessage = isSystemMessage;
exports.isMeMessage = isMeMessage;
exports.isFromWebhook = isFromWebhook;
exports.isPostEphemeral = isPostEphemeral;
exports.shouldIgnorePost = shouldIgnorePost;
exports.isUserActivityPost = isUserActivityPost;
exports.isPostOwner = isPostOwner;
exports.isEdited = isEdited;
exports.canDeletePost = canDeletePost;
exports.canEditPost = canEditPost;
exports.getLastCreateAt = getLastCreateAt;
exports.shouldFilterJoinLeavePost = shouldFilterJoinLeavePost;
exports.isPostPendingOrFailed = isPostPendingOrFailed;
exports.comparePosts = comparePosts;
exports.isPostCommentMention = isPostCommentMention;
exports.fromAutoResponder = fromAutoResponder;

var _constants = require("../constants");

var _general = require("../selectors/entities/general");

var _roles = require("../selectors/entities/roles");

var _preference_utils = require("./preference_utils");

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow
function isPostFlagged(postId
/*: $ID<Post>*/
, myPreferences
/*: {[string]: PreferenceType}*/
)
/*: boolean*/
{
  const key = (0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_FLAGGED_POST, postId);
  return myPreferences.hasOwnProperty(key);
}

function isSystemMessage(post
/*: Post*/
)
/*: boolean*/
{
  return Boolean(post.type && post.type.startsWith(_constants.Posts.SYSTEM_MESSAGE_PREFIX));
}

function isMeMessage(post
/*: Post*/
)
/*: boolean*/
{
  return Boolean(post.type && post.type === _constants.Posts.POST_TYPES.ME);
}

function isFromWebhook(post
/*: Post*/
)
/*: boolean*/
{
  return post.props && post.props.from_webhook;
}

function isPostEphemeral(post
/*: Post*/
)
/*: boolean*/
{
  return post.type === _constants.Posts.POST_TYPES.EPHEMERAL || post.type === _constants.Posts.POST_TYPES.EPHEMERAL_ADD_TO_CHANNEL || post.state === _constants.Posts.POST_DELETED;
}

function shouldIgnorePost(post
/*: Post*/
)
/*: boolean*/
{
  return _constants.Posts.IGNORE_POST_TYPES.includes(post.type);
}

function isUserActivityPost(postType
/*: PostType*/
)
/*: boolean*/
{
  return _constants.Posts.USER_ACTIVITY_POST_TYPES.includes(postType);
}

function isPostOwner(userId
/*: $ID<UserProfile>*/
, post
/*: Post*/
) {
  return userId === post.user_id;
}

function isEdited(post
/*: Post*/
)
/*: boolean*/
{
  return post.edit_at > 0;
}

function canDeletePost(state
/*: GlobalState*/
, config
/*: Object*/
, license
/*: Object*/
, teamId
/*: $ID<Team>*/
, channelId
/*: $ID<Channel>*/
, userId
/*: $ID<UserProfile>*/
, post
/*: Post*/
, isAdmin
/*: boolean*/
, isSystemAdmin
/*: boolean*/
)
/*: boolean*/
{
  if (!post) {
    return false;
  }

  const isOwner = isPostOwner(userId, post);

  if ((0, _general.hasNewPermissions)(state)) {
    const canDelete = (0, _roles.haveIChannelPermission)(state, {
      team: teamId,
      channel: channelId,
      permission: _constants.Permissions.DELETE_POST
    });

    if (!isOwner) {
      return canDelete && (0, _roles.haveIChannelPermission)(state, {
        team: teamId,
        channel: channelId,
        permission: _constants.Permissions.DELETE_OTHERS_POSTS
      });
    }

    return canDelete;
  } // Backwards compatibility with pre-advanced permissions config settings.


  if (license.IsLicensed === 'true') {
    return config.RestrictPostDelete === _constants.General.PERMISSIONS_ALL && (isOwner || isAdmin) || config.RestrictPostDelete === _constants.General.PERMISSIONS_TEAM_ADMIN && isAdmin || config.RestrictPostDelete === _constants.General.PERMISSIONS_SYSTEM_ADMIN && isSystemAdmin;
  }

  return isOwner || isAdmin;
}

function canEditPost(state
/*: GlobalState*/
, config
/*: Object*/
, license
/*: Object*/
, teamId
/*: $ID<Team>*/
, channelId
/*: $ID<Channel>*/
, userId
/*: $ID<UserProfile>*/
, post
/*: Post*/
)
/*: boolean*/
{
  if (!post || isSystemMessage(post)) {
    return false;
  }

  const isOwner = isPostOwner(userId, post);
  let canEdit = true;

  if ((0, _general.hasNewPermissions)(state)) {
    canEdit = canEdit && (0, _roles.haveIChannelPermission)(state, {
      team: teamId,
      channel: channelId,
      permission: _constants.Permissions.EDIT_POST
    });

    if (!isOwner) {
      canEdit = canEdit && (0, _roles.haveIChannelPermission)(state, {
        team: teamId,
        channel: channelId,
        permission: _constants.Permissions.EDIT_OTHERS_POSTS
      });
    }

    if (license.IsLicensed === 'true' && config.PostEditTimeLimit !== '-1' && config.PostEditTimeLimit !== -1) {
      const timeLeft = post.create_at + config.PostEditTimeLimit * 1000 - Date.now();

      if (timeLeft <= 0) {
        canEdit = false;
      }
    }
  } else {
    // Backwards compatibility with pre-advanced permissions config settings.
    canEdit = isOwner && config.AllowEditPost !== 'never';

    if (config.AllowEditPost === _constants.General.ALLOW_EDIT_POST_TIME_LIMIT) {
      const timeLeft = post.create_at + config.PostEditTimeLimit * 1000 - Date.now();

      if (timeLeft <= 0) {
        canEdit = false;
      }
    }
  }

  return canEdit;
}

function getLastCreateAt(postsArray
/*: Array<Post>*/
)
/*: number*/
{
  const createAt = postsArray.map(p => p.create_at);

  if (createAt.length) {
    return Reflect.apply(Math.max, null, createAt);
  }

  return 0;
}

const joinLeavePostTypes = [_constants.Posts.POST_TYPES.JOIN_LEAVE, _constants.Posts.POST_TYPES.JOIN_CHANNEL, _constants.Posts.POST_TYPES.LEAVE_CHANNEL, _constants.Posts.POST_TYPES.ADD_REMOVE, _constants.Posts.POST_TYPES.ADD_TO_CHANNEL, _constants.Posts.POST_TYPES.REMOVE_FROM_CHANNEL, _constants.Posts.POST_TYPES.JOIN_TEAM, _constants.Posts.POST_TYPES.LEAVE_TEAM, _constants.Posts.POST_TYPES.ADD_TO_TEAM, _constants.Posts.POST_TYPES.REMOVE_FROM_TEAM, _constants.Posts.POST_TYPES.COMBINED_USER_ACTIVITY]; // Returns true if a post should be hidden when the user has Show Join/Leave Messages disabled

function shouldFilterJoinLeavePost(post
/*: Post*/
, showJoinLeave
/*: boolean*/
, currentUsername
/*: string*/
)
/*: boolean*/
{
  if (showJoinLeave) {
    return false;
  } // Don't filter out non-join/leave messages


  if (joinLeavePostTypes.indexOf(post.type) === -1) {
    return false;
  } // Don't filter out join/leave messages about the current user


  return !isJoinLeavePostForUsername(post, currentUsername);
}

function isJoinLeavePostForUsername(post
/*: Post*/
, currentUsername
/*: string*/
)
/*: boolean*/
{
  if (!post.props || !currentUsername) {
    return false;
  }

  if (post.user_activity_posts) {
    for (const childPost of post.user_activity_posts) {
      if (isJoinLeavePostForUsername(childPost, currentUsername)) {
        // If any of the contained posts are for this user, the client will
        // need to figure out how to render the post
        return true;
      }
    }
  }

  return post.props.username === currentUsername || post.props.addedUsername === currentUsername || post.props.removedUsername === currentUsername;
}

function isPostPendingOrFailed(post
/*: Post*/
)
/*: boolean*/
{
  return post.failed || post.id === post.pending_post_id;
}

function comparePosts(a
/*: Post*/
, b
/*: Post*/
)
/*: number*/
{
  const aIsPendingOrFailed = isPostPendingOrFailed(a);
  const bIsPendingOrFailed = isPostPendingOrFailed(b);

  if (aIsPendingOrFailed && !bIsPendingOrFailed) {
    return -1;
  } else if (!aIsPendingOrFailed && bIsPendingOrFailed) {
    return 1;
  }

  if (a.create_at > b.create_at) {
    return -1;
  } else if (a.create_at < b.create_at) {
    return 1;
  }

  return 0;
}

function isPostCommentMention({
  post,
  currentUser,
  threadRepliedToByCurrentUser,
  rootPost
}
/*: {post: Post, currentUser: UserProfile, threadRepliedToByCurrentUser: boolean, rootPost: Post}*/
)
/*: boolean*/
{
  let commentsNotifyLevel = _constants.Preferences.COMMENTS_NEVER;
  let isCommentMention = false;
  let threadCreatedByCurrentUser = false;

  if (rootPost && rootPost.user_id === currentUser.id) {
    threadCreatedByCurrentUser = true;
  }

  if (currentUser.notify_props && currentUser.notify_props.comments) {
    commentsNotifyLevel = currentUser.notify_props.comments;
  }

  const notCurrentUser = post.user_id !== currentUser.id || post.props && post.props.from_webhook;

  if (notCurrentUser) {
    if (commentsNotifyLevel === _constants.Preferences.COMMENTS_ANY && (threadCreatedByCurrentUser || threadRepliedToByCurrentUser)) {
      isCommentMention = true;
    } else if (commentsNotifyLevel === _constants.Preferences.COMMENTS_ROOT && threadCreatedByCurrentUser) {
      isCommentMention = true;
    }
  }

  return isCommentMention;
}

function fromAutoResponder(post
/*: Post*/
)
/*: boolean*/
{
  return Boolean(post.type && post.type === _constants.Posts.SYSTEM_AUTO_RESPONDER);
}