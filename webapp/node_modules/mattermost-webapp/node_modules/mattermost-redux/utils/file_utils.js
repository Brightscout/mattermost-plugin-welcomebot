"use strict";

require("core-js/modules/es.string.split");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFormattedFileSize = getFormattedFileSize;
exports.getFileType = getFileType;
exports.lookupMimeType = lookupMimeType;
exports.getFileUrl = getFileUrl;
exports.getFileDownloadUrl = getFileDownloadUrl;
exports.getFileThumbnailUrl = getFileThumbnailUrl;
exports.getFilePreviewUrl = getFilePreviewUrl;
exports.sortFileInfos = sortFileInfos;

var _constants = require("../constants");

var _client = require("../client");

var _mimeDb = _interopRequireDefault(require("mime-db"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow
function getFormattedFileSize(file
/*: FileInfo*/
)
/*: string*/
{
  const bytes = file.size;
  const fileSizes = [['TB', 1024 * 1024 * 1024 * 1024], ['GB', 1024 * 1024 * 1024], ['MB', 1024 * 1024], ['KB', 1024]];
  const size = fileSizes.find(unitAndMinBytes => {
    const minBytes = unitAndMinBytes[1];
    return bytes > minBytes;
  });

  if (size) {
    return "".concat(Math.floor(bytes / size[1]), " ").concat(size[0]);
  }

  return "".concat(bytes, " B");
}

function getFileType(file
/*: FileInfo*/
)
/*: string*/
{
  if (!file || !file.extension) {
    return 'other';
  }

  const fileExt = file.extension.toLowerCase();
  const fileTypes = ['image', 'code', 'pdf', 'video', 'audio', 'spreadsheet', 'word', 'presentation', 'patch'];
  return fileTypes.find(fileType => {
    const constForFileTypeExtList = "".concat(fileType, "_types").toUpperCase();
    const fileTypeExts = _constants.Files[constForFileTypeExtList];
    return fileTypeExts.indexOf(fileExt) > -1;
  }) || 'other';
}

let extToMime;

function buildExtToMime() {
  extToMime = {};
  Object.keys(_mimeDb.default).forEach(key => {
    const mime = _mimeDb.default[key];

    if (mime.extensions) {
      mime.extensions.forEach(ext => {
        extToMime[ext] = key;
      });
    }
  });
}

function lookupMimeType(filename
/*: string*/
)
/*: string*/
{
  if (!extToMime) {
    buildExtToMime();
  }

  const ext = filename.split('.').pop().toLowerCase();
  return extToMime[ext] || 'application/octet-stream';
}

function getFileUrl(fileId
/*: string*/
)
/*: string*/
{
  return _client.Client4.getFileRoute(fileId);
}

function getFileDownloadUrl(fileId
/*: string*/
)
/*: string*/
{
  return "".concat(_client.Client4.getFileRoute(fileId), "?download=1");
}

function getFileThumbnailUrl(fileId
/*: string*/
)
/*: string*/
{
  return "".concat(_client.Client4.getFileRoute(fileId), "/thumbnail");
}

function getFilePreviewUrl(fileId
/*: string*/
)
/*: string*/
{
  return "".concat(_client.Client4.getFileRoute(fileId), "/preview");
}

function sortFileInfos(fileInfos
/*: Array<FileInfo>*/
= [], locale
/*: string*/
= _constants.General.DEFAULT_LOCALE)
/*: Array<FileInfo>*/
{
  return fileInfos.sort((a, b) => {
    if (a.create_at !== b.create_at) {
      return a.create_at - b.create_at;
    }

    return a.name.localeCompare(b.name, locale, {
      numeric: true
    });
  });
}