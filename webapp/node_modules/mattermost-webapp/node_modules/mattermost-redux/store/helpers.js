"use strict";

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createReducer = createReducer;
exports.offlineConfig = void 0;

var _redux = require("redux");

var _reduxBatchedActions = require("redux-batched-actions");

var _constants = require("../constants");

var _reducer_registry = _interopRequireDefault(require("./reducer_registry"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
const offlineConfig = {
  effect: (_effect, action) => {
    if (typeof _effect !== 'function') {
      throw new Error('Offline Action: effect must be a function.');
    } else if (!action.meta.offline.commit) {
      throw new Error('Offline Action: commit action must be present.');
    }

    return _effect();
  },
  discard: (error, action, retries) => {
    if (action.meta && action.meta.offline.hasOwnProperty('maxRetry')) {
      return retries >= action.meta.offline.maxRetry;
    }

    return retries > 10;
  }
};
exports.offlineConfig = offlineConfig;

function createReducer(baseState, ...reducers) {
  _reducer_registry.default.setReducers(Object.assign({}, ...reducers));

  const baseReducer = (0, _redux.combineReducers)(_reducer_registry.default.getReducers()); // Root reducer wrapper that listens for reset events.
  // Returns whatever is passed for the data property
  // as the new state.

  function offlineReducer(state = {}, action) {
    if (action.type === _constants.General.OFFLINE_STORE_RESET) {
      return baseReducer(baseState, action);
    }

    return baseReducer(state, action);
  }

  return (0, _reduxBatchedActions.enableBatching)(offlineReducer);
}