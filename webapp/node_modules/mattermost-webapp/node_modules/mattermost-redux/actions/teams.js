"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectTeam = selectTeam;
exports.getMyTeams = getMyTeams;
exports.getMyTeamUnreads = getMyTeamUnreads;
exports.getTeam = getTeam;
exports.getTeamByName = getTeamByName;
exports.getTeams = getTeams;
exports.searchTeams = searchTeams;
exports.createTeam = createTeam;
exports.deleteTeam = deleteTeam;
exports.updateTeam = updateTeam;
exports.patchTeam = patchTeam;
exports.regenerateTeamInviteId = regenerateTeamInviteId;
exports.getMyTeamMembers = getMyTeamMembers;
exports.getTeamMembers = getTeamMembers;
exports.getTeamMember = getTeamMember;
exports.getTeamMembersByIds = getTeamMembersByIds;
exports.getTeamsForUser = getTeamsForUser;
exports.getTeamMembersForUser = getTeamMembersForUser;
exports.getTeamStats = getTeamStats;
exports.addUserToTeamFromInvite = addUserToTeamFromInvite;
exports.addUserToTeam = addUserToTeam;
exports.addUsersToTeam = addUsersToTeam;
exports.removeUserFromTeam = removeUserFromTeam;
exports.updateTeamMemberRoles = updateTeamMemberRoles;
exports.sendEmailInvitesToTeam = sendEmailInvitesToTeam;
exports.sendEmailGuestInvitesToChannels = sendEmailGuestInvitesToChannels;
exports.getTeamInviteInfo = getTeamInviteInfo;
exports.checkIfTeamExists = checkIfTeamExists;
exports.joinTeam = joinTeam;
exports.setTeamIcon = setTeamIcon;
exports.removeTeamIcon = removeTeamIcon;
exports.updateTeamScheme = updateTeamScheme;
exports.updateTeamMemberSchemeRoles = updateTeamMemberSchemeRoles;
exports.invalidateAllEmailInvites = invalidateAllEmailInvites;
exports.membersMinusGroupMembers = membersMinusGroupMembers;

var _reduxBatchedActions = require("redux-batched-actions");

var _client = require("../client");

var _constants = require("../constants");

var _action_types = require("../action_types");

var _event_emitter = _interopRequireDefault(require("../utils/event_emitter"));

var _errors = require("./errors");

var _helpers = require("./helpers");

var _users = require("./users");

var _roles = require("./roles");

var _general = require("../selectors/entities/general");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

async function getProfilesAndStatusesForMembers(userIds, dispatch, getState) {
  const {
    currentUserId,
    profiles,
    statuses
  } = getState().entities.users;
  const profilesToLoad = [];
  const statusesToLoad = [];
  userIds.forEach(userId => {
    if (!profiles[userId] && !profilesToLoad.includes(userId) && userId !== currentUserId) {
      profilesToLoad.push(userId);
    }

    if (!statuses[userId] && !statusesToLoad.includes(userId) && userId !== currentUserId) {
      statusesToLoad.push(userId);
    }
  });
  const requests = [];

  if (profilesToLoad.length) {
    requests.push((0, _users.getProfilesByIds)(profilesToLoad)(dispatch, getState));
  }

  if (statusesToLoad.length) {
    requests.push((0, _users.getStatusesByIds)(statusesToLoad)(dispatch, getState));
  }

  await Promise.all(requests);
}

function selectTeam(team
/*: Team*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.TeamTypes.SELECT_TEAM,
      data: team.id
    }, getState);
    return {
      data: true
    };
  };
}

function getMyTeams()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getMyTeams,
    onRequest: _action_types.TeamTypes.MY_TEAMS_REQUEST,
    onSuccess: [_action_types.TeamTypes.RECEIVED_TEAMS_LIST, _action_types.TeamTypes.MY_TEAMS_SUCCESS],
    onFailure: _action_types.TeamTypes.MY_TEAMS_FAILURE
  });
}

function getMyTeamUnreads()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getMyTeamUnreads,
    onSuccess: _action_types.TeamTypes.RECEIVED_MY_TEAM_UNREADS
  });
}

function getTeam(teamId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getTeam,
    onSuccess: _action_types.TeamTypes.RECEIVED_TEAM,
    params: [teamId]
  });
}

function getTeamByName(teamName
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getTeamByName,
    onSuccess: _action_types.TeamTypes.RECEIVED_TEAM,
    params: [teamName]
  });
}

function getTeams(page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.TEAMS_CHUNK_SIZE, includeTotalCount
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let data;
    dispatch({
      type: _action_types.TeamTypes.GET_TEAMS_REQUEST,
      data
    }, getState);

    try {
      data = await _client.Client4.getTeams(page, perPage, includeTotalCount);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch({
        type: _action_types.TeamTypes.GET_TEAMS_FAILURE,
        data
      }, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const actions = [{
      type: _action_types.TeamTypes.RECEIVED_TEAMS_LIST,
      data: includeTotalCount ? data.teams : data
    }, {
      type: _action_types.TeamTypes.GET_TEAMS_SUCCESS,
      data
    }];

    if (includeTotalCount) {
      actions.push({
        type: _action_types.TeamTypes.RECEIVED_TOTAL_TEAM_COUNT,
        data: data.total_count
      });
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data
    };
  };
}

function searchTeams(term
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.searchTeams,
    onRequest: _action_types.TeamTypes.GET_TEAMS_REQUEST,
    onSuccess: [_action_types.TeamTypes.RECEIVED_TEAMS_LIST, _action_types.TeamTypes.GET_TEAMS_SUCCESS],
    onFailure: _action_types.TeamTypes.GET_TEAMS_FAILURE,
    params: [term]
  });
}

function createTeam(team
/*: Team*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let created;

    try {
      created = await _client.Client4.createTeam(team);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const member = {
      team_id: created.id,
      user_id: getState().entities.users.currentUserId,
      roles: "".concat(_constants.General.TEAM_ADMIN_ROLE, " ").concat(_constants.General.TEAM_USER_ROLE),
      delete_at: 0,
      msg_count: 0,
      mention_count: 0
    };
    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.TeamTypes.CREATED_TEAM,
      data: created
    }, {
      type: _action_types.TeamTypes.RECEIVED_MY_TEAM_MEMBER,
      data: member
    }, {
      type: _action_types.TeamTypes.SELECT_TEAM,
      data: created.id
    }]), getState);
    dispatch((0, _roles.loadRolesIfNeeded)(member.roles.split(' ')));
    return {
      data: created
    };
  };
}

function deleteTeam(teamId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.deleteTeam(teamId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const entities = getState().entities;
    const {
      currentTeamId
    } = entities.teams;
    const actions = [];

    if (teamId === currentTeamId) {
      _event_emitter.default.emit('leave_team');

      actions.push({
        type: _action_types.ChannelTypes.SELECT_CHANNEL,
        data: ''
      });
    }

    actions.push({
      type: _action_types.TeamTypes.RECEIVED_TEAM_DELETED,
      data: {
        id: teamId
      }
    });
    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data: true
    };
  };
}

function updateTeam(team
/*: Team*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.updateTeam,
    onSuccess: _action_types.TeamTypes.UPDATED_TEAM,
    params: [team]
  });
}

function patchTeam(team
/*: Team*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.patchTeam,
    onSuccess: _action_types.TeamTypes.PATCHED_TEAM,
    params: [team]
  });
}

function regenerateTeamInviteId(teamId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.regenerateTeamInviteId,
    onSuccess: _action_types.TeamTypes.REGENERATED_TEAM_INVITE_ID,
    params: [teamId]
  });
}

function getMyTeamMembers()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const getMyTeamMembersFunc = (0, _helpers.bindClientFunc)({
      clientFunc: _client.Client4.getMyTeamMembers,
      onSuccess: _action_types.TeamTypes.RECEIVED_MY_TEAM_MEMBERS
    });
    const teamMembers
    /*: ActionResult*/
    = await getMyTeamMembersFunc(dispatch, getState);

    if (teamMembers.data) {
      const roles = new Set();

      for (const teamMember of teamMembers.data) {
        for (const role of teamMember.roles.split(' ')) {
          roles.add(role);
        }
      }

      if (roles.size > 0) {
        dispatch((0, _roles.loadRolesIfNeeded)([...roles]));
      }
    }

    return teamMembers;
  };
}

function getTeamMembers(teamId
/*: string*/
, page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.TEAMS_CHUNK_SIZE)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getTeamMembers,
    onRequest: _action_types.TeamTypes.GET_TEAM_MEMBERS_REQUEST,
    onSuccess: [_action_types.TeamTypes.RECEIVED_MEMBERS_IN_TEAM, _action_types.TeamTypes.GET_TEAM_MEMBERS_SUCCESS],
    onFailure: _action_types.TeamTypes.GET_TEAM_MEMBERS_FAILURE,
    params: [teamId, page, perPage]
  });
}

function getTeamMember(teamId
/*: string*/
, userId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let member;

    try {
      const memberRequest = _client.Client4.getTeamMember(teamId, userId);

      getProfilesAndStatusesForMembers([userId], dispatch, getState);
      member = await memberRequest;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.TeamTypes.RECEIVED_MEMBERS_IN_TEAM,
      data: [member]
    });
    return {
      data: member
    };
  };
}

function getTeamMembersByIds(teamId
/*: string*/
, userIds
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let members;

    try {
      const membersRequest = _client.Client4.getTeamMembersByIds(teamId, userIds);

      getProfilesAndStatusesForMembers(userIds, dispatch, getState);
      members = await membersRequest;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.TeamTypes.RECEIVED_MEMBERS_IN_TEAM,
      data: members
    });
    return {
      data: members
    };
  };
}

function getTeamsForUser(userId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getTeamsForUser,
    onRequest: _action_types.TeamTypes.GET_TEAMS_REQUEST,
    onSuccess: [_action_types.TeamTypes.RECEIVED_TEAMS_LIST, _action_types.TeamTypes.GET_TEAMS_SUCCESS],
    onFailure: _action_types.TeamTypes.GET_TEAMS_FAILURE,
    params: [userId]
  });
}

function getTeamMembersForUser(userId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getTeamMembersForUser,
    onSuccess: _action_types.TeamTypes.RECEIVED_TEAM_MEMBERS,
    params: [userId]
  });
}

function getTeamStats(teamId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getTeamStats,
    onSuccess: _action_types.TeamTypes.RECEIVED_TEAM_STATS,
    params: [teamId]
  });
}

function addUserToTeamFromInvite(token
/*: string*/
, inviteId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.addToTeamFromInvite,
    onRequest: _action_types.TeamTypes.ADD_TO_TEAM_FROM_INVITE_REQUEST,
    onSuccess: _action_types.TeamTypes.ADD_TO_TEAM_FROM_INVITE_SUCCESS,
    onFailure: _action_types.TeamTypes.ADD_TO_TEAM_FROM_INVITE_FAILURE,
    params: [token, inviteId]
  });
}

function addUserToTeam(teamId
/*: string*/
, userId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let member;

    try {
      member = await _client.Client4.addToTeam(teamId, userId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.RECEIVED_PROFILE_IN_TEAM,
      data: {
        id: teamId,
        user_id: userId
      }
    }, {
      type: _action_types.TeamTypes.RECEIVED_MEMBER_IN_TEAM,
      data: member
    }]), getState);
    return {
      data: member
    };
  };
}

function addUsersToTeam(teamId
/*: string*/
, userIds
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let members;

    try {
      members = await _client.Client4.addUsersToTeam(teamId, userIds);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const profiles = [];
    members.forEach(m => profiles.push({
      id: m.user_id
    }));
    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_TEAM,
      data: profiles,
      id: teamId
    }, {
      type: _action_types.TeamTypes.RECEIVED_MEMBERS_IN_TEAM,
      data: members
    }]), getState);
    return {
      data: members
    };
  };
}

function removeUserFromTeam(teamId
/*: string*/
, userId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.removeFromTeam(teamId, userId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const member = {
      team_id: teamId,
      user_id: userId
    };
    const actions = [{
      type: _action_types.UserTypes.RECEIVED_PROFILE_NOT_IN_TEAM,
      data: {
        id: teamId,
        user_id: userId
      }
    }, {
      type: _action_types.TeamTypes.REMOVE_MEMBER_FROM_TEAM,
      data: member
    }];
    const state = getState();
    const {
      currentUserId
    } = state.entities.users;

    if (currentUserId === userId) {
      const {
        channels,
        myMembers
      } = state.entities.channels;

      for (const channelMember of Object.values(myMembers)) {
        // https://github.com/facebook/flow/issues/2221
        // $FlowFixMe - Object.values currently does not have good flow support
        const channel = channels[channelMember.channel_id];

        if (channel && channel.team_id === teamId) {
          actions.push({
            type: _action_types.ChannelTypes.LEAVE_CHANNEL,
            data: channel
          });
        }
      }
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data: true
    };
  };
}

function updateTeamMemberRoles(teamId
/*: string*/
, userId
/*: string*/
, roles
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.updateTeamMemberRoles(teamId, userId, roles);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const membersInTeam = getState().entities.teams.membersInTeam[teamId];

    if (membersInTeam && membersInTeam[userId]) {
      dispatch({
        type: _action_types.TeamTypes.RECEIVED_MEMBER_IN_TEAM,
        data: _objectSpread({}, membersInTeam[userId], {
          roles
        })
      });
    }

    return {
      data: true
    };
  };
}

function sendEmailInvitesToTeam(teamId
/*: string*/
, emails
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.sendEmailInvitesToTeam,
    params: [teamId, emails]
  });
}

function sendEmailGuestInvitesToChannels(teamId
/*: string*/
, channelIds
/*: Array<string>*/
, emails
/*: Array<string>*/
, message
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.sendEmailGuestInvitesToChannels,
    params: [teamId, channelIds, emails, message]
  });
}

function getTeamInviteInfo(inviteId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getTeamInviteInfo,
    onRequest: _action_types.TeamTypes.TEAM_INVITE_INFO_REQUEST,
    onSuccess: _action_types.TeamTypes.TEAM_INVITE_INFO_SUCCESS,
    onFailure: _action_types.TeamTypes.TEAM_INVITE_INFO_FAILURE,
    params: [inviteId]
  });
}

function checkIfTeamExists(teamName
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let data;

    try {
      data = await _client.Client4.checkIfTeamExists(teamName);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    return {
      data: data.exists
    };
  };
}

function joinTeam(inviteId
/*: string*/
, teamId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.TeamTypes.JOIN_TEAM_REQUEST,
      data: null
    }, getState);
    const state = getState();

    try {
      if ((0, _general.isCompatibleWithJoinViewTeamPermissions)(state)) {
        const currentUserId = state.entities.users.currentUserId;
        await _client.Client4.addToTeam(teamId, currentUserId);
      } else {
        await _client.Client4.joinTeam(inviteId);
      }
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.TeamTypes.JOIN_TEAM_FAILURE,
        error
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    getMyTeamUnreads()(dispatch, getState);
    await Promise.all([getTeam(teamId)(dispatch, getState), getMyTeamMembers()(dispatch, getState)]);
    dispatch({
      type: _action_types.TeamTypes.JOIN_TEAM_SUCCESS,
      data: null
    }, getState);
    return {
      data: true
    };
  };
}

function setTeamIcon(teamId
/*: string*/
, imageData
/*: File*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.setTeamIcon,
    params: [teamId, imageData]
  });
}

function removeTeamIcon(teamId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.removeTeamIcon,
    params: [teamId]
  });
}

function updateTeamScheme(teamId
/*: string*/
, schemeId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: async () => {
      await _client.Client4.updateTeamScheme(teamId, schemeId);
      return {
        teamId,
        schemeId
      };
    },
    onSuccess: _action_types.TeamTypes.UPDATED_TEAM_SCHEME
  });
}

function updateTeamMemberSchemeRoles(teamId
/*: string*/
, userId
/*: string*/
, isSchemeUser
/*: boolean*/
, isSchemeAdmin
/*: boolean*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: async () => {
      await _client.Client4.updateTeamMemberSchemeRoles(teamId, userId, isSchemeUser, isSchemeAdmin);
      return {
        teamId,
        userId,
        isSchemeUser,
        isSchemeAdmin
      };
    },
    onSuccess: _action_types.TeamTypes.UPDATED_TEAM_MEMBER_SCHEME_ROLES
  });
}

function invalidateAllEmailInvites()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.invalidateAllEmailInvites
  });
}

function membersMinusGroupMembers(teamID
/*: string*/
, groupIDs
/*: Array<string>*/
, page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.teamMembersMinusGroupMembers,
    onSuccess: _action_types.TeamTypes.RECEIVED_TEAM_MEMBERS_MINUS_GROUP_MEMBERS,
    params: [teamID, groupIDs, page, perPage]
  });
}