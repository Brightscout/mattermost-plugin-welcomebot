"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/es.string.search");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveAppPropsRequest = saveAppPropsRequest;
exports.saveAppProps = saveAppProps;
exports.selectSearchText = selectSearchText;
exports.updateSearchText = updateSearchText;
exports.searchBarTextSave = searchBarTextSave;
exports.invalidateSearchText = invalidateSearchText;
exports.requestSearch = requestSearch;
exports.receiveSearch = receiveSearch;
exports.receiveSearchEnd = receiveSearchEnd;
exports.errorSearching = errorSearching;
exports.receiveCategorySearch = receiveCategorySearch;
exports.clearSearchResults = clearSearchResults;
exports.requestSearchById = requestSearchById;
exports.receiveSearchById = receiveSearchById;
exports.errorSearchById = errorSearchById;
exports.searchScrollPosition = searchScrollPosition;
exports.searchPriorLocation = searchPriorLocation;
exports.searchGfycat = searchGfycat;
exports.searchCategory = searchCategory;
exports.shouldSearch = shouldSearch;
exports.searchIfNeeded = searchIfNeeded;
exports.searchIfNeededInitial = searchIfNeededInitial;
exports.shouldSearchInitial = shouldSearchInitial;
exports.searchById = searchById;
exports.shouldSearchById = shouldSearchById;
exports.searchByIdIfNeeded = searchByIdIfNeeded;
exports.saveSearchScrollPosition = saveSearchScrollPosition;
exports.saveSearchPriorLocation = saveSearchPriorLocation;
exports.searchTextUpdate = searchTextUpdate;
exports.saveSearchBarText = saveSearchBarText;
exports.categoriesListRequest = categoriesListRequest;
exports.categoriesListReceived = categoriesListReceived;
exports.categoriesListFailure = categoriesListFailure;
exports.requestCategoriesList = requestCategoriesList;
exports.requestCategoriesListIfNeeded = requestCategoriesListIfNeeded;
exports.shouldRequestCategoriesList = shouldRequestCategoriesList;
exports.cacheRequest = cacheRequest;
exports.cacheGifs = cacheGifs;
exports.cacheGifsRequest = cacheGifsRequest;

var _action_types = require("../action_types");

var _client = require("../client");

var _gfycat_sdk = _interopRequireDefault(require("../utils/gfycat_sdk"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// APP PROPS
function saveAppPropsRequest(props) {
  return {
    type: _action_types.GifTypes.SAVE_APP_PROPS,
    props
  };
}

function saveAppProps(appProps) {
  return (dispatch, getState) => {
    const {
      GfycatApiKey,
      GfycatApiSecret
    } = getState().entities.general.config;
    (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).authenticate();
    dispatch(saveAppPropsRequest(appProps));
  };
} // SEARCH


function selectSearchText(searchText) {
  return {
    type: _action_types.GifTypes.SELECT_SEARCH_TEXT,
    searchText
  };
}

function updateSearchText(searchText) {
  return {
    type: _action_types.GifTypes.UPDATE_SEARCH_TEXT,
    searchText
  };
}

function searchBarTextSave(searchBarText) {
  return {
    type: _action_types.GifTypes.SAVE_SEARCH_BAR_TEXT,
    searchBarText
  };
}

function invalidateSearchText(searchText) {
  return {
    type: _action_types.GifTypes.INVALIDATE_SEARCH_TEXT,
    searchText
  };
}

function requestSearch(searchText) {
  return {
    type: _action_types.GifTypes.REQUEST_SEARCH,
    searchText
  };
}

function receiveSearch({
  searchText,
  count,
  start,
  json
}) {
  return _objectSpread({
    type: _action_types.GifTypes.RECEIVE_SEARCH,
    searchText
  }, json, {
    count,
    start,
    currentPage: start / count,
    receivedAt: Date.now()
  });
}

function receiveSearchEnd(searchText) {
  return {
    type: _action_types.GifTypes.RECEIVE_SEARCH_END,
    searchText
  };
}

function errorSearching(err, searchText) {
  return {
    type: _action_types.GifTypes.SEARCH_FAILURE,
    searchText,
    err
  };
}

function receiveCategorySearch({
  tagName,
  json
}) {
  return _objectSpread({
    type: _action_types.GifTypes.RECEIVE_CATEGORY_SEARCH,
    searchText: tagName
  }, json, {
    receiveAt: Date.now()
  });
}

function clearSearchResults() {
  return {
    type: _action_types.GifTypes.CLEAR_SEARCH_RESULTS
  };
}

function requestSearchById(gfyId) {
  return {
    type: _action_types.GifTypes.SEARCH_BY_ID_REQUEST,
    payload: {
      gfyId
    }
  };
}

function receiveSearchById(gfyId, gfyItem) {
  return {
    type: _action_types.GifTypes.SEARCH_BY_ID_SUCCESS,
    payload: {
      gfyId,
      gfyItem
    }
  };
}

function errorSearchById(err, gfyId) {
  return {
    type: _action_types.GifTypes.SEARCH_BY_ID_FAILURE,
    err,
    gfyId
  };
}

function searchScrollPosition(scrollPosition) {
  return {
    type: _action_types.GifTypes.SAVE_SEARCH_SCROLL_POSITION,
    scrollPosition
  };
}

function searchPriorLocation(priorLocation) {
  return {
    type: _action_types.GifTypes.SAVE_SEARCH_PRIOR_LOCATION,
    priorLocation
  };
}

function searchGfycat({
  searchText,
  count = 30,
  startIndex = 0
}) {
  var start = startIndex;
  return (dispatch, getState) => {
    const {
      GfycatApiKey,
      GfycatApiSecret
    } = getState().entities.general.config;
    const {
      resultsByTerm
    } = getState().entities.gifs.search;

    if (resultsByTerm[searchText]) {
      start = resultsByTerm[searchText].start + count;
    }

    dispatch(requestSearch(searchText, count, start));
    (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).authenticate();
    return (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).search({
      search_text: searchText,
      count,
      start
    }).then(json => {
      if (json.errorMessage) {
        // There was no results before
        if (resultsByTerm[searchText].items) {
          dispatch(receiveSearchEnd(searchText));
        } else {
          dispatch(errorSearching(json, searchText));
        }
      } else {
        dispatch(updateSearchText(searchText));
        dispatch(cacheGifsRequest(json.gfycats));
        dispatch(receiveSearch({
          searchText,
          count,
          start,
          json
        }));
        const context = getState().entities.gifs.categories.tagsDict[searchText] ? 'category' : 'search';

        _client.Client4.trackEvent('gfycat', 'views', {
          context,
          count: json.gfycats.length,
          keyword: searchText
        });
      }
    }).catch(err => dispatch(errorSearching(err, searchText)));
  };
}

function searchCategory({
  tagName = '',
  gfyCount = 30,
  cursorPos
}) {
  var cursor = cursorPos;
  return (dispatch, getState) => {
    const {
      GfycatApiKey,
      GfycatApiSecret
    } = getState().entities.general.config;
    const {
      resultsByTerm
    } = getState().entities.gifs.search;

    if (resultsByTerm[tagName]) {
      cursor = resultsByTerm[tagName].cursor;
    }

    dispatch(requestSearch(tagName));
    return (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).getTrendingCategories({
      tagName,
      gfyCount,
      cursor
    }).then(json => {
      if (json.errorMessage) {
        if (resultsByTerm[tagName].gfycats) {
          dispatch(receiveSearchEnd(tagName));
        } else {
          dispatch(errorSearching(json, tagName));
        }
      } else {
        dispatch(updateSearchText(tagName));
        dispatch(cacheGifsRequest(json.gfycats));
        dispatch(receiveCategorySearch({
          tagName,
          json
        }));

        _client.Client4.trackEvent('gfycat', 'views', {
          context: 'category',
          count: json.gfycats.length,
          keyword: tagName
        }); // preload categories list


        if (tagName === 'trending') {
          dispatch(requestCategoriesListIfNeeded());
        }
      }
    }).catch(err => dispatch(errorSearching(err, tagName)));
  };
}

function shouldSearch(state, searchText) {
  const resultsByTerm = state.search.resultsByTerm[searchText];

  if (!resultsByTerm) {
    return true;
  } else if (resultsByTerm.isFetching) {
    return false;
  } else if (resultsByTerm.moreRemaining) {
    return true;
  }

  return resultsByTerm.didInvalidate;
}

function searchIfNeeded(searchText) {
  return (dispatch, getState) => {
    if (shouldSearch(getState(), searchText)) {
      if (searchText.toLowerCase() === 'trending') {
        return dispatch(searchCategory({
          tagName: searchText
        }));
      }

      return dispatch(searchGfycat({
        searchText
      }));
    }

    return Promise.resolve();
  };
}

function searchIfNeededInitial(searchText) {
  return (dispatch, getState) => {
    dispatch(updateSearchText(searchText));

    if (shouldSearchInitial(getState(), searchText)) {
      if (searchText.toLowerCase() === 'trending') {
        return dispatch(searchCategory({
          tagName: searchText
        }));
      }

      return dispatch(searchGfycat({
        searchText
      }));
    }

    return Promise.resolve();
  };
}

function shouldSearchInitial(state, searchText) {
  const resultsByTerm = state.entities.gifs.search.resultsByTerm[searchText];

  if (!resultsByTerm) {
    return true;
  } else if (resultsByTerm.isFetching) {
    return false;
  }

  return false;
}

function searchById(gfyId) {
  return (dispatch, getState) => {
    const {
      GfycatApiKey,
      GfycatApiSecret
    } = getState().entities.general.config;
    dispatch(requestSearchById(gfyId));
    return (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).searchById({
      id: gfyId
    }).then(response => {
      dispatch(receiveSearchById(gfyId, response.gfyItem));
      dispatch(cacheGifsRequest([response.gfyItem]));
    }).catch(err => dispatch(errorSearchById(err, gfyId)));
  };
}

function shouldSearchById(state, gfyId) {
  return !state.cache.gifs[gfyId];
}

function searchByIdIfNeeded(gfyId) {
  return (dispatch, getState) => {
    if (shouldSearchById(getState(), gfyId)) {
      return dispatch(searchById(gfyId));
    }

    return Promise.resolve(getState().cache.gifs[gfyId]);
  };
}

function saveSearchScrollPosition(scrollPosition) {
  return dispatch => {
    dispatch(searchScrollPosition(scrollPosition));
  };
}

function saveSearchPriorLocation(priorLocation) {
  return dispatch => {
    dispatch(searchPriorLocation(priorLocation));
  };
}

function searchTextUpdate(searchText) {
  return dispatch => {
    dispatch(updateSearchText(searchText));
  };
}

function saveSearchBarText(searchBarText) {
  return dispatch => {
    dispatch(searchBarTextSave(searchBarText));
  };
} // CATEGORIES


function categoriesListRequest() {
  return {
    type: _action_types.GifTypes.REQUEST_CATEGORIES_LIST
  };
}

function categoriesListReceived(json) {
  return _objectSpread({
    type: _action_types.GifTypes.CATEGORIES_LIST_RECEIVED
  }, json);
}

function categoriesListFailure(err) {
  return {
    type: _action_types.GifTypes.CATEGORIES_LIST_FAILURE,
    err
  };
}

function requestCategoriesList({
  count = 60
} = {}) {
  return (dispatch, getState) => {
    const {
      GfycatApiKey,
      GfycatApiSecret
    } = getState().entities.general.config;
    const state = getState().entities.gifs.categories;

    if (!shouldRequestCategoriesList(state)) {
      return Promise.resolve();
    }

    dispatch(categoriesListRequest());
    const {
      cursor
    } = state;

    const options = _objectSpread({}, count && {
      count
    }, {}, cursor && {
      cursor
    });

    return (0, _gfycat_sdk.default)(GfycatApiKey, GfycatApiSecret).getCategories(options).then(json => {
      const newGfycats = json.tags.reduce((gfycats, tag) => {
        if (tag.gfycats[0] && tag.gfycats[0].width) {
          return [...gfycats, ...tag.gfycats];
        }

        return gfycats;
      }, []);
      dispatch(cacheGifsRequest(newGfycats));
      dispatch(categoriesListReceived(json));
    }).catch(err => {
      dispatch(categoriesListFailure(err));
    });
  };
}

function requestCategoriesListIfNeeded({
  count
} = {}) {
  return (dispatch, getState) => {
    const state = getState().entities.gifs.categories;

    if (state.tagsList && state.tagsList.length) {
      return Promise.resolve();
    }

    return dispatch(requestCategoriesList({
      count
    }));
  };
}

function shouldRequestCategoriesList(state) {
  const {
    hasMore,
    isFetching,
    tagsList
  } = state;

  if (!tagsList || !tagsList.length) {
    return true;
  } else if (isFetching) {
    return false;
  } else if (hasMore) {
    return true;
  }

  return false;
} // CACHE


function cacheRequest() {
  return {
    type: _action_types.GifTypes.CACHE_REQUEST,
    payload: {
      updating: true
    }
  };
}

function cacheGifs(gifs) {
  return {
    type: _action_types.GifTypes.CACHE_GIFS,
    gifs
  };
}

function cacheGifsRequest(gifs) {
  return dispatch => {
    dispatch(cacheRequest());
    dispatch(cacheGifs(gifs));
  };
}