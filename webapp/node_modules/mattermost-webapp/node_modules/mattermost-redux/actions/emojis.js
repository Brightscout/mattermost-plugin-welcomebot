"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setSystemEmojis = setSystemEmojis;
exports.createCustomEmoji = createCustomEmoji;
exports.getCustomEmoji = getCustomEmoji;
exports.getCustomEmojiByName = getCustomEmojiByName;
exports.getCustomEmojisByName = getCustomEmojisByName;
exports.getCustomEmojisInText = getCustomEmojisInText;
exports.getCustomEmojis = getCustomEmojis;
exports.loadProfilesForCustomEmojis = loadProfilesForCustomEmojis;
exports.getAllCustomEmojis = getAllCustomEmojis;
exports.deleteCustomEmoji = deleteCustomEmoji;
exports.searchCustomEmojis = searchCustomEmojis;
exports.autocompleteCustomEmojis = autocompleteCustomEmojis;
exports.systemEmojis = void 0;

var _client = require("../client");

var _action_types = require("../action_types");

var _constants = require("../constants");

var _users = require("./users");

var _emojis = require("../selectors/entities/emojis");

var _emoji_utils = require("../utils/emoji_utils");

var _errors = require("./errors");

var _helpers = require("./helpers");

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow
let systemEmojis
/*: Map<string, Object>*/
= new Map();
exports.systemEmojis = systemEmojis;

function setSystemEmojis(emojis
/*: Map<string, Object>*/
) {
  exports.systemEmojis = systemEmojis = emojis;
}

function createCustomEmoji(emoji
/*: Object*/
, image
/*: Object*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.createCustomEmoji,
    onSuccess: _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJI,
    params: [emoji, image]
  });
}

function getCustomEmoji(emojiId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getCustomEmoji,
    onSuccess: _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJI,
    params: [emojiId]
  });
}

function getCustomEmojiByName(name
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let data;

    try {
      data = await _client.Client4.getCustomEmojiByName(name);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);

      if (error.status_code === 404) {
        dispatch({
          type: _action_types.EmojiTypes.CUSTOM_EMOJI_DOES_NOT_EXIST,
          data: name
        });
      } else {
        dispatch((0, _errors.logError)(error));
      }

      return {
        error
      };
    }

    dispatch({
      type: _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJI,
      data
    });
    return {
      data
    };
  };
}

function getCustomEmojisByName(names
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    if (!names || names.length === 0) {
      return {
        data: true
      };
    }

    const promises = [];
    names.forEach(name => promises.push(getCustomEmojiByName(name)(dispatch, getState)));
    await Promise.all(promises);
    return {
      data: true
    };
  };
}

function getCustomEmojisInText(text
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    if (!text) {
      return {
        data: true
      };
    }

    const state = getState();
    const nonExistentEmoji = state.entities.emojis.nonExistentEmoji;
    const customEmojisByName = (0, _emojis.getCustomEmojisByName)(state);
    const emojisToLoad = (0, _emoji_utils.parseNeededCustomEmojisFromText)(text, systemEmojis, customEmojisByName, nonExistentEmoji);
    return getCustomEmojisByName(Array.from(emojisToLoad))(dispatch, getState);
  };
}

function getCustomEmojis(page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PAGE_SIZE_DEFAULT, sort
/*: string*/
= _constants.Emoji.SORT_BY_NAME, loadUsers
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let data;

    try {
      data = await _client.Client4.getCustomEmojis(page, perPage, sort);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    if (loadUsers) {
      dispatch(loadProfilesForCustomEmojis(data));
    }

    dispatch({
      type: _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJIS,
      data
    });
    return {
      data
    };
  };
}

function loadProfilesForCustomEmojis(emojis
/*: Array<Object>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const usersToLoad = {};
    emojis.forEach((emoji
    /*: Object*/
    ) => {
      if (!getState().entities.users.profiles[emoji.creator_id]) {
        usersToLoad[emoji.creator_id] = true;
      }
    });
    const userIds = Object.keys(usersToLoad);

    if (userIds.length > 0) {
      await dispatch((0, _users.getProfilesByIds)(userIds));
    }

    return {
      data: true
    };
  };
}

function getAllCustomEmojis(perPage
/*: number*/
= _constants.General.PAGE_SIZE_MAXIMUM)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.EmojiTypes.CLEAR_CUSTOM_EMOJIS,
      data: null
    });
    let hasMore = true;
    let page = 0;
    const allEmojis = [];

    do {
      try {
        let emojis = [];
        emojis = await _client.Client4.getCustomEmojis(page, perPage, _constants.Emoji.SORT_BY_NAME); // eslint-disable-line no-await-in-loop

        if (emojis.length < perPage) {
          hasMore = false;
        } else {
          page += 1;
        }

        allEmojis.push(...emojis);
      } catch (error) {
        (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
        dispatch((0, _errors.logError)(error));
        return {
          error: true
        };
      }
    } while (hasMore);

    dispatch({
      type: _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJIS,
      data: allEmojis
    });
    return {
      data: true
    };
  };
}

function deleteCustomEmoji(emojiId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.deleteCustomEmoji(emojiId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.EmojiTypes.DELETED_CUSTOM_EMOJI,
      data: {
        id: emojiId
      }
    });
    return {
      data: true
    };
  };
}

function searchCustomEmojis(term
/*: string*/
, options
/*: Object*/
= {}, loadUsers
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let data;

    try {
      data = await _client.Client4.searchCustomEmoji(term, options);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    if (loadUsers) {
      dispatch(loadProfilesForCustomEmojis(data));
    }

    dispatch({
      type: _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJIS,
      data
    });
    return {
      data
    };
  };
}

function autocompleteCustomEmojis(name
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let data;

    try {
      data = await _client.Client4.autocompleteCustomEmoji(name);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJIS,
      data
    });
    return {
      data
    };
  };
}