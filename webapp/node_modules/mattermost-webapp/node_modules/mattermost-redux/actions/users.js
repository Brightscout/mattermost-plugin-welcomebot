/*:: import type {ActionFunc, ActionResult, DispatchFunc, GetStateFunc} from 'types/actions';*/

/*:: import type {UserProfile} from 'types/users';*/

/*:: import type {TeamMembership} from 'types/teams';*/
"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkMfa = checkMfa;
exports.generateMfaSecret = generateMfaSecret;
exports.createUser = createUser;
exports.login = login;
exports.loginById = loginById;
exports.loadMe = loadMe;
exports.logout = logout;
exports.getTotalUsersStats = getTotalUsersStats;
exports.getProfiles = getProfiles;
exports.getMissingProfilesByIds = getMissingProfilesByIds;
exports.getMissingProfilesByUsernames = getMissingProfilesByUsernames;
exports.getProfilesByIds = getProfilesByIds;
exports.getProfilesByUsernames = getProfilesByUsernames;
exports.getProfilesInTeam = getProfilesInTeam;
exports.getProfilesNotInTeam = getProfilesNotInTeam;
exports.getProfilesWithoutTeam = getProfilesWithoutTeam;
exports.getProfilesInChannel = getProfilesInChannel;
exports.getProfilesInGroupChannels = getProfilesInGroupChannels;
exports.getProfilesNotInChannel = getProfilesNotInChannel;
exports.getMe = getMe;
exports.updateMyTermsOfServiceStatus = updateMyTermsOfServiceStatus;
exports.getTermsOfService = getTermsOfService;
exports.promoteGuestToUser = promoteGuestToUser;
exports.demoteUserToGuest = demoteUserToGuest;
exports.createTermsOfService = createTermsOfService;
exports.getUser = getUser;
exports.getUserByUsername = getUserByUsername;
exports.getUserByEmail = getUserByEmail;
exports.getStatusesByIdsBatchedDebounced = getStatusesByIdsBatchedDebounced;
exports.getStatusesByIds = getStatusesByIds;
exports.getStatus = getStatus;
exports.setStatus = setStatus;
exports.getSessions = getSessions;
exports.revokeSession = revokeSession;
exports.revokeAllSessionsForUser = revokeAllSessionsForUser;
exports.revokeSessionsForAllUsers = revokeSessionsForAllUsers;
exports.loadProfilesForDirect = loadProfilesForDirect;
exports.getUserAudits = getUserAudits;
exports.autocompleteUsers = autocompleteUsers;
exports.searchProfiles = searchProfiles;
exports.startPeriodicStatusUpdates = startPeriodicStatusUpdates;
exports.stopPeriodicStatusUpdates = stopPeriodicStatusUpdates;
exports.updateMe = updateMe;
exports.patchUser = patchUser;
exports.updateUserRoles = updateUserRoles;
exports.updateUserMfa = updateUserMfa;
exports.updateUserPassword = updateUserPassword;
exports.updateUserActive = updateUserActive;
exports.verifyUserEmail = verifyUserEmail;
exports.sendVerificationEmail = sendVerificationEmail;
exports.resetUserPassword = resetUserPassword;
exports.sendPasswordResetEmail = sendPasswordResetEmail;
exports.setDefaultProfileImage = setDefaultProfileImage;
exports.uploadProfileImage = uploadProfileImage;
exports.switchEmailToOAuth = switchEmailToOAuth;
exports.switchOAuthToEmail = switchOAuthToEmail;
exports.switchEmailToLdap = switchEmailToLdap;
exports.switchLdapToEmail = switchLdapToEmail;
exports.createUserAccessToken = createUserAccessToken;
exports.getUserAccessToken = getUserAccessToken;
exports.getUserAccessTokens = getUserAccessTokens;
exports.getUserAccessTokensForUser = getUserAccessTokensForUser;
exports.revokeUserAccessToken = revokeUserAccessToken;
exports.disableUserAccessToken = disableUserAccessToken;
exports.enableUserAccessToken = enableUserAccessToken;
exports.clearUserAccessTokens = clearUserAccessTokens;
exports.checkForModifiedUsers = checkForModifiedUsers;
exports.default = void 0;

var _reduxBatchedActions = require("redux-batched-actions");

var _client = require("../client");

var _constants = require("../constants");

var _action_types = require("../action_types");

var _emojis = require("./emojis");

var _general = require("./general");

var _teams = require("./teams");

var _roles = require("./roles");

var _channel_utils = require("../utils/channel_utils");

var _user_utils = require("../utils/user_utils");

var _helpers = require("../utils/helpers");

var _errors = require("./errors");

var _helpers2 = require("./helpers");

var _preferences = require("./preferences");

var _general2 = require("../selectors/entities/general");

var _users = require("../selectors/entities/users");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function checkMfa(loginId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.UserTypes.CHECK_MFA_REQUEST,
      data: null
    }, getState);

    try {
      const data = await _client.Client4.checkUserMfa(loginId);
      dispatch({
        type: _action_types.UserTypes.CHECK_MFA_SUCCESS,
        data: null
      }, getState);
      return {
        data: data.mfa_required
      };
    } catch (error) {
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.UserTypes.CHECK_MFA_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }
  };
}

function generateMfaSecret(userId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.generateMfaSecret,
    params: [userId]
  });
}

function createUser(user
/*: UserProfile*/
, token
/*: string*/
, inviteId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let created = null;

    try {
      created = await _client.Client4.createUser(user, token, inviteId);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const profiles
    /*: { [userId: string]: UserProfile }*/
    = {
      [created.id]: created
    };
    dispatch({
      type: _action_types.UserTypes.RECEIVED_PROFILES,
      data: profiles
    });
    return {
      data: created
    };
  };
}

function login(loginId
/*: string*/
, password
/*: string*/
, mfaToken
/*: string*/
= '', ldapOnly
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.UserTypes.LOGIN_REQUEST,
      data: null
    }, getState);
    const deviceId = getState().entities.general.deviceToken;
    let data = null;

    try {
      data = await _client.Client4.login(loginId, password, mfaToken, deviceId, ldapOnly);
    } catch (error) {
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.UserTypes.LOGIN_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    return completeLogin(data)(dispatch, getState);
  };
}

function loginById(id
/*: string*/
, password
/*: string*/
, mfaToken
/*: string*/
= '')
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.UserTypes.LOGIN_REQUEST,
      data: null
    }, getState);
    const deviceId = getState().entities.general.deviceToken;
    let data = null;

    try {
      data = await _client.Client4.loginById(id, password, mfaToken, deviceId);
    } catch (error) {
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.UserTypes.LOGIN_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    return completeLogin(data)(dispatch, getState);
  };
}

function completeLogin(data
/*: UserProfile*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.UserTypes.RECEIVED_ME,
      data
    });

    _client.Client4.setUserId(data.id);

    _client.Client4.setUserRoles(data.roles);

    let teamMembers = null;

    try {
      const membersRequest
      /*: Promise<Array<TeamMembership>>*/
      = _client.Client4.getMyTeamMembers();

      const unreadsRequest = _client.Client4.getMyTeamUnreads();

      teamMembers = await membersRequest;
      const teamUnreads = await unreadsRequest;

      if (teamUnreads) {
        for (const u of teamUnreads) {
          const index = teamMembers.findIndex(m => m.team_id === u.team_id);
          const member = teamMembers[index];
          member.mention_count = u.mention_count;
          member.msg_count = u.msg_count;
        }
      }
    } catch (error) {
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.UserTypes.LOGIN_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    const promises = [dispatch((0, _preferences.getMyPreferences)()), dispatch((0, _teams.getMyTeams)()), dispatch((0, _general.getClientConfig)())];

    const serverVersion = _client.Client4.getServerVersion();

    dispatch((0, _general.setServerVersion)(serverVersion));

    if (!(0, _helpers.isMinimumServerVersion)(serverVersion, 4, 7) && (0, _general2.getConfig)(getState()).EnableCustomEmoji === 'true') {
      dispatch((0, _emojis.getAllCustomEmojis)());
    }

    try {
      await Promise.all(promises);
    } catch (error) {
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.UserTypes.LOGIN_FAILURE,
        error
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.TeamTypes.RECEIVED_MY_TEAM_MEMBERS,
      data: teamMembers
    }, {
      type: _action_types.UserTypes.LOGIN_SUCCESS
    }]));
    const roles = new Set();

    for (const teamMember of teamMembers) {
      for (const role of teamMember.roles.split(' ')) {
        roles.add(role);
      }

      for (const role of data.roles.split(' ')) {
        roles.add(role);
      }
    }

    if (roles.size > 0) {
      dispatch((0, _roles.loadRolesIfNeeded)(roles));
    }

    return {
      data: true
    };
  };
}

function loadMe()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const config = (0, _general2.getConfig)(state);
    const deviceId = state.entities.general.deviceToken;

    if (deviceId) {
      _client.Client4.attachDevice(deviceId);
    }

    const promises = [dispatch(getMe()), dispatch((0, _preferences.getMyPreferences)()), dispatch((0, _teams.getMyTeams)()), dispatch((0, _teams.getMyTeamMembers)()), dispatch((0, _teams.getMyTeamUnreads)())]; // Sometimes the server version is set in one or the other

    const serverVersion = _client.Client4.getServerVersion() || getState().entities.general.serverVersion;
    dispatch((0, _general.setServerVersion)(serverVersion));

    if (!(0, _helpers.isMinimumServerVersion)(serverVersion, 4, 7) && config.EnableCustomEmoji === 'true') {
      dispatch((0, _emojis.getAllCustomEmojis)());
    }

    await Promise.all(promises);
    const {
      currentUserId
    } = getState().entities.users;
    const user = getState().entities.users.profiles[currentUserId];

    if (currentUserId) {
      _client.Client4.setUserId(currentUserId);
    }

    if (user) {
      _client.Client4.setUserRoles(user.roles);
    }

    return {
      data: true
    };
  };
}

function logout()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.UserTypes.LOGOUT_REQUEST,
      data: null
    }, getState);

    try {
      await _client.Client4.logout();
    } catch (error) {// nothing to do here
    }

    dispatch({
      type: _action_types.UserTypes.LOGOUT_SUCCESS,
      data: null
    }, getState);
    return {
      data: true
    };
  };
}

function getTotalUsersStats()
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getTotalUsersStats,
    onSuccess: _action_types.UserTypes.RECEIVED_USER_STATS
  });
}

function getProfiles(page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE, options
/*: Object*/
= {})
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    let profiles = null;

    try {
      profiles = await _client.Client4.getProfiles(page, perPage, options);
      (0, _user_utils.removeUserFromList)(currentUserId, profiles);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: profiles
    });
    return {
      data: profiles
    };
  };
}

function getMissingProfilesByIds(userIds
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      profiles
    } = getState().entities.users;
    const missingIds = [];
    userIds.forEach(id => {
      if (!profiles[id]) {
        missingIds.push(id);
      }
    });

    if (missingIds.length > 0) {
      getStatusesByIds(missingIds)(dispatch, getState);
      return getProfilesByIds(missingIds)(dispatch, getState);
    }

    return {
      data: []
    };
  };
}

function getMissingProfilesByUsernames(usernames
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      profiles
    } = getState().entities.users;
    const usernameProfiles = Object.values(profiles).reduce((acc, profile
    /*: any*/
    ) => {
      acc[profile.username] = profile;
      return acc;
    }, {});
    const missingUsernames = [];
    usernames.forEach(username => {
      if (!usernameProfiles[username]) {
        missingUsernames.push(username);
      }
    });

    if (missingUsernames.length > 0) {
      return getProfilesByUsernames(missingUsernames)(dispatch, getState);
    }

    return {
      data: []
    };
  };
}

function getProfilesByIds(userIds
/*: Array<string>*/
, options
/*: Object*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    let profiles = null;

    try {
      profiles = await _client.Client4.getProfilesByIds(userIds, options);
      (0, _user_utils.removeUserFromList)(currentUserId, profiles);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: profiles
    });
    return {
      data: profiles
    };
  };
}

function getProfilesByUsernames(usernames
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    let profiles = null;

    try {
      profiles = await _client.Client4.getProfilesByUsernames(usernames);
      (0, _user_utils.removeUserFromList)(currentUserId, profiles);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: profiles
    });
    return {
      data: profiles
    };
  };
}

function getProfilesInTeam(teamId
/*: string*/
, page
/*: number*/
, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE, sort
/*: string*/
= '')
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    let profiles
    /*: null*/
    ;

    try {
      profiles = await _client.Client4.getProfilesInTeam(teamId, page, perPage, sort);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_TEAM,
      data: profiles,
      id: teamId
    }, {
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: (0, _user_utils.removeUserFromList)(currentUserId, [...profiles])
    }]), getState);
    return {
      data: profiles
    };
  };
}

function getProfilesNotInTeam(teamId
/*: string*/
, groupConstrained
/*: boolean*/
, page
/*: number*/
, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let profiles
    /*: null*/
    ;

    try {
      profiles = await _client.Client4.getProfilesNotInTeam(teamId, groupConstrained, page, perPage);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const receivedProfilesListActionType = groupConstrained ? _action_types.UserTypes.RECEIVED_PROFILES_LIST_NOT_IN_TEAM_AND_REPLACE : _action_types.UserTypes.RECEIVED_PROFILES_LIST_NOT_IN_TEAM;
    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: receivedProfilesListActionType,
      data: profiles,
      id: teamId
    }, {
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: profiles
    }]), getState);
    return {
      data: profiles
    };
  };
}

function getProfilesWithoutTeam(page
/*: number*/
, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let profiles = null;

    try {
      profiles = await _client.Client4.getProfilesWithoutTeam(page, perPage);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_WITHOUT_TEAM,
      data: profiles
    }, {
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: profiles
    }]), getState);
    return {
      data: profiles
    };
  };
}

function getProfilesInChannel(channelId
/*: string*/
, page
/*: number*/
, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE, sort
/*: string*/
= '')
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    let profiles = null;

    try {
      profiles = await _client.Client4.getProfilesInChannel(channelId, page, perPage, sort);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_CHANNEL,
      data: profiles,
      id: channelId
    }, {
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: (0, _user_utils.removeUserFromList)(currentUserId, [...profiles])
    }]), getState);
    return {
      data: profiles
    };
  };
}

function getProfilesInGroupChannels(channelsIds
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    let channelProfiles = null;

    try {
      channelProfiles = await _client.Client4.getProfilesInGroupChannels(channelsIds.slice(0, _constants.General.MAX_GROUP_CHANNELS_FOR_PROFILES));
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const actions = [];

    for (const channelId in channelProfiles) {
      if (channelProfiles.hasOwnProperty(channelId)) {
        const profiles = channelProfiles[channelId];
        actions.push({
          type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_CHANNEL,
          data: profiles,
          id: channelId
        }, {
          type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
          data: (0, _user_utils.removeUserFromList)(currentUserId, [...profiles])
        });
      }
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions));
    return {
      data: channelProfiles
    };
  };
}

function getProfilesNotInChannel(teamId
/*: string*/
, channelId
/*: string*/
, groupConstrained
/*: boolean*/
, page
/*: number*/
, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    let profiles = null;

    try {
      profiles = await _client.Client4.getProfilesNotInChannel(teamId, channelId, groupConstrained, page, perPage);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const receivedProfilesListActionType = groupConstrained ? _action_types.UserTypes.RECEIVED_PROFILES_LIST_NOT_IN_CHANNEL_AND_REPLACE : _action_types.UserTypes.RECEIVED_PROFILES_LIST_NOT_IN_CHANNEL;
    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: receivedProfilesListActionType,
      data: profiles,
      id: channelId
    }, {
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: (0, _user_utils.removeUserFromList)(currentUserId, [...profiles])
    }]), getState);
    return {
      data: profiles
    };
  };
}

function getMe()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const getMeFunc = (0, _helpers2.bindClientFunc)({
      clientFunc: _client.Client4.getMe,
      onSuccess: _action_types.UserTypes.RECEIVED_ME
    });
    const me
    /*: $Subtype<ActionResult>*/
    = await getMeFunc(dispatch, getState);

    if (me.error) {
      return me;
    }

    dispatch((0, _roles.loadRolesIfNeeded)(me.data.roles.split(' ')));
    return me;
  };
}

function updateMyTermsOfServiceStatus(termsOfServiceId
/*: string*/
, accepted
/*: boolean*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const response
    /*: $Subtype<ActionResult>*/
    = await dispatch((0, _helpers2.bindClientFunc)({
      clientFunc: _client.Client4.updateMyTermsOfServiceStatus,
      params: [termsOfServiceId, accepted]
    }));
    const {
      data,
      error
    } = response;

    if (data) {
      if (accepted) {
        dispatch({
          type: _action_types.UserTypes.RECEIVED_TERMS_OF_SERVICE_STATUS,
          data: {
            terms_of_service_create_at: new Date().getTime(),
            terms_of_service_id: accepted ? termsOfServiceId : null,
            user_id: (0, _users.getCurrentUserId)(getState())
          }
        });
      }

      return {
        data
      };
    }

    return {
      error
    };
  };
}

function getTermsOfService()
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getTermsOfService
  });
}

function promoteGuestToUser(userId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.promoteGuestToUser,
    params: [userId]
  });
}

function demoteUserToGuest(userId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.demoteUserToGuest,
    params: [userId]
  });
}

function createTermsOfService(text
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.createTermsOfService,
    params: [text]
  });
}

function getUser(id
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getUser,
    onSuccess: _action_types.UserTypes.RECEIVED_PROFILE,
    params: [id]
  });
}

function getUserByUsername(username
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getUserByUsername,
    onSuccess: _action_types.UserTypes.RECEIVED_PROFILE,
    params: [username]
  });
}

function getUserByEmail(email
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getUserByEmail,
    onSuccess: _action_types.UserTypes.RECEIVED_PROFILE,
    params: [email]
  });
} // We create an array to hold the id's that we want to get a status for. We build our
// debounced function that will get called after a set period of idle time in which
// the array of id's will be passed to the getStatusesByIds with a cb that clears out
// the array. Helps with performance because instead of making 75 different calls for
// statuses, we are only making one call for 75 ids.
// We could maybe clean it up somewhat by storing the array of ids in redux state possbily?


let ids
/*: Array<string>*/
= [];
const debouncedGetStatusesByIds = (0, _helpers2.debounce)(async (dispatch
/*: DispatchFunc*/
, getState
/*: GetStateFunc*/
) => {
  getStatusesByIds([...new Set(ids)])(dispatch, getState);
}, 20, false, () => {
  ids = [];
});

function getStatusesByIdsBatchedDebounced(id
/*: string*/
) {
  ids = [...ids, id];
  return debouncedGetStatusesByIds;
}

function getStatusesByIds(userIds
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getStatusesByIds,
    onSuccess: _action_types.UserTypes.RECEIVED_STATUSES,
    params: [userIds]
  });
}

function getStatus(userId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getStatus,
    onSuccess: _action_types.UserTypes.RECEIVED_STATUS,
    params: [userId]
  });
}

function setStatus(status
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.updateStatus(status);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.RECEIVED_STATUS,
      data: status
    });
    return {
      data: status
    };
  };
}

function getSessions(userId
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getSessions,
    onSuccess: _action_types.UserTypes.RECEIVED_SESSIONS,
    params: [userId]
  });
}

function revokeSession(userId
/*: string*/
, sessionId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.revokeSession(userId, sessionId);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.RECEIVED_REVOKED_SESSION,
      sessionId,
      data: null
    });
    return {
      data: true
    };
  };
}

function revokeAllSessionsForUser(userId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.revokeAllSessionsForUser(userId);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const data = {
      isCurrentUser: userId === (0, _users.getCurrentUserId)(getState())
    };
    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.REVOKE_ALL_USER_SESSIONS_SUCCESS,
      data
    }]), getState);
    return {
      data: true
    };
  };
}

function revokeSessionsForAllUsers()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.revokeSessionsForAllUsers();
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.REVOKE_SESSIONS_FOR_ALL_USERS_SUCCESS,
      data: null
    });
    return {
      data: true
    };
  };
}

function loadProfilesForDirect()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const config = state.entities.general.config;
    const {
      channels,
      myMembers
    } = state.entities.channels;
    const {
      myPreferences
    } = state.entities.preferences;
    const {
      currentUserId,
      profiles
    } = state.entities.users;
    const values = Object.values(channels);

    for (let i = 0; i < values.length; i++) {
      const channel
      /*: any*/
      = values[i];
      const member = myMembers[channel.id];

      if (!(0, _channel_utils.isDirectChannel)(channel) && !(0, _channel_utils.isGroupChannel)(channel)) {
        continue;
      }

      if (member) {
        if (member.mention_count > 0 && (0, _channel_utils.isDirectChannel)(channel)) {
          const otherUserId = (0, _channel_utils.getUserIdFromChannelName)(currentUserId, channel.name);

          if (!(0, _channel_utils.isDirectChannelVisible)(profiles[otherUserId] || otherUserId, config, myPreferences, channel)) {
            (0, _preferences.makeDirectChannelVisibleIfNecessary)(otherUserId)(dispatch, getState);
          }
        } else if ((member.mention_count > 0 || member.msg_count < channel.total_msg_count) && (0, _channel_utils.isGroupChannel)(channel) && !(0, _channel_utils.isGroupChannelVisible)(config, myPreferences, channel)) {
          (0, _preferences.makeGroupMessageVisibleIfNecessary)(channel.id)(dispatch, getState);
        }
      }
    }

    return {
      data: true
    };
  };
}

function getUserAudits(userId
/*: string*/
, page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.AUDITS_CHUNK_SIZE)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.getUserAudits,
    onSuccess: _action_types.UserTypes.RECEIVED_AUDITS,
    params: [userId, page, perPage]
  });
}

function autocompleteUsers(term
/*: string*/
, teamId
/*: string*/
= '', channelId
/*: string*/
= '', options
/*: {|limit: number|}*/
= {
  limit: _constants.General.AUTOCOMPLETE_LIMIT_DEFAULT
})
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.UserTypes.AUTOCOMPLETE_USERS_REQUEST,
      data: null
    }, getState);
    const {
      currentUserId
    } = getState().entities.users;
    let data;

    try {
      data = await _client.Client4.autocompleteUsers(term, teamId, channelId, options);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.UserTypes.AUTOCOMPLETE_USERS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    let users = [...data.users];

    if (data.out_of_channel) {
      users = [...users, ...data.out_of_channel];
    }

    (0, _user_utils.removeUserFromList)(currentUserId, users);
    const actions = [{
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: users
    }, {
      type: _action_types.UserTypes.AUTOCOMPLETE_USERS_SUCCESS
    }];

    if (channelId) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_CHANNEL,
        data: data.users,
        id: channelId
      });
      actions.push({
        type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_NOT_IN_CHANNEL,
        data: data.out_of_channel,
        id: channelId
      });
    }

    if (teamId) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_TEAM,
        data: users,
        id: teamId
      });
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data
    };
  };
}

function searchProfiles(term
/*: string*/
, options
/*: Object*/
= {})
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    let profiles;

    try {
      profiles = await _client.Client4.searchUsers(term, options);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const actions = [{
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST,
      data: (0, _user_utils.removeUserFromList)(currentUserId, [...profiles])
    }];

    if (options.in_channel_id) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_CHANNEL,
        data: profiles,
        id: options.in_channel_id
      });
    }

    if (options.not_in_channel_id) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_NOT_IN_CHANNEL,
        data: profiles,
        id: options.not_in_channel_id
      });
    }

    if (options.team_id) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_TEAM,
        data: profiles,
        id: options.team_id
      });
    }

    if (options.not_in_team_id) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_NOT_IN_TEAM,
        data: profiles,
        id: options.not_in_team_id
      });
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions));
    return {
      data: profiles
    };
  };
}

let statusIntervalId = null;

function startPeriodicStatusUpdates()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    if (statusIntervalId) {
      clearInterval(statusIntervalId);
    }

    statusIntervalId = setInterval(() => {
      const {
        statuses
      } = getState().entities.users;

      if (!statuses) {
        return;
      }

      const userIds = Object.keys(statuses);

      if (!userIds.length) {
        return;
      }

      getStatusesByIds(userIds)(dispatch, getState);
    }, _constants.General.STATUS_INTERVAL);
    return {
      data: true
    };
  };
}

function stopPeriodicStatusUpdates()
/*: ActionFunc*/
{
  return async () => {
    if (statusIntervalId) {
      clearInterval(statusIntervalId);
    }

    return {
      data: true
    };
  };
}

function updateMe(user
/*: UserProfile*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.UserTypes.UPDATE_ME_REQUEST,
      data: null
    }, getState);
    let data;

    try {
      data = await _client.Client4.patchMe(user);
    } catch (error) {
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.UserTypes.UPDATE_ME_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.RECEIVED_ME,
      data
    }, {
      type: _action_types.UserTypes.UPDATE_ME_SUCCESS
    }]), getState);
    dispatch((0, _roles.loadRolesIfNeeded)(data.roles.split(' ')));
    return {
      data
    };
  };
}

function patchUser(user
/*: UserProfile*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  ) => {
    let data
    /*: UserProfile*/
    ;

    try {
      data = await _client.Client4.patchUser(user);
    } catch (error) {
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.RECEIVED_PROFILE,
      data
    });
    return {
      data
    };
  };
}

function updateUserRoles(userId
/*: string*/
, roles
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.updateUserRoles(userId, roles);
    } catch (error) {
      return {
        error
      };
    }

    const profile = getState().entities.users.profiles[userId];

    if (profile) {
      dispatch({
        type: _action_types.UserTypes.RECEIVED_PROFILE,
        data: _objectSpread({}, profile, {
          roles
        })
      });
    }

    return {
      data: true
    };
  };
}

function updateUserMfa(userId
/*: string*/
, activate
/*: boolean*/
, code
/*: string*/
= '')
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.updateUserMfa(userId, activate, code);
    } catch (error) {
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const profile = getState().entities.users.profiles[userId];

    if (profile) {
      dispatch({
        type: _action_types.UserTypes.RECEIVED_PROFILE,
        data: _objectSpread({}, profile, {
          mfa_active: activate
        })
      });
    }

    return {
      data: true
    };
  };
}

function updateUserPassword(userId
/*: string*/
, currentPassword
/*: string*/
, newPassword
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.updateUserPassword(userId, currentPassword, newPassword);
    } catch (error) {
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const profile = getState().entities.users.profiles[userId];

    if (profile) {
      dispatch({
        type: _action_types.UserTypes.RECEIVED_PROFILE,
        data: _objectSpread({}, profile, {
          last_password_update_at: new Date().getTime()
        })
      });
    }

    return {
      data: true
    };
  };
}

function updateUserActive(userId
/*: string*/
, active
/*: boolean*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.updateUserActive(userId, active);
    } catch (error) {
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const profile = getState().entities.users.profiles[userId];

    if (profile) {
      const deleteAt = active ? 0 : new Date().getTime();
      dispatch({
        type: _action_types.UserTypes.RECEIVED_PROFILE,
        data: _objectSpread({}, profile, {
          delete_at: deleteAt
        })
      });
    }

    return {
      data: true
    };
  };
}

function verifyUserEmail(token
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.verifyUserEmail,
    params: [token]
  });
}

function sendVerificationEmail(email
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.sendVerificationEmail,
    params: [email]
  });
}

function resetUserPassword(token
/*: string*/
, newPassword
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.resetUserPassword,
    params: [token, newPassword]
  });
}

function sendPasswordResetEmail(email
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.sendPasswordResetEmail,
    params: [email]
  });
}

function setDefaultProfileImage(userId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.setDefaultProfileImage(userId);
    } catch (error) {
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const profile = getState().entities.users.profiles[userId];

    if (profile) {
      dispatch({
        type: _action_types.UserTypes.RECEIVED_PROFILE,
        data: _objectSpread({}, profile, {
          last_picture_update: 0
        })
      });
    }

    return {
      data: true
    };
  };
}

function uploadProfileImage(userId
/*: string*/
, imageData
/*: any*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.uploadProfileImage(userId, imageData);
    } catch (error) {
      return {
        error
      };
    }

    const profile = getState().entities.users.profiles[userId];

    if (profile) {
      dispatch({
        type: _action_types.UserTypes.RECEIVED_PROFILE,
        data: _objectSpread({}, profile, {
          last_picture_update: new Date().getTime()
        })
      });
    }

    return {
      data: true
    };
  };
}

function switchEmailToOAuth(service
/*: string*/
, email
/*: string*/
, password
/*: string*/
, mfaCode
/*: string*/
= '')
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.switchEmailToOAuth,
    params: [service, email, password, mfaCode]
  });
}

function switchOAuthToEmail(currentService
/*: string*/
, email
/*: string*/
, password
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.switchOAuthToEmail,
    params: [currentService, email, password]
  });
}

function switchEmailToLdap(email
/*: string*/
, emailPassword
/*: string*/
, ldapId
/*: string*/
, ldapPassword
/*: string*/
, mfaCode
/*: string*/
= '')
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.switchEmailToLdap,
    params: [email, emailPassword, ldapId, ldapPassword, mfaCode]
  });
}

function switchLdapToEmail(ldapPassword
/*: string*/
, email
/*: string*/
, emailPassword
/*: string*/
, mfaCode
/*: string*/
= '')
/*: ActionFunc*/
{
  return (0, _helpers2.bindClientFunc)({
    clientFunc: _client.Client4.switchLdapToEmail,
    params: [ldapPassword, email, emailPassword, mfaCode]
  });
}

function createUserAccessToken(userId
/*: string*/
, description
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let data;

    try {
      data = await _client.Client4.createUserAccessToken(userId, description);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const actions = [{
      type: _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKEN,
      data: _objectSpread({}, data, {
        token: ''
      })
    }];
    const {
      currentUserId
    } = getState().entities.users;

    if (userId === currentUserId) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_MY_USER_ACCESS_TOKEN,
        data: _objectSpread({}, data, {
          token: ''
        })
      });
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions));
    return {
      data
    };
  };
}

function getUserAccessToken(tokenId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let data;

    try {
      data = await _client.Client4.getUserAccessToken(tokenId);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const actions = [{
      type: _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKEN,
      data
    }];
    const {
      currentUserId
    } = getState().entities.users;

    if (data.user_id === currentUserId) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_MY_USER_ACCESS_TOKEN,
        data
      });
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions));
    return {
      data
    };
  };
}

function getUserAccessTokens(page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let data;

    try {
      data = await _client.Client4.getUserAccessTokens(page, perPage);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const actions = [{
      type: _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKENS,
      data
    }];
    dispatch((0, _reduxBatchedActions.batchActions)(actions));
    return {
      data
    };
  };
}

function getUserAccessTokensForUser(userId
/*: string*/
, page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    let data;

    try {
      data = await _client.Client4.getUserAccessTokensForUser(userId, page, perPage);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const actions = [{
      type: _action_types.AdminTypes.RECEIVED_USER_ACCESS_TOKENS_FOR_USER,
      data,
      userId
    }];
    const {
      currentUserId
    } = getState().entities.users;

    if (userId === currentUserId) {
      actions.push({
        type: _action_types.UserTypes.RECEIVED_MY_USER_ACCESS_TOKENS,
        data
      });
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions));
    return {
      data
    };
  };
}

function revokeUserAccessToken(tokenId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.revokeUserAccessToken(tokenId);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.REVOKED_USER_ACCESS_TOKEN,
      data: tokenId
    });
    return {
      data: true
    };
  };
}

function disableUserAccessToken(tokenId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.disableUserAccessToken(tokenId);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.DISABLED_USER_ACCESS_TOKEN,
      data: tokenId
    });
    return {
      data: true
    };
  };
}

function enableUserAccessToken(tokenId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    try {
      await _client.Client4.enableUserAccessToken(tokenId);
    } catch (error) {
      (0, _helpers2.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.UserTypes.ENABLED_USER_ACCESS_TOKEN,
      data: tokenId
    });
    return {
      data: true
    };
  };
}

function clearUserAccessTokens()
/*: ActionFunc*/
{
  return async dispatch => {
    dispatch({
      type: _action_types.UserTypes.CLEAR_MY_USER_ACCESS_TOKENS,
      data: null
    });
    return {
      data: true
    };
  };
}

function checkForModifiedUsers() {
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const users = (0, _users.getUsers)(state);
    const lastDisconnectAt = state.websocket.lastDisconnectAt;
    const serverVersion = (0, _general2.getServerVersion)(state);

    if (!(0, _helpers.isMinimumServerVersion)(serverVersion, 5, 14)) {
      return {
        data: true
      };
    }

    await dispatch(getProfilesByIds(Object.keys(users), {
      since: lastDisconnectAt
    }));
    return {
      data: true
    };
  };
}

var _default = {
  checkMfa,
  generateMfaSecret,
  login,
  logout,
  getProfiles,
  getProfilesByIds,
  getProfilesInTeam,
  getProfilesInChannel,
  getProfilesNotInChannel,
  getUser,
  getMe,
  getUserByUsername,
  getStatus,
  getStatusesByIds,
  getSessions,
  getTotalUsersStats,
  loadProfilesForDirect,
  revokeSession,
  revokeAllSessionsForUser,
  revokeSessionsForAllUsers,
  getUserAudits,
  searchProfiles,
  startPeriodicStatusUpdates,
  stopPeriodicStatusUpdates,
  updateMe,
  updateUserRoles,
  updateUserMfa,
  updateUserPassword,
  updateUserActive,
  verifyUserEmail,
  sendVerificationEmail,
  resetUserPassword,
  sendPasswordResetEmail,
  uploadProfileImage,
  switchEmailToOAuth,
  switchOAuthToEmail,
  switchEmailToLdap,
  switchLdapToEmail,
  getTermsOfService,
  createTermsOfService,
  updateMyTermsOfServiceStatus,
  createUserAccessToken,
  getUserAccessToken,
  getUserAccessTokensForUser,
  revokeUserAccessToken,
  disableUserAccessToken,
  enableUserAccessToken,
  checkForModifiedUsers
};
exports.default = _default;