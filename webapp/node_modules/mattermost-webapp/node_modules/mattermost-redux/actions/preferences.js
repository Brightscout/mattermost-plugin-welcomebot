"use strict";

require("core-js/modules/es.promise");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deletePreferences = deletePreferences;
exports.getMyPreferences = getMyPreferences;
exports.makeDirectChannelVisibleIfNecessary = makeDirectChannelVisibleIfNecessary;
exports.makeGroupMessageVisibleIfNecessary = makeGroupMessageVisibleIfNecessary;
exports.savePreferences = savePreferences;
exports.saveTheme = saveTheme;
exports.deleteTeamSpecificThemes = deleteTeamSpecificThemes;

var _client = require("../client");

var _constants = require("../constants");

var _action_types = require("../action_types");

var _preferences = require("../selectors/entities/preferences");

var _users = require("../selectors/entities/users");

var _preference_utils = require("../utils/preference_utils");

var _helpers = require("./helpers");

var _users2 = require("./users");

var _channels = require("./channels");

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow
function deletePreferences(userId
/*: string*/
, preferences
/*: Array<PreferenceType>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const myPreferences = (0, _preferences.getMyPreferences)(state);
    const currentPreferences = preferences.map(pref => myPreferences[(0, _preference_utils.getPreferenceKey)(pref.category, pref.name)]);
    dispatch({
      type: _action_types.PreferenceTypes.DELETED_PREFERENCES,
      data: preferences,
      meta: {
        offline: {
          effect: () => _client.Client4.deletePreferences(userId, preferences),
          commit: {
            type: _action_types.PreferenceTypes.DELETED_PREFERENCES
          },
          rollback: {
            type: _action_types.PreferenceTypes.RECEIVED_PREFERENCES,
            data: currentPreferences
          }
        }
      }
    });
    return {
      data: true
    };
  };
}

function getMyPreferences()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getMyPreferences,
    onRequest: _action_types.PreferenceTypes.MY_PREFERENCES_REQUEST,
    onSuccess: [_action_types.PreferenceTypes.RECEIVED_ALL_PREFERENCES, _action_types.PreferenceTypes.MY_PREFERENCES_SUCCESS],
    onFailure: _action_types.PreferenceTypes.MY_PREFERENCES_FAILURE
  });
}

function makeDirectChannelVisibleIfNecessary(otherUserId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const myPreferences = (0, _preferences.getMyPreferences)(state);
    const currentUserId = (0, _users.getCurrentUserId)(state);
    let preference = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_DIRECT_CHANNEL_SHOW, otherUserId)];

    if (!preference || preference.value === 'false') {
      preference = {
        user_id: currentUserId,
        category: _constants.Preferences.CATEGORY_DIRECT_CHANNEL_SHOW,
        name: otherUserId,
        value: 'true'
      };
      (0, _users2.getProfilesByIds)([otherUserId])(dispatch, getState);
      savePreferences(currentUserId, [preference])(dispatch);
    }

    return {
      data: true
    };
  };
}

function makeGroupMessageVisibleIfNecessary(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const myPreferences = (0, _preferences.getMyPreferences)(state);
    const currentUserId = (0, _users.getCurrentUserId)(state);
    const {
      channels
    } = state.entities.channels;
    let preference = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_GROUP_CHANNEL_SHOW, channelId)];

    if (!preference || preference.value === 'false') {
      preference = {
        user_id: currentUserId,
        category: _constants.Preferences.CATEGORY_GROUP_CHANNEL_SHOW,
        name: channelId,
        value: 'true'
      };

      if (channels[channelId]) {
        (0, _channels.getMyChannelMember)(channelId)(dispatch, getState);
      } else {
        (0, _channels.getChannelAndMyMember)(channelId)(dispatch, getState);
      }

      (0, _users2.getProfilesInChannel)(channelId, 0)(dispatch, getState);
      savePreferences(currentUserId, [preference])(dispatch);
    }

    return {
      data: true
    };
  };
}

function savePreferences(userId
/*: string*/
, preferences
/*: Array<PreferenceType>*/
) {
  return async (dispatch
  /*: DispatchFunc*/
  ) => {
    dispatch({
      type: _action_types.PreferenceTypes.RECEIVED_PREFERENCES,
      data: preferences,
      meta: {
        offline: {
          effect: () => _client.Client4.savePreferences(userId, preferences),
          commit: {
            type: _action_types.PreferenceTypes.RECEIVED_PREFERENCES
          },
          rollback: {
            type: _action_types.PreferenceTypes.DELETED_PREFERENCES,
            data: preferences
          }
        }
      }
    });
    return {
      data: true
    };
  };
}

function saveTheme(teamId
/*: string*/
, theme
/*: {}*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const currentUserId = (0, _users.getCurrentUserId)(state);
    const preference
    /*: PreferenceType*/
    = {
      user_id: currentUserId,
      category: _constants.Preferences.CATEGORY_THEME,
      name: teamId || '',
      value: JSON.stringify(theme)
    };
    await savePreferences(currentUserId, [preference])(dispatch);
    return {
      data: true
    };
  };
}

function deleteTeamSpecificThemes()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState(); // $FlowFixMe

    const getCategory
    /*: (state: any, preferenceId: string) => void*/
    = (0, _preferences.makeGetCategory)();
    const themePreferences
    /*: Array<PreferenceType>*/
    = getCategory(state, _constants.Preferences.CATEGORY_THEME);
    const currentUserId = (0, _users.getCurrentUserId)(state);
    const toDelete = themePreferences.filter(pref => pref.name !== '');

    if (toDelete.length > 0) {
      await deletePreferences(currentUserId, toDelete)(dispatch, getState);
    }

    return {
      data: true
    };
  };
}