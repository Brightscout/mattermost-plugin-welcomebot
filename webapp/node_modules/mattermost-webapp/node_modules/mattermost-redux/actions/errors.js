"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.includes");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dismissErrorObject = dismissErrorObject;
exports.dismissError = dismissError;
exports.getLogErrorAction = getLogErrorAction;
exports.logError = logError;
exports.clearErrors = clearErrors;

var _action_types = require("../action_types");

var _serializeError = _interopRequireDefault(require("serialize-error"));

var _client = require("../client");

var _event_emitter = _interopRequireDefault(require("../utils/event_emitter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow
function dismissErrorObject(index
/*: number*/
) {
  return {
    type: _action_types.ErrorTypes.DISMISS_ERROR,
    index,
    data: null
  };
}

function dismissError(index
/*: number*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  ) => {
    dispatch(dismissErrorObject(index));
    return {
      data: true
    };
  };
}

function getLogErrorAction(error
/*: Error*/
, displayable
/*: boolean*/
= false) {
  return {
    type: _action_types.ErrorTypes.LOG_ERROR,
    displayable,
    error,
    data: null
  };
}

function logError(error
/*: Error*/
, displayable
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  ) => {
    if (error.server_error_id === 'api.context.session_expired.app_error') {
      return {
        data: true
      };
    }

    const serializedError = (0, _serializeError.default)(error);
    let sendToServer = true;

    if (error.stack && error.stack.includes('TypeError: Failed to fetch')) {
      sendToServer = false;
    }

    if (error.server_error_id) {
      sendToServer = false;
    }

    if (sendToServer) {
      try {
        const stringifiedSerializedError = JSON.stringify(serializedError).toString();
        await _client.Client4.logClientError(stringifiedSerializedError);
      } catch (err) {// avoid crashing the app if an error sending
        // the error occurs.
      }
    }

    _event_emitter.default.emit(_action_types.ErrorTypes.LOG_ERROR, error);

    dispatch(getLogErrorAction(serializedError, displayable));
    return {
      data: true
    };
  };
}

function clearErrors()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  ) => {
    dispatch({
      type: _action_types.ErrorTypes.CLEAR_ERRORS,
      data: null
    });
    return {
      data: true
    };
  };
}