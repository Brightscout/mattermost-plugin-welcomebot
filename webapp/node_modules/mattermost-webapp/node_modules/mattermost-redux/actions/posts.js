"use strict";

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.includes");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.receivedPost = receivedPost;
exports.receivedNewPost = receivedNewPost;
exports.receivedPosts = receivedPosts;
exports.receivedPostsAfter = receivedPostsAfter;
exports.receivedPostsBefore = receivedPostsBefore;
exports.receivedPostsSince = receivedPostsSince;
exports.receivedPostsInChannel = receivedPostsInChannel;
exports.receivedPostsInThread = receivedPostsInThread;
exports.postDeleted = postDeleted;
exports.postRemoved = postRemoved;
exports.getPost = getPost;
exports.createPost = createPost;
exports.createPostImmediately = createPostImmediately;
exports.resetCreatePostRequest = resetCreatePostRequest;
exports.deletePost = deletePost;
exports.editPost = editPost;
exports.pinPost = pinPost;
exports.unpinPost = unpinPost;
exports.addReaction = addReaction;
exports.removeReaction = removeReaction;
exports.getCustomEmojiForReaction = getCustomEmojiForReaction;
exports.getReactionsForPost = getReactionsForPost;
exports.flagPost = flagPost;
exports.getPostThread = getPostThread;
exports.getPosts = getPosts;
exports.getPostsUnread = getPostsUnread;
exports.getPostsSince = getPostsSince;
exports.getPostsBefore = getPostsBefore;
exports.getPostsAfter = getPostsAfter;
exports.getPostsAround = getPostsAround;
exports.getThreadsForPosts = getThreadsForPosts;
exports.getProfilesAndStatusesForPosts = getProfilesAndStatusesForPosts;
exports.getNeededAtMentionedUsernames = getNeededAtMentionedUsernames;
exports.getNeededCustomEmojis = getNeededCustomEmojis;
exports.removePost = removePost;
exports.selectPost = selectPost;
exports.selectFocusedPostId = selectFocusedPostId;
exports.unflagPost = unflagPost;
exports.getOpenGraphMetadata = getOpenGraphMetadata;
exports.doPostAction = doPostAction;
exports.doPostActionWithCookie = doPostActionWithCookie;
exports.addMessageIntoHistory = addMessageIntoHistory;
exports.resetHistoryIndex = resetHistoryIndex;
exports.moveHistoryIndexBack = moveHistoryIndexBack;
exports.moveHistoryIndexForward = moveHistoryIndexForward;
exports.handleNewPost = handleNewPost;

var _reduxBatchedActions = require("redux-batched-actions");

var _client = require("../client");

var _constants = require("../constants");

var _action_types = require("../action_types");

var _channels = require("../selectors/entities/channels");

var _emojis = require("../selectors/entities/emojis");

var _general = require("../selectors/entities/general");

var Selectors = _interopRequireWildcard(require("../selectors/entities/posts"));

var _users = require("../selectors/entities/users");

var _channel_utils = require("../utils/channel_utils");

var _emoji_utils = require("../utils/emoji_utils");

var _post_utils = require("../utils/post_utils");

var _channels2 = require("./channels");

var _emojis2 = require("./emojis");

var _errors = require("./errors");

var _helpers = require("./helpers");

var _preferences = require("./preferences");

var _users2 = require("./users");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// receivedPost should be dispatched after a single post from the server. This typically happens when an existing post
// is updated.
function receivedPost(post) {
  return {
    type: _action_types.PostTypes.RECEIVED_POST,
    data: post
  };
} // receivedNewPost should be dispatched when receiving a newly created post or when sending a request to the server
// to make a new post.


function receivedNewPost(post) {
  return {
    type: _action_types.PostTypes.RECEIVED_NEW_POST,
    data: post
  };
} // receivedPosts should be dispatched when receiving multiple posts from the server that may or may not be ordered.
// This will typically be used alongside other actions like receivedPostsAfter which require the posts to be ordered.


function receivedPosts(posts) {
  return {
    type: _action_types.PostTypes.RECEIVED_POSTS,
    data: posts
  };
} // receivedPostsAfter should be dispatched when receiving an ordered list of posts that come before a given post.


function receivedPostsAfter(posts, channelId, afterPostId, recent = false) {
  return {
    type: _action_types.PostTypes.RECEIVED_POSTS_AFTER,
    channelId,
    data: posts,
    afterPostId,
    recent
  };
} // receivedPostsBefore should be dispatched when receiving an ordered list of posts that come after a given post.


function receivedPostsBefore(posts, channelId, beforePostId) {
  return {
    type: _action_types.PostTypes.RECEIVED_POSTS_BEFORE,
    channelId,
    data: posts,
    beforePostId
  };
} // receivedPostsSince should be dispatched when receiving a list of posts that have been updated since a certain time.
// Due to how the API endpoint works, some of these posts will be ordered, but others will not, so this needs special
// handling from the reducers.


function receivedPostsSince(posts, channelId) {
  return {
    type: _action_types.PostTypes.RECEIVED_POSTS_SINCE,
    channelId,
    data: posts
  };
} // receivedPostsInChannel should be dispatched when receiving a list of ordered posts within a channel when the
// the adjacent posts are not known.


function receivedPostsInChannel(posts, channelId, recent = false) {
  return {
    type: _action_types.PostTypes.RECEIVED_POSTS_IN_CHANNEL,
    channelId,
    data: posts,
    recent
  };
} // receivedPostsInThread should be dispatched when receiving a list of unordered posts in a thread.


function receivedPostsInThread(posts, rootId) {
  return {
    type: _action_types.PostTypes.RECEIVED_POSTS_IN_THREAD,
    data: posts,
    rootId
  };
} // postDeleted should be dispatched when a post has been deleted and should be replaced with a "message deleted"
// placeholder. This typically happens when a post is deleted by another user.


function postDeleted(post) {
  return {
    type: _action_types.PostTypes.POST_DELETED,
    data: post
  };
} // postRemoved should be dispatched when a post should be immediately removed. This typically happens when a post is
// deleted by the current user.


function postRemoved(post) {
  return {
    type: _action_types.PostTypes.POST_REMOVED,
    data: post
  };
}

function getPost(postId) {
  return async (dispatch, getState) => {
    let post;

    try {
      post = await _client.Client4.getPost(postId);
      getProfilesAndStatusesForPosts([post], dispatch, getState);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.PostTypes.GET_POSTS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([receivedPost(post), {
      type: _action_types.PostTypes.GET_POSTS_SUCCESS
    }]));
    return {
      data: post
    };
  };
}

function createPost(post, files = []) {
  return async (dispatch, getState) => {
    const state = getState();
    const currentUserId = state.entities.users.currentUserId;
    const timestamp = Date.now();
    const pendingPostId = post.pending_post_id || "".concat(currentUserId, ":").concat(timestamp);

    if (Selectors.isPostIdSending(state, pendingPostId)) {
      return {
        data: true
      };
    }

    let newPost = _objectSpread({}, post, {
      pending_post_id: pendingPostId,
      create_at: timestamp,
      update_at: timestamp
    }); // We are retrying a pending post that had files


    if (newPost.file_ids && !files.length) {
      files = newPost.file_ids.map(id => state.entities.files.files[id]); // eslint-disable-line
    }

    if (files.length) {
      const fileIds = files.map(file => file.id);
      newPost = _objectSpread({}, newPost, {
        file_ids: fileIds
      });
      dispatch({
        type: _action_types.FileTypes.RECEIVED_FILES_FOR_POST,
        postId: pendingPostId,
        data: files
      });
    }

    dispatch({
      type: _action_types.PostTypes.RECEIVED_NEW_POST,
      data: _objectSpread({
        id: pendingPostId
      }, newPost),
      meta: {
        offline: {
          effect: () => _client.Client4.createPost(_objectSpread({}, newPost, {
            create_at: 0
          })),
          commit: (success, payload) => {
            const actions = [receivedPost(payload), {
              type: _action_types.PostTypes.CREATE_POST_SUCCESS
            }];

            if (files) {
              actions.push({
                type: _action_types.FileTypes.RECEIVED_FILES_FOR_POST,
                postId: payload.id,
                data: files
              });
            }

            dispatch((0, _reduxBatchedActions.batchActions)(actions));
          },
          maxRetry: 0,
          offlineRollback: true,
          rollback: (success, error) => {
            const data = _objectSpread({}, newPost, {
              id: pendingPostId,
              failed: true,
              update_at: Date.now()
            });

            dispatch({
              type: _action_types.PostTypes.CREATE_POST_FAILURE,
              error
            }); // If the failure was because: the root post was deleted or
            // TownSquareIsReadOnly=true then remove the post

            if (error.server_error_id === 'api.post.create_post.root_id.app_error' || error.server_error_id === 'api.post.create_post.town_square_read_only' || error.server_error_id === 'plugin.message_will_be_posted.dismiss_post') {
              dispatch(removePost(data));
            } else {
              dispatch(receivedPost(data));
            }
          }
        }
      }
    });
    return {
      data: true
    };
  };
}

function createPostImmediately(post, files = []) {
  return async (dispatch, getState) => {
    const state = getState();
    const currentUserId = state.entities.users.currentUserId;
    const timestamp = Date.now();
    const pendingPostId = "".concat(currentUserId, ":").concat(timestamp);

    let newPost = _objectSpread({}, post, {
      pending_post_id: pendingPostId,
      create_at: timestamp,
      update_at: timestamp
    });

    if (files.length) {
      const fileIds = files.map(file => file.id);
      newPost = _objectSpread({}, newPost, {
        file_ids: fileIds
      });
      dispatch({
        type: _action_types.FileTypes.RECEIVED_FILES_FOR_POST,
        postId: pendingPostId,
        data: files
      });
    }

    dispatch(receivedNewPost(_objectSpread({
      id: pendingPostId
    }, newPost)));

    try {
      const created = await _client.Client4.createPost(_objectSpread({}, newPost, {
        create_at: 0
      }));
      newPost.id = created.id;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.PostTypes.CREATE_POST_FAILURE,
        error
      }, removePost(_objectSpread({
        id: pendingPostId
      }, newPost)), (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    const actions = [receivedPost(newPost), {
      type: _action_types.PostTypes.CREATE_POST_SUCCESS
    }];

    if (files) {
      actions.push({
        type: _action_types.FileTypes.RECEIVED_FILES_FOR_POST,
        postId: newPost.id,
        data: files
      });
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data: newPost
    };
  };
}

function resetCreatePostRequest() {
  return {
    type: _action_types.PostTypes.CREATE_POST_RESET_REQUEST
  };
}

function deletePost(post) {
  return (dispatch, getState) => {
    const state = getState();

    const delPost = _objectSpread({}, post);

    if (delPost.type === _constants.Posts.POST_TYPES.COMBINED_USER_ACTIVITY) {
      delPost.system_post_ids.forEach(systemPostId => {
        const systemPost = Selectors.getPost(state, systemPostId);

        if (systemPost) {
          dispatch(deletePost(systemPost));
        }
      });
    } else {
      dispatch({
        type: _action_types.PostTypes.POST_DELETED,
        data: delPost,
        meta: {
          offline: {
            effect: () => _client.Client4.deletePost(post.id),
            commit: {
              type: 'do_nothing'
            },
            // redux-offline always needs to dispatch something on commit
            rollback: receivedPost(delPost)
          }
        }
      });
    }

    return {
      data: true
    };
  };
}

function editPost(post) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.patchPost,
    onRequest: _action_types.PostTypes.EDIT_POST_REQUEST,
    onSuccess: [_action_types.PostTypes.RECEIVED_POST, _action_types.PostTypes.EDIT_POST_SUCCESS],
    onFailure: _action_types.PostTypes.EDIT_POST_FAILURE,
    params: [post]
  });
}

function pinPost(postId) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.PostTypes.EDIT_POST_REQUEST
    }, getState);
    let posts;

    try {
      posts = await _client.Client4.pinPost(postId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.PostTypes.EDIT_POST_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    const actions = [{
      type: _action_types.PostTypes.EDIT_POST_SUCCESS
    }];
    const post = Selectors.getPost(getState(), postId);

    if (post) {
      actions.push(receivedPost(_objectSpread({}, post, {
        is_pinned: true,
        update_at: Date.now()
      })));
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data: posts
    };
  };
}

function unpinPost(postId) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.PostTypes.EDIT_POST_REQUEST
    }, getState);
    let posts;

    try {
      posts = await _client.Client4.unpinPost(postId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.PostTypes.EDIT_POST_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    const actions = [{
      type: _action_types.PostTypes.EDIT_POST_SUCCESS
    }];
    const post = Selectors.getPost(getState(), postId);

    if (post) {
      actions.push(receivedPost(_objectSpread({}, post, {
        is_pinned: false,
        update_at: Date.now()
      })));
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data: posts
    };
  };
}

function addReaction(postId, emojiName) {
  return async (dispatch, getState) => {
    const currentUserId = getState().entities.users.currentUserId;
    let reaction;

    try {
      reaction = await _client.Client4.addReaction(currentUserId, postId, emojiName);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.PostTypes.RECEIVED_REACTION,
      data: reaction
    });
    return {
      data: true
    };
  };
}

function removeReaction(postId, emojiName) {
  return async (dispatch, getState) => {
    const currentUserId = getState().entities.users.currentUserId;

    try {
      await _client.Client4.removeReaction(currentUserId, postId, emojiName);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.PostTypes.REACTION_DELETED,
      data: {
        user_id: currentUserId,
        post_id: postId,
        emoji_name: emojiName
      }
    });
    return {
      data: true
    };
  };
}

function getCustomEmojiForReaction(name) {
  return async (dispatch, getState) => {
    const nonExistentEmoji = getState().entities.emojis.nonExistentEmoji;
    const customEmojisByName = (0, _emojis.getCustomEmojisByName)(getState());

    if (_emojis2.systemEmojis.has(name)) {
      return {
        data: true
      };
    }

    if (nonExistentEmoji.has(name)) {
      return {
        data: true
      };
    }

    if (customEmojisByName.has(name)) {
      return {
        data: true
      };
    }

    return dispatch((0, _emojis2.getCustomEmojiByName)(name));
  };
}

function getReactionsForPost(postId) {
  return async (dispatch, getState) => {
    let reactions;

    try {
      reactions = await _client.Client4.getReactionsForPost(postId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    if (reactions && reactions.length > 0) {
      const nonExistentEmoji = getState().entities.emojis.nonExistentEmoji;
      const customEmojisByName = (0, _emojis.getCustomEmojisByName)(getState());
      const emojisToLoad = new Set();
      reactions.forEach(r => {
        const name = r.emoji_name;

        if (_emojis2.systemEmojis.has(name)) {
          // It's a system emoji, go the next match
          return;
        }

        if (nonExistentEmoji.has(name)) {
          // We've previously confirmed this is not a custom emoji
          return;
        }

        if (customEmojisByName.has(name)) {
          // We have the emoji, go to the next match
          return;
        }

        emojisToLoad.add(name);
      });
      dispatch((0, _emojis2.getCustomEmojisByName)(Array.from(emojisToLoad)));
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.PostTypes.RECEIVED_REACTIONS,
      data: reactions,
      postId
    }]));
    return reactions;
  };
}

function flagPost(postId) {
  return async (dispatch, getState) => {
    const {
      currentUserId
    } = getState().entities.users;
    const preference = {
      user_id: currentUserId,
      category: _constants.Preferences.CATEGORY_FLAGGED_POST,
      name: postId,
      value: 'true'
    };

    _client.Client4.trackEvent('action', 'action_posts_flag');

    return (0, _preferences.savePreferences)(currentUserId, [preference])(dispatch, getState);
  };
}

function getPostThread(rootId) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.PostTypes.GET_POST_THREAD_REQUEST
    }, getState);
    let posts;

    try {
      posts = await _client.Client4.getPostThread(rootId);
      getProfilesAndStatusesForPosts(posts.posts, dispatch, getState);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.PostTypes.GET_POST_THREAD_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([receivedPosts(posts), receivedPostsInThread(posts, rootId), {
      type: _action_types.PostTypes.GET_POST_THREAD_SUCCESS
    }]));
    return {
      data: posts
    };
  };
}

function getPosts(channelId, page = 0, perPage = _constants.Posts.POST_CHUNK_SIZE) {
  return async (dispatch, getState) => {
    let posts;

    try {
      posts = await _client.Client4.getPosts(channelId, page, perPage);
      getProfilesAndStatusesForPosts(posts.posts, dispatch, getState);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([receivedPosts(posts), receivedPostsInChannel(posts, channelId, page === 0)]));
    return {
      data: posts
    };
  };
}

function getPostsUnread(channelId) {
  return async (dispatch, getState) => {
    const userId = (0, _users.getCurrentUserId)(getState());
    let posts;

    try {
      posts = await _client.Client4.getPostsUnread(channelId, userId);
      getProfilesAndStatusesForPosts(posts.posts, dispatch, getState);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([receivedPosts(posts), receivedPostsInChannel(posts, channelId, posts.next_post_id === '')]));
    dispatch({
      type: _action_types.PostTypes.RECEIVED_POSTS,
      data: posts,
      channelId
    });
    return {
      data: posts
    };
  };
}

function getPostsSince(channelId, since) {
  return async (dispatch, getState) => {
    let posts;

    try {
      posts = await _client.Client4.getPostsSince(channelId, since);
      getProfilesAndStatusesForPosts(posts.posts, dispatch, getState);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([receivedPosts(posts), receivedPostsSince(posts, channelId), {
      type: _action_types.PostTypes.GET_POSTS_SINCE_SUCCESS
    }]));
    return {
      data: posts
    };
  };
}

function getPostsBefore(channelId, postId, page = 0, perPage = _constants.Posts.POST_CHUNK_SIZE) {
  return async (dispatch, getState) => {
    let posts;

    try {
      posts = await _client.Client4.getPostsBefore(channelId, postId, page, perPage);
      getProfilesAndStatusesForPosts(posts.posts, dispatch, getState);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([receivedPosts(posts), receivedPostsBefore(posts, channelId, postId)]));
    return {
      data: posts
    };
  };
}

function getPostsAfter(channelId, postId, page = 0, perPage = _constants.Posts.POST_CHUNK_SIZE) {
  return async (dispatch, getState) => {
    let posts;

    try {
      posts = await _client.Client4.getPostsAfter(channelId, postId, page, perPage);
      getProfilesAndStatusesForPosts(posts.posts, dispatch, getState);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([receivedPosts(posts), receivedPostsAfter(posts, channelId, postId, posts.next_post_id === '')]));
    return {
      data: posts
    };
  };
}

function getPostsAround(channelId, postId, perPage = _constants.Posts.POST_CHUNK_SIZE / 2) {
  return async (dispatch, getState) => {
    let after;
    let thread;
    let before;

    try {
      [after, thread, before] = await Promise.all([_client.Client4.getPostsAfter(channelId, postId, 0, perPage), _client.Client4.getPostThread(postId), _client.Client4.getPostsBefore(channelId, postId, 0, perPage)]);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    } // Dispatch a combined post list so that the order is correct for postsInChannel


    const posts = {
      posts: _objectSpread({}, after.posts, {}, thread.posts, {}, before.posts),
      order: [// Remember that the order is newest posts first
      ...after.order, postId, ...before.order],
      next_post_id: after.next_post_id,
      before_post_id: before.before_post_id
    };
    getProfilesAndStatusesForPosts(posts.posts, dispatch, getState);
    dispatch((0, _reduxBatchedActions.batchActions)([receivedPosts(posts), receivedPostsInChannel(posts, channelId, after.posts.next_post_id === '')]));
    return {
      data: posts
    };
  };
} // getThreadsForPosts is intended for an array of posts that have been batched
// (see the actions/websocket_actions/handleNewPostEvents function in the webapp)


function getThreadsForPosts(posts) {
  return (dispatch, getState) => {
    if (!Array.isArray(posts) || !posts.length) {
      return {
        data: true
      };
    }

    const state = getState();
    const promises = [];
    posts.forEach(post => {
      if (!post.root_id) {
        return;
      }

      const rootPost = Selectors.getPost(state, post.root_id);

      if (!rootPost) {
        promises.push(dispatch(getPostThread(post.root_id)));
      }
    });
    return Promise.all(promises);
  };
} // Note that getProfilesAndStatusesForPosts can take either an array of posts or a map of ids to posts


function getProfilesAndStatusesForPosts(postsArrayOrMap, dispatch, getState) {
  if (!postsArrayOrMap) {
    // Some API methods return {error} for no results
    return Promise.resolve();
  }

  const posts = Object.values(postsArrayOrMap);

  if (posts.length === 0) {
    return Promise.resolve();
  }

  const state = getState();
  const {
    currentUserId,
    profiles,
    statuses
  } = state.entities.users; // Statuses and profiles of the users who made the posts

  const userIdsToLoad = new Set();
  const statusesToLoad = new Set();
  Object.values(posts).forEach(post => {
    const userId = post.user_id;

    if (!statuses[userId]) {
      statusesToLoad.add(userId);
    }

    if (userId === currentUserId) {
      return;
    }

    if (!profiles[userId]) {
      userIdsToLoad.add(userId);
    }
  });
  const promises = [];

  if (userIdsToLoad.size > 0) {
    promises.push((0, _users2.getProfilesByIds)(Array.from(userIdsToLoad))(dispatch, getState));
  }

  if (statusesToLoad.size > 0) {
    promises.push((0, _users2.getStatusesByIds)(Array.from(statusesToLoad))(dispatch, getState));
  } // Profiles of users mentioned in the posts


  const usernamesToLoad = getNeededAtMentionedUsernames(state, posts);

  if (usernamesToLoad.size > 0) {
    promises.push((0, _users2.getProfilesByUsernames)(Array.from(usernamesToLoad))(dispatch, getState));
  } // Emojis used in the posts


  const emojisToLoad = getNeededCustomEmojis(state, posts);

  if (emojisToLoad && emojisToLoad.size > 0) {
    promises.push((0, _emojis2.getCustomEmojisByName)(Array.from(emojisToLoad))(dispatch, getState));
  }

  return Promise.all(promises);
}

function getNeededAtMentionedUsernames(state, posts) {
  let usersByUsername; // Populate this lazily since it's relatively expensive

  const usernamesToLoad = new Set();
  posts.forEach(post => {
    if (!post.message.includes('@')) {
      return;
    }

    if (!usersByUsername) {
      usersByUsername = (0, _users.getUsersByUsername)(state);
    }

    const pattern = /\B@(([a-z0-9_.-]*[a-z0-9_])[.-]*)/gi;
    let match;

    while ((match = pattern.exec(post.message)) !== null) {
      // match[1] is the matched mention including trailing punctuation
      // match[2] is the matched mention without trailing punctuation
      if (_constants.General.SPECIAL_MENTIONS.indexOf(match[2]) !== -1) {
        continue;
      }

      if (usersByUsername[match[1]] || usersByUsername[match[2]]) {
        // We have the user, go to the next match
        continue;
      } // If there's no trailing punctuation, this will only add 1 item to the set


      usernamesToLoad.add(match[1]);
      usernamesToLoad.add(match[2]);
    }
  });
  return usernamesToLoad;
}

function buildPostAttachmentText(attachments) {
  let attachmentText = '';
  attachments.forEach(a => {
    if (a.fields && a.fields.length) {
      a.fields.forEach(f => {
        attachmentText += ' ' + (f.value || '');
      });
    }

    if (a.pretext) {
      attachmentText += ' ' + a.pretext;
    }

    if (a.text) {
      attachmentText += ' ' + a.text;
    }
  });
  return attachmentText;
}

function getNeededCustomEmojis(state, posts) {
  if ((0, _general.getConfig)(state).EnableCustomEmoji !== 'true') {
    return new Set();
  } // If post metadata is supported, custom emojis will have been provided as part of that


  if (posts[0].metadata) {
    return new Set();
  }

  let customEmojisToLoad = new Set();
  let customEmojisByName; // Populate this lazily since it's relatively expensive

  const nonExistentEmoji = state.entities.emojis.nonExistentEmoji;
  posts.forEach(post => {
    if (post.message.includes(':')) {
      if (!customEmojisByName) {
        customEmojisByName = (0, _emojis.getCustomEmojisByName)(state);
      }

      const emojisFromPost = (0, _emoji_utils.parseNeededCustomEmojisFromText)(post.message, _emojis2.systemEmojis, customEmojisByName, nonExistentEmoji);

      if (emojisFromPost.size > 0) {
        customEmojisToLoad = new Set([...customEmojisToLoad, ...emojisFromPost]);
      }
    }

    const props = post.props;

    if (props && props.attachments && props.attachments.length) {
      if (!customEmojisByName) {
        customEmojisByName = (0, _emojis.getCustomEmojisByName)(state);
      }

      const attachmentText = buildPostAttachmentText(props.attachments);

      if (attachmentText) {
        const emojisFromAttachment = (0, _emoji_utils.parseNeededCustomEmojisFromText)(attachmentText, _emojis2.systemEmojis, customEmojisByName, nonExistentEmoji);

        if (emojisFromAttachment.size > 0) {
          customEmojisToLoad = new Set([...customEmojisToLoad, ...emojisFromAttachment]);
        }
      }
    }
  });
  return customEmojisToLoad;
}

function removePost(post) {
  return (dispatch, getState) => {
    if (post.type === _constants.Posts.POST_TYPES.COMBINED_USER_ACTIVITY) {
      const state = getState();

      for (const systemPostId of post.system_post_ids) {
        const systemPost = Selectors.getPost(state, systemPostId);

        if (systemPost) {
          dispatch(removePost(systemPost));
        }
      }
    } else {
      dispatch(postRemoved(post));
    }
  };
}

function selectPost(postId) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.PostTypes.RECEIVED_POST_SELECTED,
      data: postId
    }, getState);
    return {
      data: true
    };
  };
}

function selectFocusedPostId(postId) {
  return {
    type: _action_types.PostTypes.RECEIVED_FOCUSED_POST,
    data: postId
  };
}

function unflagPost(postId) {
  return async (dispatch, getState) => {
    const {
      currentUserId
    } = getState().entities.users;
    const preference = {
      user_id: currentUserId,
      category: _constants.Preferences.CATEGORY_FLAGGED_POST,
      name: postId
    };

    _client.Client4.trackEvent('action', 'action_posts_unflag');

    return (0, _preferences.deletePreferences)(currentUserId, [preference])(dispatch, getState);
  };
}

function getOpenGraphMetadata(url) {
  return async (dispatch, getState) => {
    let data;

    try {
      data = await _client.Client4.getOpenGraphMetadata(url);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    if (data && (data.url || data.type || data.title || data.description)) {
      dispatch({
        type: _action_types.PostTypes.RECEIVED_OPEN_GRAPH_METADATA,
        data,
        url
      });
    }

    return {
      data
    };
  };
}

function doPostAction(postId, actionId, selectedOption = '') {
  return doPostActionWithCookie(postId, actionId, '', selectedOption);
}

function doPostActionWithCookie(postId, actionId, actionCookie, selectedOption = '') {
  return async (dispatch, getState) => {
    let data;

    try {
      data = await _client.Client4.doPostActionWithCookie(postId, actionId, actionCookie, selectedOption);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    if (data && data.trigger_id) {
      dispatch({
        type: _action_types.IntegrationTypes.RECEIVED_DIALOG_TRIGGER_ID,
        data: data.trigger_id
      });
    }

    return {
      data
    };
  };
}

function addMessageIntoHistory(message) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.PostTypes.ADD_MESSAGE_INTO_HISTORY,
      data: message
    }, getState);
    return {
      data: true
    };
  };
}

function resetHistoryIndex(index) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.PostTypes.RESET_HISTORY_INDEX,
      data: index
    }, getState);
    return {
      data: true
    };
  };
}

function moveHistoryIndexBack(index) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.PostTypes.MOVE_HISTORY_INDEX_BACK,
      data: index
    }, getState);
    return {
      data: true
    };
  };
}

function moveHistoryIndexForward(index) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.PostTypes.MOVE_HISTORY_INDEX_FORWARD,
      data: index
    }, getState);
    return {
      data: true
    };
  };
}

function handleNewPost(msg) {
  return async (dispatch, getState) => {
    const state = getState();
    const currentUserId = (0, _users.getCurrentUserId)(state);
    const post = JSON.parse(msg.data.post);
    const myChannelMember = (0, _channels.getMyChannelMember)(state, post.channel_id);
    const websocketMessageProps = msg.data;

    if (myChannelMember && Object.keys(myChannelMember).length === 0 && myChannelMember.constructor === 'Object') {
      await dispatch((0, _channels2.getMyChannelMember)(post.channel_id));
    }

    dispatch(completePostReceive(post, websocketMessageProps));

    if (msg.data.channel_type === _constants.General.DM_CHANNEL) {
      const otherUserId = (0, _channel_utils.getUserIdFromChannelName)(currentUserId, msg.data.channel_name);
      dispatch((0, _preferences.makeDirectChannelVisibleIfNecessary)(otherUserId));
    } else if (msg.data.channel_type === _constants.General.GM_CHANNEL) {
      dispatch((0, _preferences.makeGroupMessageVisibleIfNecessary)(post.channel_id));
    }
  };
}

function completePostReceive(post, websocketMessageProps) {
  return (dispatch, getState) => {
    const state = getState();
    const rootPost = Selectors.getPost(state, post.root_id);

    if (post.root_id && !rootPost) {
      dispatch(getPostThread(post.root_id));
    }

    dispatch(lastPostActions(post, websocketMessageProps));
  };
}

function lastPostActions(post, websocketMessageProps) {
  return async (dispatch, getState) => {
    const state = getState();
    const actions = [receivedNewPost(post), {
      type: _constants.WebsocketEvents.STOP_TYPING,
      data: {
        id: post.channel_id + post.root_id,
        userId: post.user_id,
        now: Date.now()
      }
    }];
    dispatch((0, _reduxBatchedActions.batchActions)(actions));

    if ((0, _post_utils.shouldIgnorePost)(post)) {
      return;
    }

    let markAsRead = false;
    let markAsReadOnServer = false;

    if (post.user_id === (0, _users.getCurrentUserId)(state) && !(0, _post_utils.isSystemMessage)(post) && !(0, _post_utils.isFromWebhook)(post)) {
      markAsRead = true;
      markAsReadOnServer = false;
    } else if (post.channel_id === (0, _channels.getCurrentChannelId)(state)) {
      markAsRead = true;
      markAsReadOnServer = true;
    }

    if (markAsRead) {
      dispatch((0, _channels2.markChannelAsRead)(post.channel_id, null, markAsReadOnServer));
      dispatch((0, _channels2.markChannelAsViewed)(post.channel_id));
    } else {
      dispatch((0, _channels2.markChannelAsUnread)(websocketMessageProps.team_id, post.channel_id, websocketMessageProps.mentions));
    }
  };
}