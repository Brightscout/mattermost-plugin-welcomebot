"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.close = close;
exports.doFirstConnect = doFirstConnect;
exports.doReconnect = doReconnect;
exports.userTyping = userTyping;

var _client = require("../client");

var _websocket_client = _interopRequireDefault(require("../client/websocket_client"));

var _users = require("./users");

var _channels = require("./channels");

var _posts = require("./posts");

var _teams = require("./teams");

var _action_types = require("../action_types");

var _constants = require("../constants");

var _channels2 = require("../selectors/entities/channels");

var _general = require("../selectors/entities/general");

var _posts2 = require("../selectors/entities/posts");

var _preferences = require("../selectors/entities/preferences");

var _teams2 = require("../selectors/entities/teams");

var _users2 = require("../selectors/entities/users");

var _channel_utils = require("../utils/channel_utils");

var _post_utils = require("../utils/post_utils");

var _event_emitter = _interopRequireDefault(require("../utils/event_emitter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

let doDispatch;

function init(platform
/*: PlatformType*/
, siteUrl
/*: ?string*/
, token
/*: ?string*/
, optionalWebSocket
/*: Object*/
, additionalOptions
/*: Object*/
= {}) {
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const config = (0, _general.getConfig)(getState());

    let connUrl = siteUrl || config.WebsocketURL || _client.Client4.getUrl();

    const authToken = token || _client.Client4.getToken(); // Set the dispatch and getState globally


    doDispatch = dispatch; // replace the protocol with a websocket one

    if (platform !== 'ios' && platform !== 'android') {
      if (connUrl.startsWith('https:')) {
        connUrl = connUrl.replace(/^https:/, 'wss:');
      } else {
        connUrl = connUrl.replace(/^http:/, 'ws:');
      } // append a port number if one isn't already specified


      if (!/:\d+$/.test(connUrl)) {
        if (connUrl.startsWith('wss:')) {
          connUrl += ':' + (config.WebsocketSecurePort || 443);
        } else {
          connUrl += ':' + (config.WebsocketPort || 80);
        }
      }
    }

    connUrl += "".concat(_client.Client4.getUrlVersion(), "/websocket");

    _websocket_client.default.setFirstConnectCallback(handleFirstConnect);

    _websocket_client.default.setEventCallback(handleEvent);

    _websocket_client.default.setReconnectCallback(handleReconnect);

    _websocket_client.default.setCloseCallback(handleClose);

    _websocket_client.default.setConnectingCallback(handleConnecting);

    const websocketOpts = _objectSpread({
      connectionUrl: connUrl,
      platform
    }, additionalOptions);

    if (optionalWebSocket) {
      websocketOpts.webSocketConnector = optionalWebSocket;
    }

    return _websocket_client.default.initialize(authToken, websocketOpts);
  };
}

let reconnect = false;

function close(shouldReconnect
/*: boolean*/
= false) {
  return async (dispatch
  /*: DispatchFunc*/
  ) => {
    reconnect = shouldReconnect;

    _websocket_client.default.close(true);

    if (dispatch) {
      dispatch({
        type: _action_types.GeneralTypes.WEBSOCKET_CLOSED,
        timestamp: Date.now(),
        data: null
      });
    }
  };
}

function doFirstConnect(now
/*: number*/
) {
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();

    if (state.websocket.lastDisconnectAt) {
      dispatch((0, _users.checkForModifiedUsers)());
    }

    dispatch({
      type: _action_types.GeneralTypes.WEBSOCKET_SUCCESS,
      timestamp: now,
      data: null
    });
    return {
      data: true
    };
  };
}

function doReconnect(now
/*: number*/
) {
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const currentTeamId = (0, _teams2.getCurrentTeamId)(state);
    const currentChannelId = (0, _channels2.getCurrentChannelId)(state);
    const currentUserId = (0, _users2.getCurrentUserId)(state);

    if (currentTeamId) {
      const dmPrefs = (0, _preferences.getDirectShowPreferences)(state);
      const statusesToLoad = {
        [currentUserId]: true
      };

      for (const pref of dmPrefs) {
        if (pref.value === 'true') {
          statusesToLoad[pref.name] = true;
        }
      }

      dispatch((0, _users.getStatusesByIds)(Object.keys(statusesToLoad)));
      dispatch((0, _teams.getMyTeamUnreads)()); // We need to wait for these actions so that we have an
      // up-to-date state of the current user's team memberships.

      await dispatch((0, _teams.getMyTeams)());
      await dispatch((0, _teams.getMyTeamMembers)());
      const currentTeamMembership = (0, _teams2.getCurrentTeamMembership)(getState());

      if (currentTeamMembership) {
        dispatch((0, _posts.getPosts)(currentChannelId));
        const fethcResult = await dispatch((0, _channels.fetchMyChannelsAndMembers)(currentTeamId));
        const data = fethcResult.data || null;
        dispatch((0, _users.loadProfilesForDirect)());

        if (data && data.members) {
          const stillMemberOfCurrentChannel = data.members.find(m => m.channel_id === currentChannelId);

          if (!stillMemberOfCurrentChannel) {
            _event_emitter.default.emit(_constants.General.SWITCH_TO_DEFAULT_CHANNEL, currentTeamId);
          }
        }
      } else {
        // If the user is no longer a member of this team when reconnecting
        const newMsg = {
          data: {
            user_id: currentUserId,
            team_id: currentTeamId
          }
        };
        dispatch(handleLeaveTeamEvent(newMsg));
      }
    }

    dispatch((0, _users.checkForModifiedUsers)());
    dispatch({
      type: _action_types.GeneralTypes.WEBSOCKET_SUCCESS,
      timestamp: now,
      data: null
    });
    return {
      data: true
    };
  };
}

function handleConnecting() {
  doDispatch({
    type: _action_types.GeneralTypes.WEBSOCKET_REQUEST,
    data: null
  });
}

function handleFirstConnect() {
  const now = Date.now();

  if (reconnect) {
    reconnect = false;
    doDispatch(doReconnect(now));
  } else {
    doDispatch(doFirstConnect(now));
  }
}

function handleReconnect() {
  doDispatch(doReconnect(Date.now()));
}

function handleClose(connectFailCount) {
  doDispatch({
    type: _action_types.GeneralTypes.WEBSOCKET_FAILURE,
    error: connectFailCount,
    data: null,
    timestamp: Date.now()
  });
}

function handleEvent(msg) {
  switch (msg.event) {
    case _constants.WebsocketEvents.POSTED:
    case _constants.WebsocketEvents.EPHEMERAL_MESSAGE:
      doDispatch(handleNewPostEvent(msg));
      break;

    case _constants.WebsocketEvents.POST_EDITED:
      doDispatch(handlePostEdited(msg));
      break;

    case _constants.WebsocketEvents.POST_DELETED:
      doDispatch(handlePostDeleted(msg));
      break;

    case _constants.WebsocketEvents.LEAVE_TEAM:
      doDispatch(handleLeaveTeamEvent(msg));
      break;

    case _constants.WebsocketEvents.UPDATE_TEAM:
      doDispatch(handleUpdateTeamEvent(msg));
      break;

    case _constants.WebsocketEvents.ADDED_TO_TEAM:
      doDispatch(handleTeamAddedEvent(msg));
      break;

    case _constants.WebsocketEvents.USER_ADDED:
      doDispatch(handleUserAddedEvent(msg));
      break;

    case _constants.WebsocketEvents.USER_REMOVED:
      doDispatch(handleUserRemovedEvent(msg));
      break;

    case _constants.WebsocketEvents.USER_UPDATED:
      doDispatch(handleUserUpdatedEvent(msg));
      break;

    case _constants.WebsocketEvents.ROLE_ADDED:
      doDispatch(handleRoleAddedEvent(msg));
      break;

    case _constants.WebsocketEvents.ROLE_REMOVED:
      doDispatch(handleRoleRemovedEvent(msg));
      break;

    case _constants.WebsocketEvents.ROLE_UPDATED:
      doDispatch(handleRoleUpdatedEvent(msg));
      break;

    case _constants.WebsocketEvents.CHANNEL_CREATED:
      doDispatch(handleChannelCreatedEvent(msg));
      break;

    case _constants.WebsocketEvents.CHANNEL_DELETED:
      doDispatch(handleChannelDeletedEvent(msg));
      break;

    case _constants.WebsocketEvents.CHANNEL_UPDATED:
      doDispatch(handleChannelUpdatedEvent(msg));
      break;

    case _constants.WebsocketEvents.CHANNEL_CONVERTED:
      doDispatch(handleChannelConvertedEvent(msg));
      break;

    case _constants.WebsocketEvents.CHANNEL_VIEWED:
      doDispatch(handleChannelViewedEvent(msg));
      break;

    case _constants.WebsocketEvents.CHANNEL_MEMBER_UPDATED:
      doDispatch(handleChannelMemberUpdatedEvent(msg));
      break;

    case _constants.WebsocketEvents.DIRECT_ADDED:
      doDispatch(handleDirectAddedEvent(msg));
      break;

    case _constants.WebsocketEvents.PREFERENCE_CHANGED:
      doDispatch(handlePreferenceChangedEvent(msg));
      break;

    case _constants.WebsocketEvents.PREFERENCES_CHANGED:
      doDispatch(handlePreferencesChangedEvent(msg));
      break;

    case _constants.WebsocketEvents.PREFERENCES_DELETED:
      doDispatch(handlePreferencesDeletedEvent(msg));
      break;

    case _constants.WebsocketEvents.STATUS_CHANGED:
      doDispatch(handleStatusChangedEvent(msg));
      break;

    case _constants.WebsocketEvents.TYPING:
      doDispatch(handleUserTypingEvent(msg));
      break;

    case _constants.WebsocketEvents.HELLO:
      handleHelloEvent(msg);
      break;

    case _constants.WebsocketEvents.REACTION_ADDED:
      doDispatch(handleReactionAddedEvent(msg));
      break;

    case _constants.WebsocketEvents.REACTION_REMOVED:
      doDispatch(handleReactionRemovedEvent(msg));
      break;

    case _constants.WebsocketEvents.EMOJI_ADDED:
      doDispatch(handleAddEmoji(msg));
      break;

    case _constants.WebsocketEvents.LICENSE_CHANGED:
      doDispatch(handleLicenseChangedEvent(msg));
      break;

    case _constants.WebsocketEvents.CONFIG_CHANGED:
      doDispatch(handleConfigChangedEvent(msg));
      break;

    case _constants.WebsocketEvents.PLUGIN_STATUSES_CHANGED:
      doDispatch(handlePluginStatusesChangedEvent(msg));
      break;

    case _constants.WebsocketEvents.OPEN_DIALOG:
      doDispatch(handleOpenDialogEvent(msg));
      break;
  }
}

function handleNewPostEvent(msg) {
  return (dispatch, getState) => {
    const post = JSON.parse(msg.data.post);
    dispatch((0, _posts.handleNewPost)(msg));
    (0, _posts.getProfilesAndStatusesForPosts)([post], dispatch, getState);

    if (post.user_id !== (0, _users2.getCurrentUserId)(getState()) && !(0, _post_utils.fromAutoResponder)(post)) {
      dispatch({
        type: _action_types.UserTypes.RECEIVED_STATUSES,
        data: [{
          user_id: post.user_id,
          status: _constants.General.ONLINE
        }]
      });
    }

    return {
      data: true
    };
  };
}

function handlePostEdited(msg) {
  return (dispatch, getState) => {
    const data = JSON.parse(msg.data.post);
    (0, _posts.getProfilesAndStatusesForPosts)([data], dispatch, getState);
    dispatch((0, _posts.receivedPost)(data));
    return {
      data: true
    };
  };
}

function handlePostDeleted(msg) {
  const data = JSON.parse(msg.data.post);
  return (0, _posts.postDeleted)(data);
}

function handleLeaveTeamEvent(msg) {
  return (dispatch, getState) => {
    const state = getState();
    const teams = (0, _teams2.getTeams)(state);
    const currentTeamId = (0, _teams2.getCurrentTeamId)(state);
    const currentUserId = (0, _users2.getCurrentUserId)(state);

    if (currentUserId === msg.data.user_id) {
      dispatch({
        type: _action_types.TeamTypes.LEAVE_TEAM,
        data: teams[msg.data.team_id]
      }); // if they are on the team being removed deselect the current team and channel

      if (currentTeamId === msg.data.team_id) {
        _event_emitter.default.emit('leave_team');
      }
    }

    return {
      data: true
    };
  };
}

function handleUpdateTeamEvent(msg) {
  return {
    type: _action_types.TeamTypes.UPDATED_TEAM,
    data: JSON.parse(msg.data.team)
  };
}

function handleTeamAddedEvent(msg) {
  return async dispatch => {
    await Promise.all([dispatch((0, _teams.getTeam)(msg.data.team_id)), dispatch((0, _teams.getMyTeamUnreads)())]);
    return {
      data: true
    };
  };
}

function handleUserAddedEvent(msg) {
  return (dispatch, getState) => {
    const state = getState();
    const currentChannelId = (0, _channels2.getCurrentChannelId)(state);
    const currentTeamId = (0, _teams2.getCurrentTeamId)(state);
    const currentUserId = (0, _users2.getCurrentUserId)(state);
    const teamId = msg.data.team_id;
    dispatch({
      type: _action_types.ChannelTypes.CHANNEL_MEMBER_ADDED,
      data: {
        channel_id: msg.broadcast.channel_id,
        user_id: msg.data.user_id
      }
    }, getState);

    if (msg.broadcast.channel_id === currentChannelId) {
      dispatch((0, _channels.getChannelStats)(currentChannelId));
    }

    if (teamId === currentTeamId && msg.data.user_id === currentUserId) {
      dispatch((0, _channels.getChannelAndMyMember)(msg.broadcast.channel_id));
    }

    return {
      data: true
    };
  };
}

function handleUserRemovedEvent(msg) {
  return (dispatch, getState) => {
    const state = getState();
    const channels = (0, _channels2.getAllChannels)(state);
    const currentChannelId = (0, _channels2.getCurrentChannelId)(state);
    const currentTeamId = (0, _teams2.getCurrentTeamId)(state);
    const currentUserId = (0, _users2.getCurrentUserId)(state);
    dispatch({
      type: _action_types.ChannelTypes.CHANNEL_MEMBER_REMOVED,
      data: {
        channel_id: msg.broadcast.channel_id,
        user_id: msg.data.user_id
      }
    }, getState);

    if (msg.broadcast.user_id === currentUserId && currentTeamId) {
      const channel = channels[currentChannelId];
      dispatch((0, _channels.fetchMyChannelsAndMembers)(currentTeamId));

      if (channel) {
        dispatch({
          type: _action_types.ChannelTypes.LEAVE_CHANNEL,
          data: {
            id: msg.data.channel_id,
            user_id: currentUserId,
            team_id: channel.team_id,
            type: channel.type
          }
        });
      }

      if (msg.data.channel_id === currentChannelId) {
        // emit the event so the client can change his own state
        _event_emitter.default.emit(_constants.General.SWITCH_TO_DEFAULT_CHANNEL, currentTeamId);
      }
    } else if (msg.data.channel_id === currentChannelId) {
      dispatch((0, _channels.getChannelStats)(currentChannelId));
    }

    return {
      data: true
    };
  };
}

function handleUserUpdatedEvent(msg) {
  return (dispatch, getState) => {
    const currentUser = (0, _users2.getCurrentUser)(getState());
    const user = msg.data.user;

    if (user.id === currentUser.id) {
      if (user.update_at > currentUser.update_at) {
        // Need to request me to make sure we don't override with sanitized fields from the
        // websocket event
        dispatch((0, _users.getMe)());
      }
    } else {
      dispatch({
        type: _action_types.UserTypes.RECEIVED_PROFILES,
        data: {
          [user.id]: user
        }
      });
    }

    return {
      data: true
    };
  };
}

function handleRoleAddedEvent(msg) {
  const role = JSON.parse(msg.data.role);
  return {
    type: _action_types.RoleTypes.RECEIVED_ROLE,
    data: role
  };
}

function handleRoleRemovedEvent(msg) {
  const role = JSON.parse(msg.data.role);
  return {
    type: _action_types.RoleTypes.ROLE_DELETED,
    data: role
  };
}

function handleRoleUpdatedEvent(msg) {
  const role = JSON.parse(msg.data.role);
  return {
    type: _action_types.RoleTypes.RECEIVED_ROLE,
    data: role
  };
}

function handleChannelCreatedEvent(msg) {
  return (dispatch, getState) => {
    const {
      channel_id: channelId,
      team_id: teamId
    } = msg.data;
    const state = getState();
    const channels = (0, _channels2.getAllChannels)(state);
    const currentTeamId = (0, _teams2.getCurrentTeamId)(state);

    if (teamId === currentTeamId && !channels[channelId]) {
      dispatch((0, _channels.getChannelAndMyMember)(channelId));
    }

    return {
      data: true
    };
  };
}

function handleChannelDeletedEvent(msg) {
  return (dispatch, getState) => {
    const state = getState();
    const currentChannelId = (0, _channels2.getCurrentChannelId)(state);
    const currentTeamId = (0, _teams2.getCurrentTeamId)(state);
    const config = (0, _general.getConfig)(state);
    const viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';

    if (msg.broadcast.team_id === currentTeamId) {
      if (msg.data.channel_id === currentChannelId && !viewArchivedChannels) {
        const channelsInTeam = (0, _channels2.getChannelsNameMapInTeam)(state, currentTeamId);
        const channel = (0, _channel_utils.getChannelByName)(channelsInTeam, (0, _channels2.getRedirectChannelNameForTeam)(state, currentTeamId));

        if (channel && channel.id) {
          dispatch({
            type: _action_types.ChannelTypes.SELECT_CHANNEL,
            data: channel.id
          });
        }

        _event_emitter.default.emit(_constants.General.DEFAULT_CHANNEL, '');
      }

      dispatch({
        type: _action_types.ChannelTypes.RECEIVED_CHANNEL_DELETED,
        data: {
          id: msg.data.channel_id,
          team_id: msg.data.team_id,
          deleteAt: msg.data.delete_at,
          viewArchivedChannels
        }
      }, getState);
      dispatch((0, _channels.fetchMyChannelsAndMembers)(currentTeamId));
    }

    return {
      data: true
    };
  };
}

function handleChannelUpdatedEvent(msg) {
  return async (dispatch, getState) => {
    let channel;

    try {
      channel = msg.data ? JSON.parse(msg.data.channel) : null;
    } catch (err) {
      return {
        error: err
      };
    }

    const currentChannelId = (0, _channels2.getCurrentChannelId)(getState());

    if (channel) {
      dispatch({
        type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
        data: channel
      });

      if (currentChannelId === channel.id) {
        // Emit an event with the channel received as we need to handle
        // the changes without listening to the store
        _event_emitter.default.emit(_constants.WebsocketEvents.CHANNEL_UPDATED, channel);
      }
    }

    return {
      data: true
    };
  };
} // handleChannelConvertedEvent handles updating of channel which is converted from public to private


function handleChannelConvertedEvent(msg) {
  return (dispatch, getState) => {
    const channelId = msg.data.channel_id;

    if (channelId) {
      const channel = (0, _channels2.getChannel)(getState(), channelId);

      if (channel) {
        dispatch({
          type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
          data: _objectSpread({}, channel, {
            type: _constants.General.PRIVATE_CHANNEL
          })
        });
      }
    }

    return {
      data: true
    };
  };
}

function handleChannelViewedEvent(msg) {
  return (dispatch, getState) => {
    const state = getState();
    const {
      channel_id: channelId
    } = msg.data;
    const currentChannelId = (0, _channels2.getCurrentChannelId)(state);
    const currentUserId = (0, _users2.getCurrentUserId)(state);

    if (channelId !== currentChannelId && currentUserId === msg.broadcast.user_id) {
      dispatch((0, _channels.markChannelAsRead)(channelId, null, false));
    }

    return {
      data: true
    };
  };
}

function handleChannelMemberUpdatedEvent(msg) {
  const channelMember = JSON.parse(msg.data.channelMember);
  return {
    type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
    data: channelMember
  };
}

function handleDirectAddedEvent(msg) {
  return dispatch => {
    dispatch((0, _channels.getChannelAndMyMember)(msg.broadcast.channel_id));
    return {
      data: true
    };
  };
}

function handlePreferenceChangedEvent(msg) {
  return dispatch => {
    const preference = JSON.parse(msg.data.preference);
    dispatch({
      type: _action_types.PreferenceTypes.RECEIVED_PREFERENCES,
      data: [preference]
    });
    dispatch(getAddedDmUsersIfNecessary([preference]));
    return {
      data: true
    };
  };
}

function handlePreferencesChangedEvent(msg) {
  return (dispatch, getState) => {
    const preferences = JSON.parse(msg.data.preferences);
    const posts = (0, _posts2.getAllPosts)(getState());
    preferences.forEach(pref => {
      if (pref.category === _constants.Preferences.CATEGORY_FLAGGED_POST && !posts[pref.name]) {
        dispatch((0, _posts.getPost)(pref.name));
      }
    });
    dispatch(getAddedDmUsersIfNecessary(preferences));
    dispatch({
      type: _action_types.PreferenceTypes.RECEIVED_PREFERENCES,
      data: preferences
    });
    return {
      data: true
    };
  };
}

function handlePreferencesDeletedEvent(msg) {
  const preferences = JSON.parse(msg.data.preferences);
  return {
    type: _action_types.PreferenceTypes.DELETED_PREFERENCES,
    data: preferences
  };
}

function handleStatusChangedEvent(msg) {
  return {
    type: _action_types.UserTypes.RECEIVED_STATUSES,
    data: [{
      user_id: msg.data.user_id,
      status: msg.data.status
    }]
  };
}

function handleHelloEvent(msg) {
  const serverVersion = msg.data.server_version;

  if (serverVersion && _client.Client4.serverVersion !== serverVersion) {
    _client.Client4.serverVersion = serverVersion;

    _event_emitter.default.emit(_constants.General.SERVER_VERSION_CHANGED, serverVersion);
  }
}

function handleUserTypingEvent(msg) {
  return (dispatch, getState) => {
    const state = getState();
    const profiles = (0, _users2.getUsers)(state);
    const statuses = (0, _users2.getUserStatuses)(state);
    const currentUserId = (0, _users2.getCurrentUserId)(state);
    const config = (0, _general.getConfig)(state);
    const userId = msg.data.user_id;
    const data = {
      id: msg.broadcast.channel_id + msg.data.parent_id,
      userId,
      now: Date.now()
    };
    dispatch({
      type: _constants.WebsocketEvents.TYPING,
      data
    });
    setTimeout(() => {
      dispatch({
        type: _constants.WebsocketEvents.STOP_TYPING,
        data
      });
    }, parseInt(config.TimeBetweenUserTypingUpdatesMilliseconds, 10));

    if (!profiles[userId] && userId !== currentUserId) {
      dispatch((0, _users.getProfilesByIds)([userId]));
    }

    const status = statuses[userId];

    if (status !== _constants.General.ONLINE) {
      dispatch((0, _users.getStatusesByIds)([userId]));
    }

    return {
      data: true
    };
  };
}

function handleReactionAddedEvent(msg) {
  return dispatch => {
    const {
      data
    } = msg;
    const reaction = JSON.parse(data.reaction);
    dispatch((0, _posts.getCustomEmojiForReaction)(reaction.emoji_name));
    dispatch({
      type: _action_types.PostTypes.RECEIVED_REACTION,
      data: reaction
    });
    return {
      data: true
    };
  };
}

function handleReactionRemovedEvent(msg) {
  const {
    data
  } = msg;
  const reaction = JSON.parse(data.reaction);
  return {
    type: _action_types.PostTypes.REACTION_DELETED,
    data: reaction
  };
}

function handleAddEmoji(msg) {
  const data = JSON.parse(msg.data.emoji);
  return {
    type: _action_types.EmojiTypes.RECEIVED_CUSTOM_EMOJI,
    data
  };
}

function handleLicenseChangedEvent(msg) {
  const data = msg.data.license;
  return {
    type: _action_types.GeneralTypes.CLIENT_LICENSE_RECEIVED,
    data
  };
}

function handleConfigChangedEvent(msg) {
  const data = msg.data.config;

  _event_emitter.default.emit(_constants.General.CONFIG_CHANGED, data);

  return {
    type: _action_types.GeneralTypes.CLIENT_CONFIG_RECEIVED,
    data
  };
}

function handlePluginStatusesChangedEvent(msg) {
  const data = msg.data;
  return {
    type: _action_types.AdminTypes.RECEIVED_PLUGIN_STATUSES,
    data: data.plugin_statuses
  };
}

function handleOpenDialogEvent(msg) {
  return dispatch => {
    const data = msg.data && msg.data.dialog || {};
    dispatch({
      type: _action_types.IntegrationTypes.RECEIVED_DIALOG,
      data: JSON.parse(data)
    });
    return {
      data: true
    };
  };
} // Helpers


function getAddedDmUsersIfNecessary(preferences) {
  return (dispatch, getState) => {
    const userIds = [];

    for (const preference of preferences) {
      if (preference.category === _constants.Preferences.CATEGORY_DIRECT_CHANNEL_SHOW && preference.value === 'true') {
        userIds.push(preference.name);
      }
    }

    if (userIds.length === 0) {
      return {
        data: true
      };
    }

    const state = getState();
    const profiles = (0, _users2.getUsers)(state);
    const statuses = (0, _users2.getUserStatuses)(state);
    const currentUserId = (0, _users2.getCurrentUserId)(state);
    const needProfiles = [];
    const needStatuses = [];

    for (const userId of userIds) {
      if (!profiles[userId] && userId !== currentUserId) {
        needProfiles.push(userId);
      }

      if (statuses[userId] !== _constants.General.ONLINE) {
        needStatuses.push(userId);
      }
    }

    if (needProfiles.length > 0) {
      dispatch((0, _users.getProfilesByIds)(needProfiles));
    }

    if (needStatuses.length > 0) {
      dispatch((0, _users.getStatusesByIds)(needStatuses));
    }

    return {
      data: true
    };
  };
}

let lastTimeTypingSent = 0;

function userTyping(channelId
/*: string*/
, parentPostId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const state = getState();
    const config = (0, _general.getConfig)(state);
    const t = Date.now();
    const stats = (0, _channels2.getCurrentChannelStats)(state);
    const membersInChannel = stats ? stats.member_count : 0;

    if (t - lastTimeTypingSent > config.TimeBetweenUserTypingUpdatesMilliseconds && membersInChannel < config.MaxNotificationsPerChannel && config.EnableUserTypingMessages === 'true') {
      _websocket_client.default.userTyping(channelId, parentPostId);

      lastTimeTypingSent = t;
    }

    return {
      data: true
    };
  };
}