"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forceLogoutIfNecessary = forceLogoutIfNecessary;
exports.requestData = requestData;
exports.requestSuccess = requestSuccess;
exports.requestFailure = requestFailure;
exports.bindClientFunc = bindClientFunc;
exports.debounce = debounce;
exports.FormattedError = void 0;

var _reduxBatchedActions = require("redux-batched-actions");

var _client = require("../client");

var _action_types = require("../action_types");

var _errors = require("./errors");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const HTTP_UNAUTHORIZED = 401;

function forceLogoutIfNecessary(err
/*: Client4Error*/
, dispatch
/*: DispatchFunc*/
, getState
/*: GetStateFunc*/
) {
  const {
    currentUserId
  } = getState().entities.users;

  if (err.status_code === HTTP_UNAUTHORIZED && err.url && err.url.indexOf('/login') === -1 && currentUserId) {
    _client.Client4.setToken('');

    dispatch({
      type: _action_types.UserTypes.LOGOUT_SUCCESS,
      data: {}
    });
  }
}

function dispatcher(type
/*: ActionType*/
, data
/*: any*/
, dispatch
/*: DispatchFunc*/
, getState
/*: GetStateFunc*/
) {
  if (type.indexOf('SUCCESS') === -1) {
    // we don't want to pass the data for the request types
    dispatch(requestSuccess(type, data), getState);
  } else {
    dispatch(requestData(type), getState);
  }
}

function requestData(type
/*: ActionType*/
)
/*: GenericAction*/
{
  return {
    type,
    data: null
  };
}

function requestSuccess(type
/*: ActionType*/
, data
/*: any*/
) {
  return {
    type,
    data
  };
}

function requestFailure(type
/*: ActionType*/
, error
/*: Client4Error*/
) {
  return {
    type,
    error
  };
}
/**
 * Returns an ActionFunc which calls a specfied (client) function and
 * dispatches the specifed actions on request, success or failure.
 *
 * @export
 * @param {Object} obj                                       an object for destructirung required properties
 * @param {() => Promise<mixed>} obj.clientFunc              clientFunc to execute
 * @param {ActionType} obj.onRequest                         ActionType to dispatch on request
 * @param {(ActionType | Array<ActionType>)} obj.onSuccess   ActionType to dispatch on success
 * @param {ActionType} obj.onFailure                         ActionType to dispatch on failure
 * @param {...Array<any>} obj.params
 * @returns {ActionFunc} ActionFunc
 */


function bindClientFunc({
  clientFunc,
  onRequest,
  onSuccess,
  onFailure,
  params = []
}
/*: {|
  clientFunc: () => Promise<mixed>,
  onRequest?: ActionType,
  onSuccess?: ActionType | Array<ActionType>,
  onFailure?: ActionType,
  params?: Array<any>,
|}*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    if (onRequest) {
      dispatch(requestData(onRequest), getState);
    }

    let data = null;

    try {
      data = await clientFunc(...params);
    } catch (error) {
      forceLogoutIfNecessary(error, dispatch, getState);
      const actions = [(0, _errors.logError)(error)];

      if (onFailure) {
        actions.push(requestFailure(onFailure, error));
      }

      dispatch((0, _reduxBatchedActions.batchActions)(actions));
      return {
        error
      };
    }

    if (Array.isArray(onSuccess)) {
      onSuccess.forEach(s => {
        dispatcher(s, data, dispatch, getState);
      });
    } else if (onSuccess) {
      dispatcher(onSuccess, data, dispatch, getState);
    }

    return {
      data
    };
  };
} // Debounce function based on underscores modified to use es6 and a cb


function debounce(func
/*: (...args: any) => mixed*/
, wait
/*: number*/
, immediate
/*: boolean*/
, cb
/*: () => mixed*/
) {
  let timeout;
  return function fx(...args) {
    const runLater = () => {
      timeout = null;

      if (!immediate) {
        Reflect.apply(func, this, args);

        if (cb) {
          cb();
        }
      }
    };

    const callNow = immediate && !timeout;

    if (timeout) {
      clearTimeout(timeout);
    }

    timeout = setTimeout(runLater, wait);

    if (callNow) {
      Reflect.apply(func, this, args);

      if (cb) {
        cb();
      }
    }
  };
}

class FormattedError extends Error {
  constructor(id
  /*: string*/
  , defaultMessage
  /*: string*/
  , values
  /*: Object*/
  = {}) {
    super(defaultMessage);

    _defineProperty(this, "intl", void 0);

    this.intl = {
      id,
      defaultMessage,
      values
    };
  }

}

exports.FormattedError = FormattedError;