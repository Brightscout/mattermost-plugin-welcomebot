"use strict";

require("core-js/modules/es.promise");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPing = getPing;
exports.resetPing = resetPing;
exports.getClientConfig = getClientConfig;
exports.getDataRetentionPolicy = getDataRetentionPolicy;
exports.getLicenseConfig = getLicenseConfig;
exports.logClientError = logClientError;
exports.setAppState = setAppState;
exports.setDeviceToken = setDeviceToken;
exports.setServerVersion = setServerVersion;
exports.setStoreFromLocalData = setStoreFromLocalData;
exports.getSupportedTimezones = getSupportedTimezones;
exports.setUrl = setUrl;
exports.getRedirectLocation = getRedirectLocation;
exports.default = void 0;

var _client = require("../client");

var _helpers = require("./helpers.js");

var _action_types = require("../action_types");

var _users = require("./users");

var _roles = require("./roles");

var _errors = require("./errors");

var _reduxBatchedActions = require("redux-batched-actions");

var _general = require("../selectors/entities/general");

var _helpers2 = require("../utils/helpers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getPing()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.GeneralTypes.PING_REQUEST,
      data: {}
    }, getState);
    let data
    /*: GenericClientResponse*/
    ;
    let pingError = new _helpers.FormattedError('mobile.server_ping_failed', 'Cannot connect to the server. Please check your server URL and internet connection.');

    try {
      data = await _client.Client4.ping();

      if (data.status !== 'OK') {
        // successful ping but not the right return {data}
        dispatch({
          type: _action_types.GeneralTypes.PING_FAILURE,
          data: {},
          error: pingError
        }, getState);
        return {
          error: pingError
        };
      }
    } catch (error) {
      // Client4Error
      if (error.status_code === 401) {
        // When the server requires a client certificate to connect.
        pingError = error;
      }

      dispatch({
        type: _action_types.GeneralTypes.PING_FAILURE,
        data: {},
        error: pingError
      }, getState);
      return {
        error: pingError
      };
    }

    dispatch({
      type: _action_types.GeneralTypes.PING_SUCCESS,
      data
    }, getState);
    return {
      data
    };
  };
}

function resetPing()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.GeneralTypes.PING_RESET,
      data: {}
    }, getState);
    return {
      data: true
    };
  };
}

function getClientConfig()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.GeneralTypes.CLIENT_CONFIG_REQUEST,
      data: {}
    }, getState);
    let data;

    try {
      data = await _client.Client4.getClientConfigOld();
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.GeneralTypes.CLIENT_CONFIG_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    _client.Client4.setEnableLogging(data.EnableDeveloper === 'true');

    _client.Client4.setDiagnosticId(data.DiagnosticId);

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.GeneralTypes.CLIENT_CONFIG_RECEIVED,
      data
    }, {
      type: _action_types.GeneralTypes.CLIENT_CONFIG_SUCCESS
    }]));
    return {
      data
    };
  };
}

function getDataRetentionPolicy()
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.GeneralTypes.DATA_RETENTION_POLICY_REQUEST,
      data: {}
    }, getState);
    let data;

    try {
      data = await _client.Client4.getDataRetentionPolicy();
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.GeneralTypes.DATA_RETENTION_POLICY_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.GeneralTypes.RECEIVED_DATA_RETENTION_POLICY,
      data
    }, {
      type: _action_types.GeneralTypes.DATA_RETENTION_POLICY_SUCCESS
    }]));
    return {
      data
    };
  };
}

function getLicenseConfig()
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getClientLicenseOld,
    onRequest: _action_types.GeneralTypes.CLIENT_LICENSE_REQUEST,
    onSuccess: [_action_types.GeneralTypes.CLIENT_LICENSE_RECEIVED, _action_types.GeneralTypes.CLIENT_LICENSE_SUCCESS],
    onFailure: _action_types.GeneralTypes.CLIENT_LICENSE_FAILURE
  });
}

function logClientError(message
/*: string*/
, level
/*: logLevel*/
= 'ERROR') {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.logClientError,
    onRequest: _action_types.GeneralTypes.LOG_CLIENT_ERROR_REQUEST,
    onSuccess: _action_types.GeneralTypes.LOG_CLIENT_ERROR_SUCCESS,
    onFailure: _action_types.GeneralTypes.LOG_CLIENT_ERROR_FAILURE,
    params: [message, level]
  });
}

function setAppState(state
/*: $PropertyType<GeneralState, 'appState'>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.GeneralTypes.RECEIVED_APP_STATE,
      data: state
    }, getState);
    return {
      data: true
    };
  };
}

function setDeviceToken(token
/*: $PropertyType<GeneralState, 'deviceToken'>*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.GeneralTypes.RECEIVED_APP_DEVICE_TOKEN,
      data: token
    }, getState);
    return {
      data: true
    };
  };
}

function setServerVersion(serverVersion
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.GeneralTypes.RECEIVED_SERVER_VERSION,
      data: serverVersion
    }, getState);
    dispatch((0, _roles.loadRolesIfNeeded)([]));
    return {
      data: true
    };
  };
}

function setStoreFromLocalData(data
/*: { token: string, url: string }*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState) => {
    _client.Client4.setToken(data.token);

    _client.Client4.setUrl(data.url);

    return (0, _users.loadMe)()(dispatch, getState);
  };
}

function getSupportedTimezones() {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getTimezones,
    onRequest: _action_types.GeneralTypes.SUPPORTED_TIMEZONES_REQUEST,
    onSuccess: [_action_types.GeneralTypes.SUPPORTED_TIMEZONES_RECEIVED, _action_types.GeneralTypes.SUPPORTED_TIMEZONES_SUCCESS],
    onFailure: _action_types.GeneralTypes.SUPPORTED_TIMEZONES_FAILURE
  });
}

function setUrl(url
/*: string*/
) {
  _client.Client4.setUrl(url);

  return true;
}

function getRedirectLocation(url
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    dispatch({
      type: _action_types.GeneralTypes.REDIRECT_LOCATION_REQUEST,
      data: {}
    }, getState);
    let pendingData
    /*: Promise<Object>*/
    ;

    if ((0, _helpers2.isMinimumServerVersion)((0, _general.getServerVersion)(getState()), 5, 3)) {
      pendingData = _client.Client4.getRedirectLocation(url);
    } else {
      pendingData = Promise.resolve({
        location: url
      });
    }

    let data;

    try {
      data = await pendingData;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch({
        type: _action_types.GeneralTypes.REDIRECT_LOCATION_FAILURE,
        data: {
          error,
          url
        }
      }, getState);
      return {
        error
      };
    }

    dispatch({
      type: _action_types.GeneralTypes.REDIRECT_LOCATION_SUCCESS,
      data: _objectSpread({}, data, {
        url
      })
    }, getState);
    return {
      data
    };
  };
}

var _default = {
  getPing,
  getClientConfig,
  getDataRetentionPolicy,
  getSupportedTimezones,
  getLicenseConfig,
  logClientError,
  setAppState,
  setDeviceToken,
  setServerVersion,
  setStoreFromLocalData,
  setUrl,
  getRedirectLocation
};
exports.default = _default;