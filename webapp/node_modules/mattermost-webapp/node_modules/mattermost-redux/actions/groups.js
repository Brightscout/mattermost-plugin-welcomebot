"use strict";

require("core-js/modules/es.promise");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linkGroupSyncable = linkGroupSyncable;
exports.unlinkGroupSyncable = unlinkGroupSyncable;
exports.getGroupSyncables = getGroupSyncables;
exports.getGroupMembers = getGroupMembers;
exports.getGroup = getGroup;
exports.getGroupsNotAssociatedToTeam = getGroupsNotAssociatedToTeam;
exports.getGroupsNotAssociatedToChannel = getGroupsNotAssociatedToChannel;
exports.getAllGroupsAssociatedToTeam = getAllGroupsAssociatedToTeam;
exports.getAllGroupsAssociatedToChannel = getAllGroupsAssociatedToChannel;
exports.getGroupsAssociatedToTeam = getGroupsAssociatedToTeam;
exports.getGroupsAssociatedToChannel = getGroupsAssociatedToChannel;

var _action_types = require("../action_types");

var _constants = require("../constants");

var _client = require("../client");

var _errors = require("./errors");

var _helpers = require("./helpers");

var _reduxBatchedActions = require("redux-batched-actions");

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
// @flow
function linkGroupSyncable(groupID
/*: string*/
, syncableID
/*: string*/
, syncableType
/*: SyncableType*/
, patch
/*: SyncablePatch*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.GroupTypes.LINK_GROUP_SYNCABLE_REQUEST,
      data: {
        groupID,
        syncableID
      }
    });
    let data;

    try {
      data = await _client.Client4.linkGroupSyncable(groupID, syncableID, syncableType, patch);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.GroupTypes.LINK_GROUP_SYNCABLE_FAILURE,
        error,
        data: {
          groupID,
          syncableID
        }
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    const dispatches = [];
    let type;

    switch (syncableType) {
      case _constants.Groups.SYNCABLE_TYPE_TEAM:
        dispatches.push({
          type: _action_types.GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_TEAM,
          data: {
            teamID: syncableID,
            groups: [{
              id: groupID
            }]
          }
        });
        type = _action_types.GroupTypes.LINKED_GROUP_TEAM;
        break;

      case _constants.Groups.SYNCABLE_TYPE_CHANNEL:
        type = _action_types.GroupTypes.LINKED_GROUP_CHANNEL;
        break;

      default:
        console.warn("unhandled syncable type ".concat(syncableType));
      // eslint-disable-line no-console
    }

    dispatches.push({
      type: _action_types.GroupTypes.LINK_GROUP_SYNCABLE_SUCCESS,
      data: null
    }, {
      type,
      data
    });
    dispatch((0, _reduxBatchedActions.batchActions)(dispatches));
    return {
      data: true
    };
  };
}

function unlinkGroupSyncable(groupID
/*: string*/
, syncableID
/*: string*/
, syncableType
/*: SyncableType*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.GroupTypes.UNLINK_GROUP_SYNCABLE_REQUEST,
      data: {
        groupID,
        syncableID
      }
    });

    try {
      await _client.Client4.unlinkGroupSyncable(groupID, syncableID, syncableType);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.GroupTypes.UNLINK_GROUP_SYNCABLE_FAILURE,
        error,
        data: {
          groupID,
          syncableID
        }
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    const dispatches = [];
    let type;
    const data = {
      group_id: groupID,
      syncable_id: syncableID
    };

    switch (syncableType) {
      case _constants.Groups.SYNCABLE_TYPE_TEAM:
        type = _action_types.GroupTypes.UNLINKED_GROUP_TEAM;
        data.syncable_id = syncableID;
        dispatches.push({
          type: _action_types.GroupTypes.RECEIVED_GROUPS_NOT_ASSOCIATED_TO_TEAM,
          data: {
            teamID: syncableID,
            groups: [{
              id: groupID
            }]
          }
        });
        break;

      case _constants.Groups.SYNCABLE_TYPE_CHANNEL:
        type = _action_types.GroupTypes.UNLINKED_GROUP_CHANNEL;
        data.syncable_id = syncableID;
        break;

      default:
        console.warn("unhandled syncable type ".concat(syncableType));
      // eslint-disable-line no-console
    }

    dispatches.push({
      type: _action_types.GroupTypes.UNLINK_GROUP_SYNCABLE_SUCCESS,
      data: null
    }, {
      type,
      data
    });
    dispatch((0, _reduxBatchedActions.batchActions)(dispatches));
    return {
      data: true
    };
  };
}

function getGroupSyncables(groupID
/*: string*/
, syncableType
/*: SyncableType*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.GroupTypes.GET_GROUP_SYNCABLES_REQUEST,
      data: {
        groupID
      }
    });
    let data;

    try {
      data = await _client.Client4.getGroupSyncables(groupID, syncableType);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.GroupTypes.GET_GROUP_SYNCABLES_FAILURE,
        error,
        data: {
          groupID
        }
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    let type;

    switch (syncableType) {
      case _constants.Groups.SYNCABLE_TYPE_TEAM:
        type = _action_types.GroupTypes.RECEIVED_GROUP_TEAMS;
        break;

      case _constants.Groups.SYNCABLE_TYPE_CHANNEL:
        type = _action_types.GroupTypes.RECEIVED_GROUP_CHANNELS;
        break;

      default:
        console.warn("unhandled syncable type ".concat(syncableType));
      // eslint-disable-line no-console
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.GroupTypes.GET_GROUP_SYNCABLES_SUCCESS,
      data: null
    }, {
      type,
      data,
      group_id: groupID
    }]));
    return {
      data: true
    };
  };
}

function getGroupMembers(groupID
/*: string*/
, page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PAGE_SIZE_DEFAULT)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.GroupTypes.GET_GROUP_MEMBERS_REQUEST,
      data: {
        groupID,
        page,
        perPage
      }
    });
    let data;

    try {
      data = await _client.Client4.getGroupMembers(groupID, page, perPage);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.GroupTypes.GET_GROUP_MEMBERS_FAILURE,
        error,
        data: {
          groupID,
          page,
          perPage
        }
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.GroupTypes.GET_GROUP_MEMBERS_SUCCESS,
      data: null
    }, {
      type: _action_types.GroupTypes.RECEIVED_GROUP_MEMBERS,
      group_id: groupID,
      data
    }]));
    return {
      data: true
    };
  };
}

function getGroup(id
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getGroup,
    onRequest: _action_types.GroupTypes.GET_GROUP_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUP, _action_types.GroupTypes.GET_GROUP_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUP_FAILURE,
    params: [id]
  });
}

function getGroupsNotAssociatedToTeam(teamID
/*: string*/
, q
/*: string*/
= '', page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PAGE_SIZE_DEFAULT)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getGroupsNotAssociatedToTeam,
    onRequest: _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_TEAM_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUPS, _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_TEAM_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_TEAM_FAILURE,
    params: [teamID, q, page, perPage]
  });
}

function getGroupsNotAssociatedToChannel(channelID
/*: string*/
, q
/*: string*/
= '', page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PAGE_SIZE_DEFAULT)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getGroupsNotAssociatedToChannel,
    onRequest: _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_CHANNEL_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUPS, _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_CHANNEL_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUPS_NOT_ASSOCIATED_TO_CHANNEL_FAILURE,
    params: [channelID, q, page, perPage]
  });
}

function getAllGroupsAssociatedToTeam(teamID
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: async param1 => {
      const result = await _client.Client4.getAllGroupsAssociatedToTeam(param1);
      result.teamID = param1;
      return result;
    },
    onRequest: _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_TEAM_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_TEAM, _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_TEAM_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_TEAM_FAILURE,
    params: [teamID]
  });
}

function getAllGroupsAssociatedToChannel(channelID
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: async param1 => {
      const result = await _client.Client4.getAllGroupsAssociatedToChannel(param1);
      result.channelID = param1;
      return result;
    },
    onRequest: _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_CHANNEL_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_ALL_GROUPS_ASSOCIATED_TO_CHANNEL, _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_CHANNEL_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_ALL_GROUPS_ASSOCIATED_TO_CHANNEL_FAILURE,
    params: [channelID]
  });
}

function getGroupsAssociatedToTeam(teamID
/*: string*/
, q
/*: string*/
= '', page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PAGE_SIZE_DEFAULT)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: async (param1, param2, param3, param4) => {
      const result = await _client.Client4.getGroupsAssociatedToTeam(param1, param2, param3, param4);
      return {
        groups: result.groups,
        totalGroupCount: result.total_group_count,
        teamID: param1
      };
    },
    onRequest: _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_TEAM_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_TEAM, _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_TEAM_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_TEAM_FAILURE,
    params: [teamID, q, page, perPage]
  });
}

function getGroupsAssociatedToChannel(channelID
/*: string*/
, q
/*: string*/
= '', page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PAGE_SIZE_DEFAULT)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: async (param1, param2, param3, param4) => {
      const result = await _client.Client4.getGroupsAssociatedToChannel(param1, param2, param3, param4);
      return {
        groups: result.groups,
        totalGroupCount: result.total_group_count,
        channelID: param1
      };
    },
    onRequest: _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_CHANNEL_REQUEST,
    onSuccess: [_action_types.GroupTypes.RECEIVED_GROUPS_ASSOCIATED_TO_CHANNEL, _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_CHANNEL_SUCCESS],
    onFailure: _action_types.GroupTypes.GET_GROUPS_ASSOCIATED_TO_CHANNEL_FAILURE,
    params: [channelID, q, page, perPage]
  });
}