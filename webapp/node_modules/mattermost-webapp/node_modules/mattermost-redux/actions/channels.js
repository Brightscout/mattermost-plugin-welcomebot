"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.split");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectChannel = selectChannel;
exports.createChannel = createChannel;
exports.createDirectChannel = createDirectChannel;
exports.markGroupChannelOpen = markGroupChannelOpen;
exports.createGroupChannel = createGroupChannel;
exports.patchChannel = patchChannel;
exports.updateChannel = updateChannel;
exports.convertChannelToPrivate = convertChannelToPrivate;
exports.updateChannelNotifyProps = updateChannelNotifyProps;
exports.getChannelByNameAndTeamName = getChannelByNameAndTeamName;
exports.getChannel = getChannel;
exports.getChannelAndMyMember = getChannelAndMyMember;
exports.getChannelTimezones = getChannelTimezones;
exports.fetchMyChannelsAndMembers = fetchMyChannelsAndMembers;
exports.getMyChannelMembers = getMyChannelMembers;
exports.getChannelMembers = getChannelMembers;
exports.leaveChannel = leaveChannel;
exports.joinChannel = joinChannel;
exports.deleteChannel = deleteChannel;
exports.viewChannel = viewChannel;
exports.markChannelAsViewed = markChannelAsViewed;
exports.getChannels = getChannels;
exports.getAllChannelsWithCount = getAllChannelsWithCount;
exports.getAllChannels = getAllChannels;
exports.autocompleteChannels = autocompleteChannels;
exports.autocompleteChannelsForSearch = autocompleteChannelsForSearch;
exports.searchChannels = searchChannels;
exports.searchAllChannels = searchAllChannels;
exports.searchGroupChannels = searchGroupChannels;
exports.getChannelStats = getChannelStats;
exports.addChannelMember = addChannelMember;
exports.removeChannelMember = removeChannelMember;
exports.updateChannelMemberRoles = updateChannelMemberRoles;
exports.updateChannelHeader = updateChannelHeader;
exports.updateChannelPurpose = updateChannelPurpose;
exports.markChannelAsRead = markChannelAsRead;
exports.markChannelAsUnread = markChannelAsUnread;
exports.getChannelMembersByIds = getChannelMembersByIds;
exports.getChannelMember = getChannelMember;
exports.getMyChannelMember = getMyChannelMember;
exports.favoriteChannel = favoriteChannel;
exports.unfavoriteChannel = unfavoriteChannel;
exports.updateChannelScheme = updateChannelScheme;
exports.updateChannelMemberSchemeRoles = updateChannelMemberSchemeRoles;
exports.membersMinusGroupMembers = membersMinusGroupMembers;
exports.default = void 0;

var _reduxBatchedActions = require("redux-batched-actions");

var _client = require("../client");

var _constants = require("../constants");

var _action_types = require("../action_types");

var _preferences = require("./preferences");

var _channel_utils = require("../utils/channel_utils");

var _channels = require("../selectors/entities/channels");

var _teams = require("../selectors/entities/teams");

var _errors = require("./errors");

var _helpers = require("./helpers");

var _users = require("./users");

var _roles = require("./roles");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function selectChannel(channelId
/*: string*/
) {
  return {
    type: _action_types.ChannelTypes.SELECT_CHANNEL,
    data: channelId
  };
}

function createChannel(channel
/*: Channel*/
, userId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let created;

    try {
      created = await _client.Client4.createChannel(channel);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.CREATE_CHANNEL_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    const member = {
      channel_id: created.id,
      user_id: userId,
      roles: "".concat(_constants.General.CHANNEL_USER_ROLE, " ").concat(_constants.General.CHANNEL_ADMIN_ROLE),
      last_viewed_at: 0,
      msg_count: 0,
      mention_count: 0,
      notify_props: {
        desktop: 'default',
        mark_unread: 'all'
      },
      last_update_at: created.create_at
    };
    const actions = [];
    const {
      channels,
      myMembers
    } = getState().entities.channels;

    if (!channels[created.id]) {
      actions.push({
        type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
        data: created
      });
    }

    if (!myMembers[created.id]) {
      actions.push({
        type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
        data: member
      });
      dispatch((0, _roles.loadRolesIfNeeded)(member.roles.split(' ')));
    }

    dispatch((0, _reduxBatchedActions.batchActions)([...actions, {
      type: _action_types.ChannelTypes.CREATE_CHANNEL_SUCCESS
    }]), getState);
    return {
      data: created
    };
  };
}

function createDirectChannel(userId
/*: string*/
, otherUserId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.CREATE_CHANNEL_REQUEST,
      data: null
    }, getState);
    let created;

    try {
      created = await _client.Client4.createDirectChannel([userId, otherUserId]);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.CREATE_CHANNEL_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    const member = {
      channel_id: created.id,
      user_id: userId,
      roles: "".concat(_constants.General.CHANNEL_USER_ROLE),
      last_viewed_at: 0,
      msg_count: 0,
      mention_count: 0,
      notify_props: {
        desktop: 'default',
        mark_unread: 'all'
      },
      last_update_at: created.create_at
    };
    const preferences = [{
      user_id: userId,
      category: _constants.Preferences.CATEGORY_DIRECT_CHANNEL_SHOW,
      name: otherUserId,
      value: 'true'
    }, {
      user_id: userId,
      category: _constants.Preferences.CATEGORY_CHANNEL_OPEN_TIME,
      name: created.id,
      value: new Date().getTime().toString()
    }];
    (0, _preferences.savePreferences)(userId, preferences)(dispatch);
    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data: created
    }, {
      type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
      data: member
    }, {
      type: _action_types.PreferenceTypes.RECEIVED_PREFERENCES,
      data: preferences
    }, {
      type: _action_types.ChannelTypes.CREATE_CHANNEL_SUCCESS
    }, {
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_CHANNEL,
      id: created.id,
      data: [{
        id: userId
      }, {
        id: otherUserId
      }]
    }]), getState);
    dispatch((0, _roles.loadRolesIfNeeded)(member.roles.split(' ')));
    return {
      data: created
    };
  };
}

function markGroupChannelOpen(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch
  /*: DispatchFunc*/
  , getState
  /*: GetStateFunc*/
  ) => {
    const {
      currentUserId
    } = getState().entities.users;
    const preferences
    /*: Array<PreferenceType>*/
    = [{
      user_id: currentUserId,
      category: _constants.Preferences.CATEGORY_GROUP_CHANNEL_SHOW,
      name: channelId,
      value: 'true'
    }, {
      user_id: currentUserId,
      category: _constants.Preferences.CATEGORY_CHANNEL_OPEN_TIME,
      name: channelId,
      value: new Date().getTime().toString()
    }];
    return dispatch((0, _preferences.savePreferences)(currentUserId, preferences));
  };
}

function createGroupChannel(userIds
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.CREATE_CHANNEL_REQUEST,
      data: null
    }, getState);
    const {
      currentUserId
    } = getState().entities.users;
    let created;

    try {
      created = await _client.Client4.createGroupChannel(userIds);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.CREATE_CHANNEL_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    let member = {
      channel_id: created.id,
      user_id: currentUserId,
      roles: "".concat(_constants.General.CHANNEL_USER_ROLE),
      last_viewed_at: 0,
      msg_count: 0,
      mention_count: 0,
      notify_props: {
        desktop: 'default',
        mark_unread: 'all'
      },
      last_update_at: created.create_at
    }; // Check the channel previous existency: if the channel already have
    // posts is because it existed before.

    if (created.total_msg_count > 0) {
      const storeMember = (0, _channels.getMyChannelMember)(getState(), created.id);

      if (storeMember === null) {
        try {
          member = await _client.Client4.getMyChannelMember(created.id);
        } catch (error) {
          // Log the error and keep going with the generated membership.
          dispatch((0, _errors.logError)(error));
        }
      } else {
        member = storeMember;
      }
    }

    dispatch(markGroupChannelOpen(created.id));
    const profilesInChannel = userIds.map(id => {
      return {
        id
      };
    });
    profilesInChannel.push({
      id: currentUserId
    }); // currentUserId is optionally in userIds, but the reducer will get rid of a duplicate

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data: created
    }, {
      type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
      data: member
    }, {
      type: _action_types.ChannelTypes.CREATE_CHANNEL_SUCCESS
    }, {
      type: _action_types.UserTypes.RECEIVED_PROFILES_LIST_IN_CHANNEL,
      id: created.id,
      data: profilesInChannel
    }]), getState);
    dispatch((0, _roles.loadRolesIfNeeded)(member && member.roles.split(' ') || []));
    return {
      data: created
    };
  };
}

function patchChannel(channelId
/*: string*/
, patch
/*: Channel*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.UPDATE_CHANNEL_REQUEST,
      data: null
    }, getState);
    let updated;

    try {
      updated = await _client.Client4.patchChannel(channelId, patch);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.UPDATE_CHANNEL_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data: updated
    }, {
      type: _action_types.ChannelTypes.UPDATE_CHANNEL_SUCCESS
    }]), getState);
    return {
      data: updated
    };
  };
}

function updateChannel(channel
/*: Channel*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.UPDATE_CHANNEL_REQUEST,
      data: null
    }, getState);
    let updated;

    try {
      updated = await _client.Client4.updateChannel(channel);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.UPDATE_CHANNEL_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data: updated
    }, {
      type: _action_types.ChannelTypes.UPDATE_CHANNEL_SUCCESS
    }]), getState);
    return {
      data: updated
    };
  };
}

function convertChannelToPrivate(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.UPDATE_CHANNEL_REQUEST,
      data: null
    }, getState);
    let convertedChannel;

    try {
      convertedChannel = await _client.Client4.convertChannelToPrivate(channelId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.UPDATE_CHANNEL_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data: convertedChannel
    }, {
      type: _action_types.ChannelTypes.UPDATE_CHANNEL_SUCCESS
    }]), getState);
    return {
      data: convertedChannel
    };
  };
}

function updateChannelNotifyProps(userId
/*: string*/
, channelId
/*: string*/
, props
/*: ChannelNotifyProps*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    const notifyProps = _objectSpread({
      user_id: userId,
      channel_id: channelId
    }, props);

    try {
      await _client.Client4.updateChannelNotifyProps(notifyProps);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const member = getState().entities.channels.myMembers[channelId] || {};
    const currentNotifyProps = member.notify_props || {};
    dispatch({
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL_PROPS,
      data: {
        channel_id: channelId,
        notifyProps: _objectSpread({}, currentNotifyProps, {}, notifyProps)
      }
    });
    return {
      data: true
    };
  };
}

function getChannelByNameAndTeamName(teamName
/*: string*/
, channelName
/*: string*/
, includeDeleted
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let data;

    try {
      data = await _client.Client4.getChannelByNameAndTeamName(teamName, channelName, includeDeleted);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch({
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data
    });
    return {
      data
    };
  };
}

function getChannel(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let data;

    try {
      data = await _client.Client4.getChannel(channelId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch({
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data
    });
    return {
      data
    };
  };
}

function getChannelAndMyMember(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let channel;
    let member;

    try {
      const channelRequest = _client.Client4.getChannel(channelId);

      const memberRequest = _client.Client4.getMyChannelMember(channelId);

      channel = await channelRequest;
      member = await memberRequest;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data: channel
    }, {
      type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
      data: member
    }]), getState);
    dispatch((0, _roles.loadRolesIfNeeded)(member.roles.split(' ')));
    return {
      data: {
        channel,
        member
      }
    };
  };
}

function getChannelTimezones(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let channelTimezones;

    try {
      const channelTimezonesRequest = _client.Client4.getChannelTimezones(channelId);

      channelTimezones = await channelTimezonesRequest;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    return {
      data: channelTimezones
    };
  };
}

function fetchMyChannelsAndMembers(teamId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.CHANNELS_REQUEST,
      data: null
    });
    let channels;
    let channelMembers;

    try {
      const channelRequest = _client.Client4.getMyChannels(teamId);

      const memberRequest = _client.Client4.getMyChannelMembers(teamId);

      channels = await channelRequest;
      channelMembers = await memberRequest;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    const {
      currentUserId
    } = getState().entities.users;
    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNELS,
      teamId,
      data: channels
    }, {
      type: _action_types.ChannelTypes.CHANNELS_SUCCESS
    }, {
      type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBERS,
      data: channelMembers,
      remove: (0, _channel_utils.getChannelsIdForTeam)(getState(), teamId),
      currentUserId
    }]), getState);
    const roles = new Set();

    for (const member of channelMembers) {
      for (const role of member.roles.split(' ')) {
        roles.add(role);
      }
    }

    if (roles.size > 0) {
      dispatch((0, _roles.loadRolesIfNeeded)(roles));
    }

    return {
      data: {
        channels,
        members: channelMembers
      }
    };
  };
}

function getMyChannelMembers(teamId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let channelMembers;

    try {
      const channelMembersRequest = _client.Client4.getMyChannelMembers(teamId);

      channelMembers = await channelMembersRequest;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const {
      currentUserId
    } = getState().entities.users;
    dispatch({
      type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBERS,
      data: channelMembers,
      remove: (0, _channel_utils.getChannelsIdForTeam)(getState(), teamId),
      currentUserId
    });
    const roles = new Set();

    for (const member of channelMembers) {
      for (const role of member.roles.split(' ')) {
        roles.add(role);
      }
    }

    if (roles.size > 0) {
      dispatch((0, _roles.loadRolesIfNeeded)(roles));
    }

    return {
      data: channelMembers
    };
  };
}

function getChannelMembers(channelId
/*: string*/
, page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.CHANNELS_CHUNK_SIZE)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let channelMembers;

    try {
      const channelMembersRequest = _client.Client4.getChannelMembers(channelId, page, perPage);

      channelMembers = await channelMembersRequest;
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const userIds = channelMembers.map(cm => cm.user_id);
    (0, _users.getMissingProfilesByIds)(userIds)(dispatch, getState);
    dispatch({
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL_MEMBERS,
      data: channelMembers
    });
    return {
      data: channelMembers
    };
  };
}

function leaveChannel(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    const state = getState();
    const {
      currentUserId
    } = state.entities.users;
    const {
      channels,
      myMembers
    } = state.entities.channels;
    const channel = channels[channelId];
    const member = myMembers[channelId];

    _client.Client4.trackEvent('action', 'action_channels_leave', {
      channel_id: channelId
    });

    dispatch({
      type: _action_types.ChannelTypes.LEAVE_CHANNEL,
      data: {
        id: channelId,
        user_id: currentUserId,
        team_id: channel.team_id,
        type: channel.type
      },
      meta: {
        offline: {
          effect: () => _client.Client4.removeFromChannel(currentUserId, channelId),
          commit: {
            type: 'do_nothing'
          },
          // redux-offline always needs to dispatch something on commit
          rollback: () => {
            dispatch((0, _reduxBatchedActions.batchActions)([{
              type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
              data: channel
            }, {
              type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
              data: member
            }]));
          }
        }
      }
    });
    return {
      data: true
    };
  };
}

function joinChannel(userId
/*: string*/
, teamId
/*: string*/
, channelId
/*: string*/
, channelName
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let member
    /*: ?ChannelMembership*/
    ;
    let channel;

    try {
      if (channelId) {
        member = await _client.Client4.addToChannel(userId, channelId);
        channel = await _client.Client4.getChannel(channelId);
      } else if (channelName) {
        channel = await _client.Client4.getChannelByName(teamId, channelName, true);

        if (channel.type === _constants.General.GM_CHANNEL || channel.type === _constants.General.DM_CHANNEL) {
          member = await _client.Client4.getChannelMember(channel.id, userId);
        } else {
          member = await _client.Client4.addToChannel(userId, channel.id);
        }
      }
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    _client.Client4.trackEvent('action', 'action_channels_join', {
      channel_id: channelId
    });

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL,
      data: channel
    }, {
      type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
      data: member
    }]), getState);

    if (member) {
      dispatch((0, _roles.loadRolesIfNeeded)(member.roles.split(' ')));
    }

    return {
      data: {
        channel,
        member
      }
    };
  };
}

function deleteChannel(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let state = getState();
    const viewArchivedChannels = state.entities.general.config.ExperimentalViewArchivedChannels === 'true';

    try {
      await _client.Client4.deleteChannel(channelId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    state = getState();
    const {
      currentChannelId
    } = state.entities.channels;

    if (channelId === currentChannelId && !viewArchivedChannels) {
      const teamId = (0, _teams.getCurrentTeamId)(state);
      const channelsInTeam = (0, _channels.getChannelsNameMapInTeam)(state, teamId);
      const channel = (0, _channel_utils.getChannelByName)(channelsInTeam, (0, _channels.getRedirectChannelNameForTeam)(state, teamId));

      if (channel && channel.id) {
        dispatch({
          type: _action_types.ChannelTypes.SELECT_CHANNEL,
          data: channel.id
        }, getState);
      }
    }

    dispatch({
      type: _action_types.ChannelTypes.DELETE_CHANNEL_SUCCESS,
      data: {
        id: channelId,
        viewArchivedChannels
      }
    }, getState);
    return {
      data: true
    };
  };
}

function viewChannel(channelId
/*: string*/
, prevChannelId
/*: string*/
= '')
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    const {
      currentUserId
    } = getState().entities.users;
    const {
      myPreferences
    } = getState().entities.preferences;
    const viewTimePref = myPreferences["".concat(_constants.Preferences.CATEGORY_CHANNEL_APPROXIMATE_VIEW_TIME, "--").concat(channelId)];
    const viewTime = viewTimePref ? parseInt(viewTimePref.value, 10) : 0;

    if (viewTime < new Date().getTime() - 3 * 60 * 60 * 1000) {
      const preferences = [{
        user_id: currentUserId,
        category: _constants.Preferences.CATEGORY_CHANNEL_APPROXIMATE_VIEW_TIME,
        name: channelId,
        value: new Date().getTime().toString()
      }];
      (0, _preferences.savePreferences)(currentUserId, preferences)(dispatch);
    }

    try {
      await _client.Client4.viewMyChannel(channelId, prevChannelId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const actions = [];
    const {
      myMembers
    } = getState().entities.channels;
    const member = myMembers[channelId];

    if (member) {
      actions.push({
        type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
        data: _objectSpread({}, member, {
          last_viewed_at: new Date().getTime()
        })
      });
      dispatch((0, _roles.loadRolesIfNeeded)(member.roles.split(' ')));
    }

    const prevMember = myMembers[prevChannelId];

    if (prevMember) {
      actions.push({
        type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
        data: _objectSpread({}, prevMember, {
          last_viewed_at: new Date().getTime()
        })
      });
      dispatch((0, _roles.loadRolesIfNeeded)(prevMember.roles.split(' ')));
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data: true
    };
  };
}

function markChannelAsViewed(channelId
/*: string*/
, prevChannelId
/*: string*/
= '')
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    const actions = [];
    const {
      myMembers
    } = getState().entities.channels;
    const member = myMembers[channelId];

    if (member) {
      actions.push({
        type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
        data: _objectSpread({}, member, {
          last_viewed_at: Date.now()
        })
      });
      dispatch((0, _roles.loadRolesIfNeeded)(member.roles.split(' ')));
    }

    const prevMember = myMembers[prevChannelId];

    if (prevMember) {
      actions.push({
        type: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
        data: _objectSpread({}, prevMember, {
          last_viewed_at: Date.now()
        })
      });
      dispatch((0, _roles.loadRolesIfNeeded)(prevMember.roles.split(' ')));
    }

    if (actions.length) {
      dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    }

    return {
      data: true
    };
  };
}

function getChannels(teamId
/*: string*/
, page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.CHANNELS_CHUNK_SIZE)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.GET_CHANNELS_REQUEST,
      data: null
    }, getState);
    let channels;

    try {
      channels = await _client.Client4.getChannels(teamId, page, perPage);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.GET_CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNELS,
      teamId,
      data: channels
    }, {
      type: _action_types.ChannelTypes.GET_CHANNELS_SUCCESS
    }]), getState);
    return {
      data: channels
    };
  };
}

function getAllChannelsWithCount(page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.CHANNELS_CHUNK_SIZE, notAssociatedToGroup
/*: string*/
= '', excludeDefaultChannels
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.GET_ALL_CHANNELS_REQUEST,
      data: null
    }, getState);
    let payload;

    try {
      payload = await _client.Client4.getAllChannels(page, perPage, notAssociatedToGroup, excludeDefaultChannels, true);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.GET_ALL_CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_ALL_CHANNELS,
      data: payload.channels
    }, {
      type: _action_types.ChannelTypes.GET_ALL_CHANNELS_SUCCESS
    }, {
      type: _action_types.ChannelTypes.RECEIVED_TOTAL_CHANNEL_COUNT,
      data: payload.total_count
    }]), getState);
    return {
      data: payload
    };
  };
}

function getAllChannels(page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.CHANNELS_CHUNK_SIZE, notAssociatedToGroup
/*: string*/
= '', excludeDefaultChannels
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.GET_ALL_CHANNELS_REQUEST,
      data: null
    }, getState);
    let channels;

    try {
      channels = await _client.Client4.getAllChannels(page, perPage, notAssociatedToGroup, excludeDefaultChannels);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.GET_ALL_CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_ALL_CHANNELS,
      data: channels
    }, {
      type: _action_types.ChannelTypes.GET_ALL_CHANNELS_SUCCESS
    }]), getState);
    return {
      data: channels
    };
  };
}

function autocompleteChannels(teamId
/*: string*/
, term
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.GET_CHANNELS_REQUEST,
      data: null
    }, getState);
    let channels;

    try {
      channels = await _client.Client4.autocompleteChannels(teamId, term);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.GET_CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNELS,
      teamId,
      data: channels
    }, {
      type: _action_types.ChannelTypes.GET_CHANNELS_SUCCESS
    }]), getState);
    return {
      data: channels
    };
  };
}

function autocompleteChannelsForSearch(teamId
/*: string*/
, term
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.GET_CHANNELS_REQUEST,
      data: null
    }, getState);
    let channels;

    try {
      channels = await _client.Client4.autocompleteChannelsForSearch(teamId, term);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.GET_CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNELS,
      teamId,
      data: channels
    }, {
      type: _action_types.ChannelTypes.GET_CHANNELS_SUCCESS
    }]), getState);
    return {
      data: channels
    };
  };
}

function searchChannels(teamId
/*: string*/
, term
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.GET_CHANNELS_REQUEST,
      data: null
    }, getState);
    let channels;

    try {
      channels = await _client.Client4.searchChannels(teamId, term);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.GET_CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_CHANNELS,
      teamId,
      data: channels
    }, {
      type: _action_types.ChannelTypes.GET_CHANNELS_SUCCESS
    }]), getState);
    return {
      data: channels
    };
  };
}

function searchAllChannels(term
/*: string*/
, notAssociatedToGroup
/*: string*/
= '', excludeDefaultChannels
/*: boolean*/
= false)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.ChannelTypes.GET_ALL_CHANNELS_REQUEST,
      data: null
    }, getState);
    let channels;

    try {
      channels = await _client.Client4.searchAllChannels(term, notAssociatedToGroup, excludeDefaultChannels);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.ChannelTypes.GET_ALL_CHANNELS_FAILURE,
        error
      }, (0, _errors.logError)(error)]), getState);
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.ChannelTypes.RECEIVED_ALL_CHANNELS,
      data: channels
    }, {
      type: _action_types.ChannelTypes.GET_ALL_CHANNELS_SUCCESS
    }]), getState);
    return {
      data: channels
    };
  };
}

function searchGroupChannels(term
/*: string*/
)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.searchGroupChannels,
    params: [term]
  });
}

function getChannelStats(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let stat;

    try {
      stat = await _client.Client4.getChannelStats(channelId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    dispatch({
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL_STATS,
      data: stat
    });
    return {
      data: stat
    };
  };
}

function addChannelMember(channelId
/*: string*/
, userId
/*: string*/
, postRootId
/*: string*/
= '')
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    let member;

    try {
      member = await _client.Client4.addToChannel(userId, channelId, postRootId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    _client.Client4.trackEvent('action', 'action_channels_add_member', {
      channel_id: channelId
    });

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.RECEIVED_PROFILE_IN_CHANNEL,
      data: {
        id: channelId,
        user_id: userId
      }
    }, {
      type: _action_types.ChannelTypes.RECEIVED_CHANNEL_MEMBER,
      data: member
    }, {
      type: _action_types.ChannelTypes.ADD_CHANNEL_MEMBER_SUCCESS,
      id: channelId
    }], 'ADD_CHANNEL_MEMBER.BATCH'), getState);
    return {
      data: member
    };
  };
}

function removeChannelMember(channelId
/*: string*/
, userId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    try {
      await _client.Client4.removeFromChannel(userId, channelId);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    _client.Client4.trackEvent('action', 'action_channels_remove_member', {
      channel_id: channelId
    });

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.UserTypes.RECEIVED_PROFILE_NOT_IN_CHANNEL,
      data: {
        id: channelId,
        user_id: userId
      }
    }, {
      type: _action_types.ChannelTypes.REMOVE_CHANNEL_MEMBER_SUCCESS,
      id: channelId
    }], 'REMOVE_CHANNEL_MEMBER.BATCH'), getState);
    return {
      data: true
    };
  };
}

function updateChannelMemberRoles(channelId
/*: string*/
, userId
/*: string*/
, roles
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    try {
      await _client.Client4.updateChannelMemberRoles(channelId, userId, roles);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _errors.logError)(error));
      return {
        error
      };
    }

    const membersInChannel = getState().entities.channels.membersInChannel[channelId];

    if (membersInChannel && membersInChannel[userId]) {
      dispatch({
        type: _action_types.ChannelTypes.RECEIVED_CHANNEL_MEMBER,
        data: _objectSpread({}, membersInChannel[userId], {
          roles
        })
      });
    }

    return {
      data: true
    };
  };
}

function updateChannelHeader(channelId
/*: string*/
, header
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    _client.Client4.trackEvent('action', 'action_channels_update_header', {
      channel_id: channelId
    });

    dispatch({
      type: _action_types.ChannelTypes.UPDATE_CHANNEL_HEADER,
      data: {
        channelId,
        header
      }
    }, getState);
    return {
      data: true
    };
  };
}

function updateChannelPurpose(channelId
/*: string*/
, purpose
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    _client.Client4.trackEvent('action', 'action_channels_update_purpose', {
      channel_id: channelId
    });

    dispatch({
      type: _action_types.ChannelTypes.UPDATE_CHANNEL_PURPOSE,
      data: {
        channelId,
        purpose
      }
    }, getState);
    return {
      data: true
    };
  };
}

function markChannelAsRead(channelId
/*: string*/
, prevChannelId
/*: ?string*/
, updateLastViewedAt
/*: boolean*/
= true)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    // Send channel last viewed at to the server
    if (updateLastViewedAt) {
      _client.Client4.viewMyChannel(channelId, prevChannelId).then().catch(error => {
        (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
        dispatch((0, _errors.logError)(error));
        return {
          error
        };
      });
    }

    const state = getState();
    const {
      channels,
      myMembers
    } = state.entities.channels; // Update channel member objects to set all mentions and posts as viewed

    const channel = channels[channelId];
    const prevChannel = prevChannelId ? channels[prevChannelId] : null; // May be null since prevChannelId is optional
    // Update team member objects to set mentions and posts in channel as viewed

    const channelMember = myMembers[channelId];
    const prevChannelMember = prevChannelId ? myMembers[prevChannelId] : null; // May also be null

    const actions = [];

    if (channel && channelMember) {
      actions.push({
        type: _action_types.ChannelTypes.DECREMENT_UNREAD_MSG_COUNT,
        data: {
          teamId: channel.team_id,
          channelId,
          amount: channel.total_msg_count - channelMember.msg_count
        }
      });
      actions.push({
        type: _action_types.ChannelTypes.DECREMENT_UNREAD_MENTION_COUNT,
        data: {
          teamId: channel.team_id,
          channelId,
          amount: channelMember.mention_count
        }
      });
    }

    if (prevChannel && prevChannelMember) {
      actions.push({
        type: _action_types.ChannelTypes.DECREMENT_UNREAD_MSG_COUNT,
        data: {
          teamId: prevChannel.team_id,
          channelId: prevChannelId,
          amount: prevChannel.total_msg_count - prevChannelMember.msg_count
        }
      });
      actions.push({
        type: _action_types.ChannelTypes.DECREMENT_UNREAD_MENTION_COUNT,
        data: {
          teamId: prevChannel.team_id,
          channelId: prevChannelId,
          amount: prevChannelMember.mention_count
        }
      });
    }

    if (actions.length > 0) {
      dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    }

    return {
      data: true
    };
  };
} // Increments the number of posts in the channel by 1 and marks it as unread if necessary


function markChannelAsUnread(teamId
/*: string*/
, channelId
/*: string*/
, mentions
/*: Array<string>*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    const state = getState();
    const {
      myMembers
    } = state.entities.channels;
    const {
      currentUserId
    } = state.entities.users;
    const actions = [{
      type: _action_types.ChannelTypes.INCREMENT_TOTAL_MSG_COUNT,
      data: {
        channelId,
        amount: 1
      }
    }, {
      type: _action_types.ChannelTypes.INCREMENT_UNREAD_MSG_COUNT,
      data: {
        teamId,
        channelId,
        amount: 1,
        onlyMentions: myMembers[channelId] && myMembers[channelId].notify_props && myMembers[channelId].notify_props.mark_unread === _constants.General.MENTION
      }
    }];

    if (mentions && mentions.indexOf(currentUserId) !== -1) {
      actions.push({
        type: _action_types.ChannelTypes.INCREMENT_UNREAD_MENTION_COUNT,
        data: {
          teamId,
          channelId,
          amount: 1
        }
      });
    }

    dispatch((0, _reduxBatchedActions.batchActions)(actions), getState);
    return {
      data: true
    };
  };
}

function getChannelMembersByIds(channelId
/*: string*/
, userIds
/*: Array<string>*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getChannelMembersByIds,
    onSuccess: _action_types.ChannelTypes.RECEIVED_CHANNEL_MEMBERS,
    params: [channelId, userIds]
  });
}

function getChannelMember(channelId
/*: string*/
, userId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getChannelMember,
    onSuccess: _action_types.ChannelTypes.RECEIVED_CHANNEL_MEMBER,
    params: [channelId, userId]
  });
}

function getMyChannelMember(channelId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.getMyChannelMember,
    onSuccess: _action_types.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
    params: [channelId]
  });
}

function favoriteChannel(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    const {
      currentUserId
    } = getState().entities.users;
    const preference
    /*: PreferenceType*/
    = {
      user_id: currentUserId,
      category: _constants.Preferences.CATEGORY_FAVORITE_CHANNEL,
      name: channelId,
      value: 'true'
    };

    _client.Client4.trackEvent('action', 'action_channels_favorite');

    return (0, _preferences.savePreferences)(currentUserId, [preference])(dispatch);
  };
}

function unfavoriteChannel(channelId
/*: string*/
)
/*: ActionFunc*/
{
  return async (dispatch, getState) => {
    const {
      currentUserId
    } = getState().entities.users;
    const preference
    /*: PreferenceType*/
    = {
      user_id: currentUserId,
      category: _constants.Preferences.CATEGORY_FAVORITE_CHANNEL,
      name: channelId,
      value: ''
    };

    _client.Client4.trackEvent('action', 'action_channels_unfavorite');

    return (0, _preferences.deletePreferences)(currentUserId, [preference])(dispatch, getState);
  };
}

function updateChannelScheme(channelId
/*: string*/
, schemeId
/*: string*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: async () => {
      await _client.Client4.updateChannelScheme(channelId, schemeId);
      return {
        channelId,
        schemeId
      };
    },
    onSuccess: _action_types.ChannelTypes.UPDATED_CHANNEL_SCHEME
  });
}

function updateChannelMemberSchemeRoles(channelId
/*: string*/
, userId
/*: string*/
, isSchemeUser
/*: boolean*/
, isSchemeAdmin
/*: boolean*/
) {
  return (0, _helpers.bindClientFunc)({
    clientFunc: async () => {
      await _client.Client4.updateChannelMemberSchemeRoles(channelId, userId, isSchemeUser, isSchemeAdmin);
      return {
        channelId,
        userId,
        isSchemeUser,
        isSchemeAdmin
      };
    },
    onSuccess: _action_types.ChannelTypes.UPDATED_CHANNEL_MEMBER_SCHEME_ROLES
  });
}

function membersMinusGroupMembers(channelID
/*: string*/
, groupIDs
/*: Array<string>*/
, page
/*: number*/
= 0, perPage
/*: number*/
= _constants.General.PROFILE_CHUNK_SIZE)
/*: ActionFunc*/
{
  return (0, _helpers.bindClientFunc)({
    clientFunc: _client.Client4.channelMembersMinusGroupMembers,
    onSuccess: _action_types.ChannelTypes.RECEIVED_CHANNEL_MEMBERS_MINUS_GROUP_MEMBERS,
    params: [channelID, groupIDs, page, perPage]
  });
}

var _default = {
  selectChannel,
  createChannel,
  createDirectChannel,
  updateChannel,
  patchChannel,
  updateChannelNotifyProps,
  getChannel,
  fetchMyChannelsAndMembers,
  getMyChannelMembers,
  getChannelTimezones,
  getChannelMembersByIds,
  leaveChannel,
  joinChannel,
  deleteChannel,
  viewChannel,
  markChannelAsViewed,
  getChannels,
  autocompleteChannels,
  autocompleteChannelsForSearch,
  searchChannels,
  searchGroupChannels,
  getChannelStats,
  addChannelMember,
  removeChannelMember,
  updateChannelHeader,
  updateChannelPurpose,
  markChannelAsRead,
  markChannelAsUnread,
  favoriteChannel,
  unfavoriteChannel,
  membersMinusGroupMembers
};
exports.default = _default;