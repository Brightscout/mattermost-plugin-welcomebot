"use strict";

require("core-js/modules/es.promise");

require("core-js/modules/es.string.search");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMissingChannelsFromPosts = getMissingChannelsFromPosts;
exports.searchPostsWithParams = searchPostsWithParams;
exports.searchPosts = searchPosts;
exports.getMorePostsForSearch = getMorePostsForSearch;
exports.clearSearch = clearSearch;
exports.getFlaggedPosts = getFlaggedPosts;
exports.getPinnedPosts = getPinnedPosts;
exports.clearPinnedPosts = clearPinnedPosts;
exports.getRecentMentions = getRecentMentions;
exports.removeSearchTerms = removeSearchTerms;
exports.default = void 0;

var _reduxBatchedActions = require("redux-batched-actions");

var _client = require("../client");

var _action_types = require("../action_types");

var _teams = require("../selectors/entities/teams");

var _users = require("../selectors/entities/users");

var _channels = require("./channels");

var _helpers = require("./helpers");

var _errors = require("./errors");

var _posts = require("./posts");

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
const WEBAPP_SEARCH_PER_PAGE = 20;

function getMissingChannelsFromPosts(posts) {
  return async (dispatch, getState) => {
    const {
      channels,
      membersInChannel,
      myMembers
    } = getState().entities.channels;
    const promises = [];
    Object.values(posts).forEach(post => {
      const id = post.channel_id;

      if (!channels[id] || !myMembers[id]) {
        promises.push(dispatch((0, _channels.getChannelAndMyMember)(id)));
      }

      if (!membersInChannel[id]) {
        promises.push(dispatch((0, _channels.getChannelMembers)(id)));
      }
    });
    return Promise.all(promises);
  };
}

function searchPostsWithParams(teamId, params) {
  return async (dispatch, getState) => {
    const isGettingMore = params.page > 0;
    dispatch({
      type: _action_types.SearchTypes.SEARCH_POSTS_REQUEST,
      isGettingMore
    });
    let posts;

    try {
      posts = await _client.Client4.searchPostsWithParams(teamId, params);
      await Promise.all([(0, _posts.getProfilesAndStatusesForPosts)(posts.posts, dispatch, getState), dispatch(getMissingChannelsFromPosts(posts.posts))]);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.SearchTypes.SEARCH_POSTS_FAILURE,
        error
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.SearchTypes.RECEIVED_SEARCH_POSTS,
      data: posts,
      isGettingMore
    }, (0, _posts.receivedPosts)(posts), {
      type: _action_types.SearchTypes.RECEIVED_SEARCH_TERM,
      data: {
        teamId,
        params,
        isEnd: posts.order.length < params.per_page
      }
    }, {
      type: _action_types.SearchTypes.SEARCH_POSTS_SUCCESS
    }], 'SEARCH_POST_BATCH'));
    return {
      data: posts
    };
  };
}

function searchPosts(teamId, terms, isOrSearch, includeDeletedChannels) {
  return searchPostsWithParams(teamId, {
    terms,
    is_or_search: isOrSearch,
    include_deleted_channels: includeDeletedChannels,
    page: 0,
    per_page: WEBAPP_SEARCH_PER_PAGE
  });
}

function getMorePostsForSearch() {
  return async (dispatch, getState) => {
    const teamId = (0, _teams.getCurrentTeamId)(getState());
    const {
      params,
      isEnd
    } = getState().entities.search.current[teamId];

    if (!isEnd) {
      const newParams = Object.assign({}, params);
      newParams.page += 1;
      return dispatch(searchPostsWithParams(teamId, newParams));
    }

    return {};
  };
}

function clearSearch() {
  return async dispatch => {
    dispatch({
      type: _action_types.SearchTypes.REMOVE_SEARCH_POSTS
    });
    return {
      data: true
    };
  };
}

function getFlaggedPosts() {
  return async (dispatch, getState) => {
    const state = getState();
    const userId = (0, _users.getCurrentUserId)(state);
    const teamId = (0, _teams.getCurrentTeamId)(state);
    dispatch({
      type: _action_types.SearchTypes.SEARCH_FLAGGED_POSTS_REQUEST
    });
    let posts;

    try {
      posts = await _client.Client4.getFlaggedPosts(userId, '', teamId);
      await Promise.all([(0, _posts.getProfilesAndStatusesForPosts)(posts.posts, dispatch, getState), dispatch(getMissingChannelsFromPosts(posts.posts))]);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.SearchTypes.SEARCH_FLAGGED_POSTS_FAILURE,
        error
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.SearchTypes.RECEIVED_SEARCH_FLAGGED_POSTS,
      data: posts
    }, (0, _posts.receivedPosts)(posts), {
      type: _action_types.SearchTypes.SEARCH_FLAGGED_POSTS_SUCCESS
    }], 'SEARCH_FLAGGED_POSTS_BATCH'));
    return {
      data: posts
    };
  };
}

function getPinnedPosts(channelId) {
  return async (dispatch, getState) => {
    dispatch({
      type: _action_types.SearchTypes.SEARCH_PINNED_POSTS_REQUEST
    });
    let result;

    try {
      result = await _client.Client4.getPinnedPosts(channelId);
      await Promise.all([(0, _posts.getProfilesAndStatusesForPosts)(result.posts, dispatch, getState), dispatch(getMissingChannelsFromPosts(result.posts))]);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.SearchTypes.SEARCH_PINNED_POSTS_FAILURE,
        error
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.SearchTypes.RECEIVED_SEARCH_PINNED_POSTS,
      data: {
        pinned: result,
        channelId
      }
    }, (0, _posts.receivedPosts)(result), {
      type: _action_types.SearchTypes.SEARCH_PINNED_POSTS_SUCCESS
    }], 'SEARCH_PINNED_POSTS_BATCH'));
    return {
      data: result
    };
  };
}

function clearPinnedPosts(channelId) {
  return async dispatch => {
    dispatch({
      type: _action_types.SearchTypes.REMOVE_SEARCH_PINNED_POSTS,
      data: {
        channelId
      }
    });
    return {
      data: true
    };
  };
}

function getRecentMentions() {
  return async (dispatch, getState) => {
    const state = getState();
    const teamId = (0, _teams.getCurrentTeamId)(state);
    dispatch({
      type: _action_types.SearchTypes.SEARCH_RECENT_MENTIONS_REQUEST
    });
    let posts;

    try {
      const termKeys = (0, _users.getCurrentUserMentionKeys)(state).filter(({
        key
      }) => {
        return key !== '@channel' && key !== '@all' && key !== '@here';
      });
      const terms = termKeys.map(({
        key
      }) => key).join(' ').trim() + ' ';

      _client.Client4.trackEvent('api', 'api_posts_search_mention');

      posts = await _client.Client4.searchPosts(teamId, terms, true);
      await Promise.all([(0, _posts.getProfilesAndStatusesForPosts)(posts.posts, dispatch, getState), dispatch(getMissingChannelsFromPosts(posts.posts))]);
    } catch (error) {
      (0, _helpers.forceLogoutIfNecessary)(error, dispatch, getState);
      dispatch((0, _reduxBatchedActions.batchActions)([{
        type: _action_types.SearchTypes.SEARCH_RECENT_MENTIONS_FAILURE,
        error
      }, (0, _errors.logError)(error)]));
      return {
        error
      };
    }

    dispatch((0, _reduxBatchedActions.batchActions)([{
      type: _action_types.SearchTypes.RECEIVED_SEARCH_POSTS,
      data: posts
    }, (0, _posts.receivedPosts)(posts), {
      type: _action_types.SearchTypes.SEARCH_RECENT_MENTIONS_SUCCESS
    }], 'SEARCH_RECENT_MENTIONS_BATCH'));
    return {
      data: posts
    };
  };
}

function removeSearchTerms(teamId, terms) {
  return async dispatch => {
    dispatch({
      type: _action_types.SearchTypes.REMOVE_SEARCH_TERM,
      data: {
        teamId,
        terms
      }
    });
    return {
      data: true
    };
  };
}

var _default = {
  clearSearch,
  removeSearchTerms,
  searchPosts
};
exports.default = _default;