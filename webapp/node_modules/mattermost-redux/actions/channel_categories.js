"use strict";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var action_types_1 = require("../action_types");
var client_1 = require("../client");
var channels_1 = require("./channels");
var errors_1 = require("./errors");
var helpers_1 = require("./helpers");
var constants_1 = require("../constants");
var channel_categories_1 = require("../constants/channel_categories");
var channel_categories_2 = require("../selectors/entities/channel_categories");
var users_1 = require("../selectors/entities/users");
var actions_1 = require("../types/actions");
var channel_categories_3 = require("../types/channel_categories");
var array_utils_1 = require("../utils/array_utils");
function expandCategory(categoryId) {
    return {
        type: action_types_1.ChannelCategoryTypes.CATEGORY_EXPANDED,
        data: categoryId,
    };
}
exports.expandCategory = expandCategory;
function collapseCategory(categoryId) {
    return {
        type: action_types_1.ChannelCategoryTypes.CATEGORY_COLLAPSED,
        data: categoryId,
    };
}
exports.collapseCategory = collapseCategory;
function setCategorySorting(categoryId, sorting) {
    return function (dispatch, getState) {
        var state = getState();
        var category = channel_categories_2.getCategory(state, categoryId);
        return dispatch(updateCategory(tslib_1.__assign(tslib_1.__assign({}, category), { sorting: sorting })));
    };
}
exports.setCategorySorting = setCategorySorting;
function updateCategory(category) {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state, currentUserId, updatedCategory, error_1;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    state = getState();
                    currentUserId = users_1.getCurrentUserId(state);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, client_1.Client4.updateChannelCategory(currentUserId, category.team_id, category)];
                case 2:
                    updatedCategory = _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_1 = _a.sent();
                    helpers_1.forceLogoutIfNecessary(error_1, dispatch, getState);
                    dispatch(errors_1.logError(error_1));
                    return [2 /*return*/, { error: error_1 }];
                case 4: 
                // The updated category will be added to the state after receiving the corresponding websocket event.
                return [2 /*return*/, { data: updatedCategory }];
            }
        });
    }); };
}
exports.updateCategory = updateCategory;
function fetchMyCategories(teamId) {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var currentUserId, data, error_2;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    currentUserId = users_1.getCurrentUserId(getState());
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, client_1.Client4.getChannelCategories(currentUserId, teamId)];
                case 2:
                    data = _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_2 = _a.sent();
                    helpers_1.forceLogoutIfNecessary(error_2, dispatch, getState);
                    dispatch(errors_1.logError(error_2));
                    return [2 /*return*/, { error: error_2 }];
                case 4: return [2 /*return*/, dispatch(actions_1.batchActions([
                        {
                            type: action_types_1.ChannelCategoryTypes.RECEIVED_CATEGORIES,
                            data: data.categories,
                        },
                        {
                            type: action_types_1.ChannelCategoryTypes.RECEIVED_CATEGORY_ORDER,
                            data: {
                                teamId: teamId,
                                order: data.order,
                            },
                        },
                    ]))];
            }
        });
    }); };
}
exports.fetchMyCategories = fetchMyCategories;
// addChannelToInitialCategory returns an action that can be dispatched to add a newly-joined or newly-created channel
// to its either the Channels or Direct Messages category based on the type of channel. New DM and GM channels are
// added to the Direct Messages category on each team.
//
// Unless setOnServer is true, this only affects the categories on this client. If it is set to true, this updates
// categories on the server too.
function addChannelToInitialCategory(channel, setOnServer) {
    if (setOnServer === void 0) { setOnServer = false; }
    return function (dispatch, getState) {
        var state = getState();
        var categories = Object.values(channel_categories_2.getAllCategoriesByIds(state));
        if (channel.type === constants_1.General.DM_CHANNEL || channel.type === constants_1.General.GM_CHANNEL) {
            var allDmCategories = categories.filter(function (category) { return category.type === channel_categories_1.CategoryTypes.DIRECT_MESSAGES; });
            // Get all the categories in which channel exists
            var channelInCategories_1 = categories.filter(function (category) {
                return category.channel_ids.findIndex(function (channelId) { return channelId === channel.id; }) !== -1;
            });
            // Skip DM categories where channel already exists in a different category
            var dmCategories = allDmCategories.filter(function (dmCategory) {
                return channelInCategories_1.findIndex(function (category) { return dmCategory.team_id === category.team_id; }) === -1;
            });
            return dispatch({
                type: action_types_1.ChannelCategoryTypes.RECEIVED_CATEGORIES,
                data: dmCategories.map(function (category) { return (tslib_1.__assign(tslib_1.__assign({}, category), { channel_ids: array_utils_1.insertWithoutDuplicates(category.channel_ids, channel.id, 0) })); }),
            });
        }
        // Add the new channel to the Channels category on the channel's team
        if (categories.some(function (category) { return category.channel_ids.some(function (channelId) { return channelId === channel.id; }); })) {
            return { data: false };
        }
        var channelsCategory = channel_categories_2.getCategoryInTeamByType(state, channel.team_id, channel_categories_1.CategoryTypes.CHANNELS);
        if (!channelsCategory) {
            // No categories were found for this team, so the categories for this team haven't been loaded yet.
            // The channel will have been added to the category by the server, so we'll get it once the categories
            // are actually loaded.
            return { data: false };
        }
        if (setOnServer) {
            return dispatch(addChannelToCategory(channelsCategory.id, channel.id));
        }
        return dispatch({
            type: action_types_1.ChannelCategoryTypes.RECEIVED_CATEGORY,
            data: tslib_1.__assign(tslib_1.__assign({}, channelsCategory), { channel_ids: array_utils_1.insertWithoutDuplicates(channelsCategory.channel_ids, channel.id, 0) }),
        });
    };
}
exports.addChannelToInitialCategory = addChannelToInitialCategory;
// addChannelToCategory returns an action that can be dispatched to add a channel to a given category without specifying
// its order. The channel will be removed from its previous category (if any) on the given category's team and it will be
// placed first in its new category.
function addChannelToCategory(categoryId, channelId) {
    return moveChannelToCategory(categoryId, channelId, 0, false);
}
exports.addChannelToCategory = addChannelToCategory;
// moveChannelToCategory returns an action that moves a channel into a category and puts it at the given index at the
// category. The channel will also be removed from its previous category (if any) on that category's team. The category's
// order will also be set to manual by default.
function moveChannelToCategory(categoryId, channelId, newIndex, setManualSorting) {
    var _this = this;
    if (setManualSorting === void 0) { setManualSorting = true; }
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state, targetCategory, currentUserId, categories, sourceCategory, result, error_3, originalCategories;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    state = getState();
                    targetCategory = channel_categories_2.getCategory(state, categoryId);
                    currentUserId = users_1.getCurrentUserId(state);
                    categories = [tslib_1.__assign(tslib_1.__assign({}, targetCategory), { sorting: (setManualSorting && targetCategory.type !== channel_categories_1.CategoryTypes.DIRECT_MESSAGES) ? channel_categories_3.CategorySorting.Manual : targetCategory.sorting, channel_ids: array_utils_1.insertWithoutDuplicates(targetCategory.channel_ids, channelId, newIndex) })];
                    sourceCategory = channel_categories_2.getCategoryInTeamWithChannel(getState(), targetCategory.team_id, channelId);
                    if (sourceCategory && sourceCategory.id !== targetCategory.id) {
                        categories.push(tslib_1.__assign(tslib_1.__assign({}, sourceCategory), { channel_ids: array_utils_1.removeItem(sourceCategory.channel_ids, channelId) }));
                    }
                    result = dispatch({
                        type: action_types_1.ChannelCategoryTypes.RECEIVED_CATEGORIES,
                        data: categories,
                    });
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, client_1.Client4.updateChannelCategories(currentUserId, targetCategory.team_id, categories)];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_3 = _a.sent();
                    helpers_1.forceLogoutIfNecessary(error_3, dispatch, getState);
                    dispatch(errors_1.logError(error_3));
                    originalCategories = [targetCategory];
                    if (sourceCategory && sourceCategory.id !== targetCategory.id) {
                        originalCategories.push(sourceCategory);
                    }
                    dispatch({
                        type: action_types_1.ChannelCategoryTypes.RECEIVED_CATEGORIES,
                        data: originalCategories,
                    });
                    return [2 /*return*/, { error: error_3 }];
                case 4:
                    if (!(targetCategory.type === channel_categories_1.CategoryTypes.FAVORITES)) return [3 /*break*/, 6];
                    return [4 /*yield*/, dispatch(channels_1.favoriteChannel(channelId, false))];
                case 5:
                    _a.sent();
                    return [3 /*break*/, 8];
                case 6:
                    if (!(sourceCategory && sourceCategory.type === channel_categories_1.CategoryTypes.FAVORITES)) return [3 /*break*/, 8];
                    return [4 /*yield*/, dispatch(channels_1.unfavoriteChannel(channelId, false))];
                case 7:
                    _a.sent();
                    _a.label = 8;
                case 8: return [2 /*return*/, result];
            }
        });
    }); };
}
exports.moveChannelToCategory = moveChannelToCategory;
function moveCategory(teamId, categoryId, newIndex) {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state, order, currentUserId, newOrder, updatedOrder, error_4;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    state = getState();
                    order = channel_categories_2.getCategoryIdsForTeam(state, teamId);
                    currentUserId = users_1.getCurrentUserId(state);
                    newOrder = array_utils_1.insertWithoutDuplicates(order, categoryId, newIndex);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, client_1.Client4.updateChannelCategoryOrder(currentUserId, teamId, newOrder)];
                case 2:
                    updatedOrder = _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_4 = _a.sent();
                    helpers_1.forceLogoutIfNecessary(error_4, dispatch, getState);
                    dispatch(errors_1.logError(error_4));
                    return [2 /*return*/, { error: error_4 }];
                case 4: 
                // The order will be updated in the state after receiving the corresponding websocket event.
                return [2 /*return*/, { data: updatedOrder }];
            }
        });
    }); };
}
exports.moveCategory = moveCategory;
function receivedCategoryOrder(teamId, order) {
    return {
        type: action_types_1.ChannelCategoryTypes.RECEIVED_CATEGORY_ORDER,
        data: {
            teamId: teamId,
            order: order,
        },
    };
}
exports.receivedCategoryOrder = receivedCategoryOrder;
function createCategory(teamId, displayName, channelIds) {
    var _this = this;
    if (channelIds === void 0) { channelIds = []; }
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var currentUserId, newCategory, error_5;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    currentUserId = users_1.getCurrentUserId(getState());
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, client_1.Client4.createChannelCategory(currentUserId, teamId, {
                            team_id: teamId,
                            user_id: currentUserId,
                            display_name: displayName,
                            channel_ids: channelIds,
                        })];
                case 2:
                    newCategory = _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_5 = _a.sent();
                    helpers_1.forceLogoutIfNecessary(error_5, dispatch, getState);
                    dispatch(errors_1.logError(error_5));
                    return [2 /*return*/, { error: error_5 }];
                case 4: 
                // The new category will be added to the state after receiving the corresponding websocket event.
                return [2 /*return*/, { data: newCategory }];
            }
        });
    }); };
}
exports.createCategory = createCategory;
function renameCategory(categoryId, displayName) {
    return function (dispatch, getState) {
        var state = getState();
        var category = channel_categories_2.getCategory(state, categoryId);
        return dispatch(updateCategory(tslib_1.__assign(tslib_1.__assign({}, category), { display_name: displayName })));
    };
}
exports.renameCategory = renameCategory;
function deleteCategory(categoryId) {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state, category, currentUserId, error_6;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    state = getState();
                    category = channel_categories_2.getCategory(state, categoryId);
                    currentUserId = users_1.getCurrentUserId(state);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, client_1.Client4.deleteChannelCategory(currentUserId, category.team_id, category.id)];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_6 = _a.sent();
                    helpers_1.forceLogoutIfNecessary(error_6, dispatch, getState);
                    dispatch(errors_1.logError(error_6));
                    return [2 /*return*/, { error: error_6 }];
                case 4: 
                // The category will be deleted from the state after receiving the corresponding websocket event.
                return [2 /*return*/, { data: true }];
            }
        });
    }); };
}
exports.deleteCategory = deleteCategory;
//# sourceMappingURL=channel_categories.js.map