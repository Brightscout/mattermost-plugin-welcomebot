"use strict";
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var client_1 = require("../client");
var websocket_client_1 = tslib_1.__importDefault(require("../client/websocket_client"));
var action_types_1 = require("../action_types");
var constants_1 = require("../constants");
var channels_1 = require("../selectors/entities/channels");
var general_1 = require("../selectors/entities/general");
var posts_1 = require("../selectors/entities/posts");
var preferences_1 = require("../selectors/entities/preferences");
var teams_1 = require("../selectors/entities/teams");
var users_1 = require("../selectors/entities/users");
var channel_utils_1 = require("../utils/channel_utils");
var post_utils_1 = require("../utils/post_utils");
var event_emitter_1 = tslib_1.__importDefault(require("../utils/event_emitter"));
var preferences_2 = require("./preferences");
var actions_1 = require("../types/actions");
var teams_2 = require("./teams");
var posts_2 = require("./posts");
var channels_2 = require("./channels");
var users_2 = require("./users");
var roles_1 = require("./roles");
var user_utils_1 = require("../utils/user_utils");
var doDispatch;
function init(platform, siteUrl, token, optionalWebSocket, additionalOptions) {
    var _this = this;
    if (additionalOptions === void 0) { additionalOptions = {}; }
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var config, connUrl, authToken, websocketOpts;
        return tslib_1.__generator(this, function (_a) {
            config = general_1.getConfig(getState());
            connUrl = siteUrl || config.WebsocketURL || client_1.Client4.getUrl();
            authToken = token || client_1.Client4.getToken();
            // Set the dispatch and getState globally
            doDispatch = dispatch;
            // replace the protocol with a websocket one
            if (platform !== 'ios' && platform !== 'android') {
                if (connUrl.startsWith('https:')) {
                    connUrl = connUrl.replace(/^https:/, 'wss:');
                }
                else {
                    connUrl = connUrl.replace(/^http:/, 'ws:');
                }
                // append a port number if one isn't already specified
                if (!(/:\d+$/).test(connUrl)) {
                    if (connUrl.startsWith('wss:')) {
                        connUrl += ':' + (config.WebsocketSecurePort || 443);
                    }
                    else {
                        connUrl += ':' + (config.WebsocketPort || 80);
                    }
                }
            }
            connUrl += client_1.Client4.getUrlVersion() + "/websocket";
            websocket_client_1.default.setFirstConnectCallback(handleFirstConnect);
            websocket_client_1.default.setEventCallback(handleEvent);
            websocket_client_1.default.setReconnectCallback(handleReconnect);
            websocket_client_1.default.setCloseCallback(handleClose);
            websocket_client_1.default.setConnectingCallback(handleConnecting);
            websocketOpts = tslib_1.__assign({ connectionUrl: connUrl, platform: platform }, additionalOptions);
            if (optionalWebSocket) {
                websocketOpts.webSocketConnector = optionalWebSocket;
            }
            return [2 /*return*/, websocket_client_1.default.initialize(authToken, websocketOpts)];
        });
    }); };
}
exports.init = init;
var reconnect = false;
function close(shouldReconnect) {
    var _this = this;
    if (shouldReconnect === void 0) { shouldReconnect = false; }
    return function (dispatch) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            reconnect = shouldReconnect;
            websocket_client_1.default.close(true);
            if (dispatch) {
                dispatch({
                    type: action_types_1.GeneralTypes.WEBSOCKET_CLOSED,
                    timestamp: Date.now(),
                    data: null,
                });
            }
            return [2 /*return*/];
        });
    }); };
}
exports.close = close;
function doFirstConnect(now) {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state;
        return tslib_1.__generator(this, function (_a) {
            state = getState();
            if (state.websocket.lastDisconnectAt) {
                dispatch(users_2.checkForModifiedUsers());
            }
            dispatch({
                type: action_types_1.GeneralTypes.WEBSOCKET_SUCCESS,
                timestamp: now,
                data: null,
            });
            return [2 /*return*/, { data: true }];
        });
    }); };
}
exports.doFirstConnect = doFirstConnect;
function doReconnect(now) {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state, currentTeamId, currentChannelId, currentUserId, dmPrefs, statusesToLoad, dmPrefs_1, dmPrefs_1_1, pref, currentTeamMembership, currentChannel, fethcResult, data, channelStillExists, stillMemberOfCurrentChannel, config, viewArchivedChannels, newMsg;
        var _a, e_1, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, dispatch(preferences_2.getMyPreferences())];
                case 1:
                    _c.sent();
                    state = getState();
                    currentTeamId = teams_1.getCurrentTeamId(state);
                    currentChannelId = channels_1.getCurrentChannelId(state);
                    currentUserId = users_1.getCurrentUserId(state);
                    if (!currentTeamId) return [3 /*break*/, 6];
                    dmPrefs = preferences_1.getDirectShowPreferences(state);
                    statusesToLoad = (_a = {},
                        _a[currentUserId] = true,
                        _a);
                    try {
                        for (dmPrefs_1 = tslib_1.__values(dmPrefs), dmPrefs_1_1 = dmPrefs_1.next(); !dmPrefs_1_1.done; dmPrefs_1_1 = dmPrefs_1.next()) {
                            pref = dmPrefs_1_1.value;
                            if (pref.value === 'true') {
                                statusesToLoad[pref.name] = true;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (dmPrefs_1_1 && !dmPrefs_1_1.done && (_b = dmPrefs_1.return)) _b.call(dmPrefs_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    dispatch(users_2.getStatusesByIds(Object.keys(statusesToLoad)));
                    dispatch(teams_2.getMyTeamUnreads());
                    // We need to wait for these actions so that we have an
                    // up-to-date state of the current user's team memberships.
                    return [4 /*yield*/, dispatch(teams_2.getMyTeams())];
                case 2:
                    // We need to wait for these actions so that we have an
                    // up-to-date state of the current user's team memberships.
                    _c.sent();
                    return [4 /*yield*/, dispatch(teams_2.getMyTeamMembers())];
                case 3:
                    _c.sent();
                    currentTeamMembership = teams_1.getCurrentTeamMembership(getState());
                    if (!currentTeamMembership) return [3 /*break*/, 5];
                    currentChannel = channels_1.getCurrentChannel(state);
                    return [4 /*yield*/, dispatch(channels_2.fetchMyChannelsAndMembers(currentTeamId))];
                case 4:
                    fethcResult = _c.sent();
                    data = fethcResult.data || null;
                    dispatch(users_2.loadProfilesForDirect());
                    if (data && data.channels && data.members) {
                        channelStillExists = data.channels.find(function (c) { return c.id === currentChannelId; });
                        stillMemberOfCurrentChannel = data.members.find(function (m) { return m.channel_id === currentChannelId; });
                        config = general_1.getConfig(getState());
                        viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';
                        if (!stillMemberOfCurrentChannel || !channelStillExists || (!viewArchivedChannels && currentChannel.delete_at !== 0)) {
                            event_emitter_1.default.emit(constants_1.General.SWITCH_TO_DEFAULT_CHANNEL, currentTeamId);
                        }
                        else {
                            dispatch(posts_2.getPosts(currentChannelId));
                        }
                    }
                    return [3 /*break*/, 6];
                case 5:
                    newMsg = {
                        data: {
                            user_id: currentUserId,
                            team_id: currentTeamId,
                        },
                    };
                    dispatch(handleLeaveTeamEvent(newMsg));
                    _c.label = 6;
                case 6:
                    dispatch(users_2.checkForModifiedUsers());
                    dispatch({
                        type: action_types_1.GeneralTypes.WEBSOCKET_SUCCESS,
                        timestamp: now,
                        data: null,
                    });
                    return [2 /*return*/, { data: true }];
            }
        });
    }); };
}
exports.doReconnect = doReconnect;
function handleConnecting() {
    doDispatch({ type: action_types_1.GeneralTypes.WEBSOCKET_REQUEST, data: null });
}
function handleFirstConnect() {
    var now = Date.now();
    if (reconnect) {
        reconnect = false;
        doDispatch(doReconnect(now));
    }
    else {
        doDispatch(doFirstConnect(now));
    }
}
function handleReconnect() {
    doDispatch(doReconnect(Date.now()));
}
function handleClose(connectFailCount) {
    doDispatch({
        type: action_types_1.GeneralTypes.WEBSOCKET_FAILURE,
        error: connectFailCount,
        data: null,
        timestamp: Date.now(),
    });
}
function handleEvent(msg) {
    switch (msg.event) {
        case constants_1.WebsocketEvents.POSTED:
        case constants_1.WebsocketEvents.EPHEMERAL_MESSAGE:
            doDispatch(handleNewPostEvent(msg));
            break;
        case constants_1.WebsocketEvents.POST_EDITED:
            doDispatch(handlePostEdited(msg));
            break;
        case constants_1.WebsocketEvents.POST_DELETED:
            doDispatch(handlePostDeleted(msg));
            break;
        case constants_1.WebsocketEvents.POST_UNREAD:
            doDispatch(handlePostUnread(msg));
            break;
        case constants_1.WebsocketEvents.LEAVE_TEAM:
            doDispatch(handleLeaveTeamEvent(msg));
            break;
        case constants_1.WebsocketEvents.UPDATE_TEAM:
            doDispatch(handleUpdateTeamEvent(msg));
            break;
        case constants_1.WebsocketEvents.ADDED_TO_TEAM:
            doDispatch(handleTeamAddedEvent(msg));
            break;
        case constants_1.WebsocketEvents.USER_ADDED:
            doDispatch(handleUserAddedEvent(msg));
            break;
        case constants_1.WebsocketEvents.USER_REMOVED:
            doDispatch(handleUserRemovedEvent(msg));
            break;
        case constants_1.WebsocketEvents.USER_UPDATED:
            doDispatch(handleUserUpdatedEvent(msg));
            break;
        case constants_1.WebsocketEvents.ROLE_ADDED:
            doDispatch(handleRoleAddedEvent(msg));
            break;
        case constants_1.WebsocketEvents.ROLE_REMOVED:
            doDispatch(handleRoleRemovedEvent(msg));
            break;
        case constants_1.WebsocketEvents.ROLE_UPDATED:
            doDispatch(handleRoleUpdatedEvent(msg));
            break;
        case constants_1.WebsocketEvents.USER_ROLE_UPDATED:
            doDispatch(handleUserRoleUpdated(msg));
            break;
        case constants_1.WebsocketEvents.CHANNEL_CREATED:
            doDispatch(handleChannelCreatedEvent(msg));
            break;
        case constants_1.WebsocketEvents.CHANNEL_DELETED:
            doDispatch(handleChannelDeletedEvent(msg));
            break;
        case constants_1.WebsocketEvents.CHANNEL_UNARCHIVED:
            doDispatch(handleChannelUnarchiveEvent(msg));
            break;
        case constants_1.WebsocketEvents.CHANNEL_UPDATED:
            doDispatch(handleChannelUpdatedEvent(msg));
            break;
        case constants_1.WebsocketEvents.CHANNEL_CONVERTED:
            doDispatch(handleChannelConvertedEvent(msg));
            break;
        case constants_1.WebsocketEvents.CHANNEL_VIEWED:
            doDispatch(handleChannelViewedEvent(msg));
            break;
        case constants_1.WebsocketEvents.CHANNEL_MEMBER_UPDATED:
            doDispatch(handleChannelMemberUpdatedEvent(msg));
            break;
        case constants_1.WebsocketEvents.CHANNEL_SCHEME_UPDATED:
            doDispatch(handleChannelSchemeUpdatedEvent(msg));
            break;
        case constants_1.WebsocketEvents.DIRECT_ADDED:
            doDispatch(handleDirectAddedEvent(msg));
            break;
        case constants_1.WebsocketEvents.PREFERENCE_CHANGED:
            doDispatch(handlePreferenceChangedEvent(msg));
            break;
        case constants_1.WebsocketEvents.PREFERENCES_CHANGED:
            doDispatch(handlePreferencesChangedEvent(msg));
            break;
        case constants_1.WebsocketEvents.PREFERENCES_DELETED:
            doDispatch(handlePreferencesDeletedEvent(msg));
            break;
        case constants_1.WebsocketEvents.STATUS_CHANGED:
            doDispatch(handleStatusChangedEvent(msg));
            break;
        case constants_1.WebsocketEvents.TYPING:
            doDispatch(handleUserTypingEvent(msg));
            break;
        case constants_1.WebsocketEvents.HELLO:
            handleHelloEvent(msg);
            break;
        case constants_1.WebsocketEvents.REACTION_ADDED:
            doDispatch(handleReactionAddedEvent(msg));
            break;
        case constants_1.WebsocketEvents.REACTION_REMOVED:
            doDispatch(handleReactionRemovedEvent(msg));
            break;
        case constants_1.WebsocketEvents.EMOJI_ADDED:
            doDispatch(handleAddEmoji(msg));
            break;
        case constants_1.WebsocketEvents.LICENSE_CHANGED:
            doDispatch(handleLicenseChangedEvent(msg));
            break;
        case constants_1.WebsocketEvents.CONFIG_CHANGED:
            doDispatch(handleConfigChangedEvent(msg));
            break;
        case constants_1.WebsocketEvents.PLUGIN_STATUSES_CHANGED:
            doDispatch(handlePluginStatusesChangedEvent(msg));
            break;
        case constants_1.WebsocketEvents.OPEN_DIALOG:
            doDispatch(handleOpenDialogEvent(msg));
            break;
        case constants_1.WebsocketEvents.RECEIVED_GROUP:
            doDispatch(handleGroupUpdatedEvent(msg));
            break;
        case constants_1.WebsocketEvents.RECEIVED_GROUP_ASSOCIATED_TO_TEAM:
            doDispatch(handleReceivedGroupAssociatedToTeamEvent(msg));
            break;
        case constants_1.WebsocketEvents.RECEIVED_GROUP_NOT_ASSOCIATED_TO_TEAM:
            doDispatch(handleReceivedGroupNotAssociatedToTeamEvent(msg));
            break;
        case constants_1.WebsocketEvents.RECEIVED_GROUP_ASSOCIATED_TO_CHANNEL:
            doDispatch(handleReceivedGroupAssociatedToChannelEvent(msg));
            break;
        case constants_1.WebsocketEvents.RECEIVED_GROUP_NOT_ASSOCIATED_TO_CHANNEL:
            doDispatch(handleReceivedGroupNotAssociatedToChannelEvent(msg));
            break;
        case constants_1.WebsocketEvents.WARN_METRIC_STATUS_RECEIVED:
            doDispatch(handleWarnMetricStatusReceivedEvent(msg));
            break;
        case constants_1.WebsocketEvents.WARN_METRIC_STATUS_REMOVED:
            doDispatch(handleWarnMetricStatusRemovedEvent(msg));
            break;
    }
}
function handleNewPostEvent(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var post = JSON.parse(msg.data.post);
        var exists = posts_1.getPost(state, post.pending_post_id);
        if (!exists) {
            if (channels_1.getCurrentChannelId(state) === post.channel_id) {
                event_emitter_1.default.emit(constants_1.WebsocketEvents.INCREASE_POST_VISIBILITY_BY_ONE);
            }
            dispatch(posts_2.handleNewPost(msg));
            posts_2.getProfilesAndStatusesForPosts([post], dispatch, getState);
            if (post.user_id !== users_1.getCurrentUserId(getState()) && !post_utils_1.fromAutoResponder(post) && !users_1.getIsManualStatusForUserId(state, post.user_id)) {
                dispatch({
                    type: action_types_1.UserTypes.RECEIVED_STATUSES,
                    data: [{ user_id: post.user_id, status: constants_1.General.ONLINE }],
                });
            }
        }
        return { data: true };
    };
}
function handlePostEdited(msg) {
    return function (dispatch, getState) {
        var data = JSON.parse(msg.data.post);
        posts_2.getProfilesAndStatusesForPosts([data], dispatch, getState);
        dispatch(posts_2.receivedPost(data));
        return { data: true };
    };
}
function handlePostDeleted(msg) {
    var data = JSON.parse(msg.data.post);
    return posts_2.postDeleted(data);
}
function handlePostUnread(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var manual = channels_1.isManuallyUnread(state, msg.broadcast.channel_id);
        if (!manual) {
            var member = channels_1.getMyChannelMember(state, msg.broadcast.channel_id);
            var delta = member ? member.msg_count - msg.data.msg_count : msg.data.msg_count;
            var info = tslib_1.__assign(tslib_1.__assign({}, msg.data), { user_id: msg.broadcast.user_id, team_id: msg.broadcast.team_id, channel_id: msg.broadcast.channel_id, deltaMsgs: delta });
            var data = posts_2.getUnreadPostData(info, state);
            dispatch({
                type: action_types_1.ChannelTypes.POST_UNREAD_SUCCESS,
                data: data,
            });
            return { data: data };
        }
        return { data: null };
    };
}
function handleLeaveTeamEvent(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var teams = teams_1.getTeams(state);
        var currentTeamId = teams_1.getCurrentTeamId(state);
        var currentUser = users_1.getCurrentUser(state);
        if (currentUser.id === msg.data.user_id) {
            if (user_utils_1.isGuest(currentUser.roles)) {
                dispatch(removeNotVisibleUsers());
            }
            dispatch({ type: action_types_1.TeamTypes.LEAVE_TEAM, data: teams[msg.data.team_id] });
            // if they are on the team being removed deselect the current team and channel
            if (currentTeamId === msg.data.team_id) {
                event_emitter_1.default.emit('leave_team');
            }
        }
        return { data: true };
    };
}
function handleUpdateTeamEvent(msg) {
    return {
        type: action_types_1.TeamTypes.UPDATED_TEAM,
        data: JSON.parse(msg.data.team),
    };
}
function handleTeamAddedEvent(msg) {
    var _this = this;
    return function (dispatch) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Promise.all([
                        dispatch(teams_2.getTeam(msg.data.team_id)),
                        dispatch(teams_2.getMyTeamUnreads()),
                    ])];
                case 1:
                    _a.sent();
                    return [2 /*return*/, { data: true }];
            }
        });
    }); };
}
function handleUserRoleUpdated(msg) {
    return function (dispatch) {
        var roles = msg.data.roles.split(' ');
        dispatch(roles_1.loadRolesIfNeeded(roles));
        return { data: true };
    };
}
function handleUserAddedEvent(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var currentChannelId = channels_1.getCurrentChannelId(state);
        var currentTeamId = teams_1.getCurrentTeamId(state);
        var currentUserId = users_1.getCurrentUserId(state);
        var teamId = msg.data.team_id;
        dispatch({
            type: action_types_1.ChannelTypes.CHANNEL_MEMBER_ADDED,
            data: {
                channel_id: msg.broadcast.channel_id,
                user_id: msg.data.user_id,
            },
        });
        if (msg.broadcast.channel_id === currentChannelId) {
            dispatch(channels_2.getChannelStats(currentChannelId));
        }
        if (teamId === currentTeamId && msg.data.user_id === currentUserId) {
            dispatch(channels_2.getChannelAndMyMember(msg.broadcast.channel_id));
        }
        return { data: true };
    };
}
function handleUserRemovedEvent(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var channels = channels_1.getAllChannels(state);
        var currentChannelId = channels_1.getCurrentChannelId(state);
        var currentTeamId = teams_1.getCurrentTeamId(state);
        var currentUser = users_1.getCurrentUser(state);
        dispatch({
            type: action_types_1.ChannelTypes.CHANNEL_MEMBER_REMOVED,
            data: {
                channel_id: msg.broadcast.channel_id,
                user_id: msg.data.user_id,
            },
        });
        var channel = channels[currentChannelId];
        if (msg.data.user_id !== currentUser.id) {
            var members = channels_1.getChannelMembersInChannels(state);
            var isMember = Object.values(members).some(function (member) { return member[msg.data.user_id]; });
            if (channel && user_utils_1.isGuest(currentUser.roles) && !isMember) {
                var actions = [
                    {
                        type: action_types_1.UserTypes.PROFILE_NO_LONGER_VISIBLE,
                        data: { user_id: msg.data.user_id },
                    },
                    {
                        type: action_types_1.TeamTypes.REMOVE_MEMBER_FROM_TEAM,
                        data: { team_id: channel.team_id, user_id: msg.data.user_id },
                    },
                ];
                dispatch(actions_1.batchActions(actions));
            }
        }
        if (msg.broadcast.user_id === currentUser.id && currentTeamId) {
            dispatch(channels_2.fetchMyChannelsAndMembers(currentTeamId));
            if (channel) {
                dispatch({
                    type: action_types_1.ChannelTypes.LEAVE_CHANNEL,
                    data: {
                        id: msg.data.channel_id,
                        user_id: currentUser.id,
                        team_id: channel.team_id,
                        type: channel.type,
                    },
                });
            }
            if (msg.data.channel_id === currentChannelId) {
                // emit the event so the client can change his own state
                event_emitter_1.default.emit(constants_1.General.SWITCH_TO_DEFAULT_CHANNEL, currentTeamId);
            }
            if (user_utils_1.isGuest(currentUser.roles)) {
                dispatch(removeNotVisibleUsers());
            }
        }
        else if (msg.data.channel_id === currentChannelId) {
            dispatch(channels_2.getChannelStats(currentChannelId));
        }
        return { data: true };
    };
}
function handleUserUpdatedEvent(msg) {
    return function (dispatch, getState) {
        var _a;
        var currentUser = users_1.getCurrentUser(getState());
        var user = msg.data.user;
        if (user.id === currentUser.id) {
            if (user.update_at > currentUser.update_at) {
                // Need to request me to make sure we don't override with sanitized fields from the
                // websocket event
                dispatch(users_2.getMe());
            }
        }
        else {
            dispatch({
                type: action_types_1.UserTypes.RECEIVED_PROFILES,
                data: (_a = {},
                    _a[user.id] = user,
                    _a),
            });
        }
        return { data: true };
    };
}
function handleRoleAddedEvent(msg) {
    var role = JSON.parse(msg.data.role);
    return {
        type: action_types_1.RoleTypes.RECEIVED_ROLE,
        data: role,
    };
}
function handleRoleRemovedEvent(msg) {
    var role = JSON.parse(msg.data.role);
    return {
        type: action_types_1.RoleTypes.ROLE_DELETED,
        data: role,
    };
}
function handleRoleUpdatedEvent(msg) {
    var role = JSON.parse(msg.data.role);
    return {
        type: action_types_1.RoleTypes.RECEIVED_ROLE,
        data: role,
    };
}
function handleChannelCreatedEvent(msg) {
    return function (dispatch, getState) {
        var _a = msg.data, channelId = _a.channel_id, teamId = _a.team_id;
        var state = getState();
        var channels = channels_1.getAllChannels(state);
        var currentTeamId = teams_1.getCurrentTeamId(state);
        if (teamId === currentTeamId && !channels[channelId]) {
            dispatch(channels_2.getChannelAndMyMember(channelId));
        }
        return { data: true };
    };
}
function handleChannelDeletedEvent(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var currentChannelId = channels_1.getCurrentChannelId(state);
        var currentTeamId = teams_1.getCurrentTeamId(state);
        var config = general_1.getConfig(state);
        var viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';
        dispatch({ type: action_types_1.ChannelTypes.RECEIVED_CHANNEL_DELETED, data: { id: msg.data.channel_id, deleteAt: msg.data.delete_at, team_id: msg.broadcast.team_id, viewArchivedChannels: viewArchivedChannels } });
        if (msg.broadcast.team_id === currentTeamId) {
            if (msg.data.channel_id === currentChannelId && !viewArchivedChannels) {
                var channelsInTeam = channels_1.getChannelsNameMapInTeam(state, currentTeamId);
                var channel = channel_utils_1.getChannelByName(channelsInTeam, channels_1.getRedirectChannelNameForTeam(state, currentTeamId));
                if (channel && channel.id) {
                    dispatch({ type: action_types_1.ChannelTypes.SELECT_CHANNEL, data: channel.id });
                }
                event_emitter_1.default.emit(constants_1.General.DEFAULT_CHANNEL, '');
            }
        }
        return { data: true };
    };
}
function handleChannelUnarchiveEvent(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var currentTeamId = teams_1.getCurrentTeamId(state);
        var config = general_1.getConfig(state);
        var viewArchivedChannels = config.ExperimentalViewArchivedChannels === 'true';
        if (msg.broadcast.team_id === currentTeamId) {
            dispatch({ type: action_types_1.ChannelTypes.RECEIVED_CHANNEL_UNARCHIVED, data: { id: msg.data.channel_id, team_id: msg.data.team_id, deleteAt: 0, viewArchivedChannels: viewArchivedChannels } });
            dispatch(channels_2.fetchMyChannelsAndMembers(currentTeamId));
        }
        return { data: true };
    };
}
function handleChannelUpdatedEvent(msg) {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var channel, currentChannelId;
        return tslib_1.__generator(this, function (_a) {
            try {
                channel = msg.data ? JSON.parse(msg.data.channel) : null;
            }
            catch (err) {
                return [2 /*return*/, { error: err }];
            }
            currentChannelId = channels_1.getCurrentChannelId(getState());
            if (channel) {
                dispatch({
                    type: action_types_1.ChannelTypes.RECEIVED_CHANNEL,
                    data: channel,
                });
                if (currentChannelId === channel.id) {
                    // Emit an event with the channel received as we need to handle
                    // the changes without listening to the store
                    event_emitter_1.default.emit(constants_1.WebsocketEvents.CHANNEL_UPDATED, channel);
                }
            }
            return [2 /*return*/, { data: true }];
        });
    }); };
}
// handleChannelConvertedEvent handles updating of channel which is converted from public to private
function handleChannelConvertedEvent(msg) {
    return function (dispatch, getState) {
        var channelId = msg.data.channel_id;
        if (channelId) {
            var channel = channels_1.getChannel(getState(), channelId);
            if (channel) {
                dispatch({
                    type: action_types_1.ChannelTypes.RECEIVED_CHANNEL,
                    data: tslib_1.__assign(tslib_1.__assign({}, channel), { type: constants_1.General.PRIVATE_CHANNEL }),
                });
            }
        }
        return { data: true };
    };
}
function handleChannelViewedEvent(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var channelId = msg.data.channel_id;
        var currentChannelId = channels_1.getCurrentChannelId(state);
        var currentUserId = users_1.getCurrentUserId(state);
        if (channelId !== currentChannelId && currentUserId === msg.broadcast.user_id) {
            dispatch(channels_2.markChannelAsRead(channelId, undefined, false));
        }
        return { data: true };
    };
}
function handleChannelMemberUpdatedEvent(msg) {
    return function (dispatch) {
        var channelMember = JSON.parse(msg.data.channelMember);
        var roles = channelMember.roles.split(' ');
        dispatch(roles_1.loadRolesIfNeeded(roles));
        dispatch({
            type: action_types_1.ChannelTypes.RECEIVED_MY_CHANNEL_MEMBER,
            data: channelMember,
        });
        return { data: true };
    };
}
function handleChannelSchemeUpdatedEvent(msg) {
    return function (dispatch) {
        dispatch(channels_2.getMyChannelMember(msg.broadcast.channel_id));
        return { data: true };
    };
}
function handleDirectAddedEvent(msg) {
    return function (dispatch) {
        dispatch(channels_2.getChannelAndMyMember(msg.broadcast.channel_id));
        return { data: true };
    };
}
function handlePreferenceChangedEvent(msg) {
    return function (dispatch) {
        var preference = JSON.parse(msg.data.preference);
        dispatch({ type: action_types_1.PreferenceTypes.RECEIVED_PREFERENCES, data: [preference] });
        dispatch(getAddedDmUsersIfNecessary([preference]));
        return { data: true };
    };
}
function handlePreferencesChangedEvent(msg) {
    return function (dispatch, getState) {
        var preferences = JSON.parse(msg.data.preferences);
        var posts = posts_1.getAllPosts(getState());
        preferences.forEach(function (pref) {
            if (pref.category === constants_1.Preferences.CATEGORY_FLAGGED_POST && !posts[pref.name]) {
                dispatch(posts_2.getPost(pref.name));
            }
        });
        dispatch(getAddedDmUsersIfNecessary(preferences));
        dispatch({ type: action_types_1.PreferenceTypes.RECEIVED_PREFERENCES, data: preferences });
        return { data: true };
    };
}
function handlePreferencesDeletedEvent(msg) {
    var preferences = JSON.parse(msg.data.preferences);
    return { type: action_types_1.PreferenceTypes.DELETED_PREFERENCES, data: preferences };
}
function handleStatusChangedEvent(msg) {
    return {
        type: action_types_1.UserTypes.RECEIVED_STATUSES,
        data: [{ user_id: msg.data.user_id, status: msg.data.status }],
    };
}
function handleHelloEvent(msg) {
    var serverVersion = msg.data.server_version;
    if (serverVersion && client_1.Client4.serverVersion !== serverVersion) {
        client_1.Client4.serverVersion = serverVersion;
        event_emitter_1.default.emit(constants_1.General.SERVER_VERSION_CHANGED, serverVersion);
    }
}
function handleUserTypingEvent(msg) {
    return function (dispatch, getState) {
        var state = getState();
        var currentChannelId = channels_1.getCurrentChannelId(state);
        if (currentChannelId === msg.broadcast.channel_id) {
            var profiles = users_1.getUsers(state);
            var statuses = users_1.getUserStatuses(state);
            var currentUserId = users_1.getCurrentUserId(state);
            var config = general_1.getConfig(state);
            var userId = msg.data.user_id;
            var data_1 = {
                id: msg.broadcast.channel_id + msg.data.parent_id,
                userId: userId,
                now: Date.now(),
            };
            dispatch({
                type: constants_1.WebsocketEvents.TYPING,
                data: data_1,
            });
            setTimeout(function () {
                dispatch({
                    type: constants_1.WebsocketEvents.STOP_TYPING,
                    data: data_1,
                });
            }, parseInt(config.TimeBetweenUserTypingUpdatesMilliseconds, 10));
            if (!profiles[userId] && userId !== currentUserId) {
                dispatch(users_2.getProfilesByIds([userId]));
            }
            var status_1 = statuses[userId];
            if (status_1 !== constants_1.General.ONLINE) {
                dispatch(users_2.getStatusesByIds([userId]));
            }
        }
        return { data: true };
    };
}
exports.handleUserTypingEvent = handleUserTypingEvent;
function handleReactionAddedEvent(msg) {
    return function (dispatch) {
        var data = msg.data;
        var reaction = JSON.parse(data.reaction);
        dispatch(posts_2.getCustomEmojiForReaction(reaction.emoji_name));
        dispatch({
            type: action_types_1.PostTypes.RECEIVED_REACTION,
            data: reaction,
        });
        return { data: true };
    };
}
function handleReactionRemovedEvent(msg) {
    var data = msg.data;
    var reaction = JSON.parse(data.reaction);
    return {
        type: action_types_1.PostTypes.REACTION_DELETED,
        data: reaction,
    };
}
function handleAddEmoji(msg) {
    var data = JSON.parse(msg.data.emoji);
    return {
        type: action_types_1.EmojiTypes.RECEIVED_CUSTOM_EMOJI,
        data: data,
    };
}
function handleLicenseChangedEvent(msg) {
    var data = msg.data.license;
    return {
        type: action_types_1.GeneralTypes.CLIENT_LICENSE_RECEIVED,
        data: data,
    };
}
function handleConfigChangedEvent(msg) {
    var data = msg.data.config;
    event_emitter_1.default.emit(constants_1.General.CONFIG_CHANGED, data);
    return {
        type: action_types_1.GeneralTypes.CLIENT_CONFIG_RECEIVED,
        data: data,
    };
}
function handlePluginStatusesChangedEvent(msg) {
    var data = msg.data;
    return {
        type: action_types_1.AdminTypes.RECEIVED_PLUGIN_STATUSES,
        data: data.plugin_statuses,
    };
}
function handleOpenDialogEvent(msg) {
    return function (dispatch) {
        var data = (msg.data && msg.data.dialog) || {};
        dispatch({ type: action_types_1.IntegrationTypes.RECEIVED_DIALOG, data: JSON.parse(data) });
        return { data: true };
    };
}
// Helpers
function getAddedDmUsersIfNecessary(preferences) {
    return function (dispatch, getState) {
        var e_2, _a, e_3, _b;
        var userIds = [];
        try {
            for (var preferences_3 = tslib_1.__values(preferences), preferences_3_1 = preferences_3.next(); !preferences_3_1.done; preferences_3_1 = preferences_3.next()) {
                var preference = preferences_3_1.value;
                if (preference.category === constants_1.Preferences.CATEGORY_DIRECT_CHANNEL_SHOW && preference.value === 'true') {
                    userIds.push(preference.name);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (preferences_3_1 && !preferences_3_1.done && (_a = preferences_3.return)) _a.call(preferences_3);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (userIds.length === 0) {
            return { data: true };
        }
        var state = getState();
        var profiles = users_1.getUsers(state);
        var statuses = users_1.getUserStatuses(state);
        var currentUserId = users_1.getCurrentUserId(state);
        var needProfiles = [];
        var needStatuses = [];
        try {
            for (var userIds_1 = tslib_1.__values(userIds), userIds_1_1 = userIds_1.next(); !userIds_1_1.done; userIds_1_1 = userIds_1.next()) {
                var userId = userIds_1_1.value;
                if (!profiles[userId] && userId !== currentUserId) {
                    needProfiles.push(userId);
                }
                if (statuses[userId] !== constants_1.General.ONLINE) {
                    needStatuses.push(userId);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (userIds_1_1 && !userIds_1_1.done && (_b = userIds_1.return)) _b.call(userIds_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (needProfiles.length > 0) {
            dispatch(users_2.getProfilesByIds(needProfiles));
        }
        if (needStatuses.length > 0) {
            dispatch(users_2.getStatusesByIds(needStatuses));
        }
        return { data: true };
    };
}
var lastTimeTypingSent = 0;
function userTyping(channelId, parentPostId) {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state, config, t, stats, membersInChannel;
        return tslib_1.__generator(this, function (_a) {
            state = getState();
            config = general_1.getConfig(state);
            t = Date.now();
            stats = channels_1.getCurrentChannelStats(state);
            membersInChannel = stats ? stats.member_count : 0;
            if (((t - lastTimeTypingSent) > parseInt(config.TimeBetweenUserTypingUpdatesMilliseconds, 10)) &&
                (membersInChannel < parseInt(config.MaxNotificationsPerChannel, 10)) && (config.EnableUserTypingMessages === 'true')) {
                websocket_client_1.default.userTyping(channelId, parentPostId);
                lastTimeTypingSent = t;
            }
            return [2 /*return*/, { data: true }];
        });
    }); };
}
exports.userTyping = userTyping;
function removeNotVisibleUsers() {
    var _this = this;
    return function (dispatch, getState) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var state, knownUsers, fetchResult, err_1, allUsers, usersToRemove, actions, _a, _b, userToRemove;
        var e_4, _c;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    state = getState();
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, dispatch(users_2.getKnownUsers())];
                case 2:
                    fetchResult = _d.sent();
                    knownUsers = new Set(fetchResult.data);
                    return [3 /*break*/, 4];
                case 3:
                    err_1 = _d.sent();
                    return [2 /*return*/, { error: err_1 }];
                case 4:
                    knownUsers.add(users_1.getCurrentUserId(state));
                    allUsers = Object.keys(users_1.getUsers(state));
                    usersToRemove = new Set(allUsers.filter(function (x) { return !knownUsers.has(x); }));
                    actions = [];
                    try {
                        for (_a = tslib_1.__values(usersToRemove.values()), _b = _a.next(); !_b.done; _b = _a.next()) {
                            userToRemove = _b.value;
                            actions.push({ type: action_types_1.UserTypes.PROFILE_NO_LONGER_VISIBLE, data: { user_id: userToRemove } });
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    if (actions.length > 0) {
                        dispatch(actions_1.batchActions(actions));
                    }
                    return [2 /*return*/, { data: true }];
            }
        });
    }); };
}
exports.removeNotVisibleUsers = removeNotVisibleUsers;
function handleGroupUpdatedEvent(msg) {
    var _this = this;
    return function (dispatch) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var data;
        return tslib_1.__generator(this, function (_a) {
            try {
                data = msg.data ? JSON.parse(msg.data.group) : null;
            }
            catch (err) {
                return [2 /*return*/, { error: err }];
            }
            if (data) {
                dispatch({
                    type: action_types_1.GroupTypes.RECEIVED_GROUP,
                    data: data,
                });
            }
            return [2 /*return*/, { data: true }];
        });
    }); };
}
function handleReceivedGroupAssociatedToTeamEvent(msg) {
    return function (dispatch) {
        dispatch({
            type: action_types_1.GroupTypes.RECEIVED_GROUP_ASSOCIATED_TO_TEAM,
            data: { teamID: msg.broadcast.team_id, groups: [{ id: msg.data.group_id }] }
        });
        return { data: true };
    };
}
function handleReceivedGroupNotAssociatedToTeamEvent(msg) {
    return function (dispatch) {
        dispatch({
            type: action_types_1.GroupTypes.RECEIVED_GROUP_NOT_ASSOCIATED_TO_TEAM,
            data: { teamID: msg.broadcast.team_id, groups: [{ id: msg.data.group_id }] }
        });
        return { data: true };
    };
}
function handleReceivedGroupAssociatedToChannelEvent(msg) {
    return function (dispatch) {
        dispatch({
            type: action_types_1.GroupTypes.RECEIVED_GROUP_ASSOCIATED_TO_CHANNEL,
            data: { channelID: msg.broadcast.channel_id, groups: [{ id: msg.data.group_id }] }
        });
        return { data: true };
    };
}
function handleReceivedGroupNotAssociatedToChannelEvent(msg) {
    return function (dispatch) {
        dispatch({
            type: action_types_1.GroupTypes.RECEIVED_GROUP_NOT_ASSOCIATED_TO_CHANNEL,
            data: { channelID: msg.broadcast.channel_id, groups: [{ id: msg.data.group_id }] }
        });
        return { data: true };
    };
}
function handleWarnMetricStatusReceivedEvent(msg) {
    return function (dispatch) {
        dispatch({
            type: action_types_1.GeneralTypes.WARN_METRIC_STATUS_RECEIVED,
            data: JSON.parse(msg.data.warnMetricStatus),
        });
        return { data: true };
    };
}
function handleWarnMetricStatusRemovedEvent(msg) {
    return function (dispatch) {
        dispatch({
            type: action_types_1.GeneralTypes.WARN_METRIC_STATUS_REMOVED,
            data: { id: msg.data.warnMetricId },
        });
        return { data: true };
    };
}
//# sourceMappingURL=websocket.js.map